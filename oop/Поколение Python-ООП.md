# 3. Введение в ООП
## 3.1 Введение в ООП
### Тема урока: введение в ООП

1. Процедурное программирование
2. Объектно-ориентированное программирование (ООП)
3. Преимущества и недостатки ООП

**Аннотация.** Урок посвящен введению в ООП.

### Процедурное и объектно-ориентированное программирование

В настоящее время в программировании применяются два подхода: **процедурное** и **объектно-ориентированное**. Оба подхода объединены общей целью — сделать процесс программирования максимально эффективным. Это значит, что благодаря им разработка программного обеспечения становится более простой для понимания, легко масштабируемой и содержащей минимальное количество ошибок.

По сути, любая программа представляет собой совокупность данных и операций по их обработке. В языках, в основе работы которых лежит подход процедурного программирования (C, Pascal, BASIC), главным является код для обработки данных. При этом сами данные имеют второстепенное значение.

Первые языки программирования были процедурными, при этом программа состояла из одной или нескольких процедур. Процедура — это независимая именованная часть программы, которую после однократного описания можно многократно вызвать по имени из последующих частей програ[[]]ммы для выполнения определенных действий. Процедура может рассматриваться просто как функция, которая выполняет определенную задачу, такую как сбор вводимых пользователем данных, выполнение вычислений, чтение и запись файлов, вывод результатов и т. д.

Процедура и функция имеют общее название — подпрограмма. В более ранних языках программирования функцию от процедуры отличало то, что функция всегда имела возвращаемое значение, а процедура нет.

Программы, которые мы писали до сих пор, были по своей природе процедурными. Как правило, процедуры оперируют данными, которые существуют отдельно от процедур. В процедурной программе данные обычно передаются из одной процедуры в другую.

![](https://ucarecdn.com/d6668999-6f9d-4715-bb0b-a25bae2f824e/)

По мере увеличения и усложнения программы разделение данных и программного кода, который оперирует данными, может привести к проблемам.

Предположим, что мы создали программу для обработки базы данных клиентов. Эта программа первоначально разрабатывалась с использованием трех переменных, которые ссылаются на имя, адрес и телефонный номер клиента, и большинство функций в программе оперировали именно этими тремя переменными (данными).

Созданная программа успешно работала в течение некоторого времени, однако мы решили ее обновить, внедрив несколько новых возможностей, а также расширить набор обрабатываемых данных, добавив к уже имеющимся фамилию, отчество и дополнительный телефонный номер клиента. Для удобства данные об одном клиенте было решено хранить в списке.

Это означает, что нам необходимо изменить все разработанные функции таким образом, чтобы они принимали список и работали с ним вместо этих трех переменных. Внесение таких масштабных модификаций не только предполагает большой объем работы, но и повышает вероятность появления ошибок в работе программного кода.

В отличие от процедурного программирования, в центре внимания которого находится создание процедур, объектно-ориентированное программирование сосредоточено на создании объектов. Объект — это программная сущность, которая содержит данные и процедуры. Находящиеся внутри объекта данные называются **атрибутами**. Атрибуты — это просто переменные, которые ссылаются на данные. Выполняемые объектом процедуры называются **методами**. Методы объекта — это функции, которые, как правило, выполняют операции с атрибутами. В концептуальном плане объект представляет собой автономную единицу, которая состоит из атрибутов и методов.

Например, когда мы смотрим на какого-либо человека, мы видим его как объект. У человека имеются такие атрибуты, как цвет глаз, возраст, вес и т. д. Человек также выполняет различные действия, он ходит, говорит, программирует, проходит курсы "Поколение Python", дышит и т. д.

Таким образом, в основе ООП лежит простая и элегантная идея, в соответствии с которой главными в программе являются **данные**. Именно они определяют, какие методы будут использоваться для их обработки. То есть данные первичны, код для обработки этих данных — вторичен.

![](https://ucarecdn.com/9345a0be-110d-4ca6-80b0-06ea530aaa67/)

В объектно-ориентированном программировании атрибуты и методы размещаются в рамках одного объекта, в то время как в процедурном программировании атрибуты и методы обычно разделяются.

ООП решает проблему разделения программного кода и данных посредством **инкапсуляции** и **сокрытия данных**. Инкапсуляция обозначает объединение данных и процедур в одном объекте. Сокрытие данных связано со способностью объекта скрывать свои атрибуты от программного кода, который находится за пределами объекта. Только методы объекта могут непосредственно получать доступ и вносить изменения в атрибуты объекта. Объект, как правило, скрывает свои данные, но позволяет внешнему коду получать доступ к своим методам. Как показано на рисунке ниже, методы объекта предоставляют программному коду за пределами объекта косвенный доступ к атрибутам объекта.

![](https://ucarecdn.com/81ef579f-3190-41b0-bc61-0c49b92b1729/)

Инкапсуляцию и сокрытие данных часто объединяют в одно понятие и называют просто инкапсуляцией.

Когда атрибуты объекта скрыты от внешнего кода и доступ к атрибутам данных ограничен методами объекта, атрибуты защищены от случайного повреждения. Кроме того, программному коду за пределами объекта не нужно знать о формате или внутренней структуре данных объекта. Программный код взаимодействует только с методами объекта. Когда программист меняет структуру внутренних атрибутов, он также меняет методы объекта, чтобы они могли должным образом оперировать данными. Однако приемы взаимодействия внешнего кода с методами не меняются.

### Возможность многократного использования объекта

В дополнение к решению проблем разделения данных и процедур применение ООП также поддерживает идею многократного использования объектов. Объект не является автономной программой. Напротив, он используется программами, которым нужен его функционал.

Например, Тимур, будучи программистом, разработал ряд объектов для визуализации трехмерных изображений. Он силен в математике и достаточно много знает о компьютерной графике, поэтому его объекты запрограммированы так, чтобы выполнять все необходимые математические операции с 3D графикой и справляться с компьютерным видеооборудованием.

Для Артура, который пишет программу по заказу архитектурной фирмы, требуется, чтобы его приложение выводило 3D изображения зданий. Поскольку он не обладает большим объемом знаний в области компьютерной графики, то может применить объекты Тимура для выполнения своих задач.

### Преимущества и недостатки ООП

К преимуществам ООП можно отнести:

**Модульность.** ООП подход позволяет сделать код более структурированным, в котором легко разобраться стороннему человеку. Благодаря инкапсуляции уменьшается количество ошибок и ускоряется разработка с участием большого количества программистов, потому что каждый может работать независимо друг от друга.

**Гибкость.** ООП код легко развивать, дополнять и изменять. Взаимодействие с объектами, а не логикой упрощает понимание кода.

**Экономия времени.** Возможность многократного использования объектов, что позволяет не писать один и тот же код много раз.

**Безопасность.** Программу сложно сломать, так как инкапсулированный код недоступен извне.

К недостаткам ООП можно отнести:

**Сложный старт**. Чтобы пользоваться ООП, нужно сначала изучить теорию и освоить процедурный подход, поэтому порог входа достаточно высок.

**Снижение производительности.** ООП подход немного снижает производительность кода в целом. Программы работают несколько медленнее из-за особенностей доступа к данным и большого количества сущностей.

**Большой размер программы.** Код, написанный с использованием ООП, обычно длиннее и занимает больше места на диске, чем процедурный. Это происходит потому, что в такой программе хранится больше конструкций, чем в обычной процедурной программе.

### Примечания

**Примечание 1.** Процедурное программирование подходит для простых программ, где весь функционал можно реализовать несколькими десятками процедур (функций). Функции аккуратно вложены друг в друга и легко взаимодействуют посредством передачи данных из одной в другую. При этом в больших программах, написанных с помощью процедурного подхода, наличие сотен функций нередко приводит к ошибкам и [спагетти-коду](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B0%D0%B3%D0%B5%D1%82%D1%82%D0%B8-%D0%BA%D0%BE%D0%B4).

**Примечание 2.** Истоки ООП берут начало с 60-х годов XX века. Однако окончательное формирование основополагающих принципов и популяризацию идеи следует отнести к 80-м годам. Большой вклад внес [Алан Кей](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D0%B9,_%D0%90%D0%BB%D0%B0%D0%BD_%D0%9A%D1%91%D1%80%D1%82%D0%B8%D1%81).

**Примечание 3.** Первый объектно-ориентированный язык [SmallTalk](https://ru.wikipedia.org/wiki/Smalltalk) был разработан фирмой Xerox в 1970-х годах.

**Примечание 4.** В ООП языках, как правило, нет такого понятия, как глобальные данные. По этой причине в них обеспечивается высокая степень целостности данных.

**Примечание 5.** Коммуникация между данными и функциями в процедурном программировании осуществляется посредством глобальных данных. Коммуникация между объектами в ООП происходит без использования глобальных данных.

## 3.2 Основы и принципы ООП
### Тема урока: основы и принципы ООП

1. Классы и объекты
2. Принципы ООП

**Аннотация.** Урок посвящен основным понятиям и принципам ООП.

### Классы и объекты

Мир, в котором мы живем, состоит из объектов. Это деревья, солнце, горы, дома, машины и т. д. Каждый из этих объектов имеет свое предназначение и собственный набор характеристик. Именно объектная картина реального мира легла в основу ООП.

Ключевыми понятиями в ООП являются **классы** и **объекты**, и мы должны хорошо понимать разницу между ними.

**Класс** — это шаблон кода, по которому создаются объекты. Класс описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением. То есть сам по себе класс ничего не делает, но с его помощью можно создать объект и уже его использовать в работе.

**Объект** — это программная сущность, обладающая определённым состоянием (атрибуты) и поведением (методы). Объект также можно считать конкретным представителем класса.

Мы можем представить класс как строительный проект, на основе которого будут возводиться реальные объекты. Класс выполняет аналогичные задачи, что и проект дома. При этом сам проект не является домом, он является подробным описанием дома. По желанию заказчика может быть построено несколько идентичных зданий на основе одного и того же проекта.

Данная идея продемонстрирована ниже:

![](https://ucarecdn.com/09ccf13e-8857-4e06-a49b-aa53ef0c8fb3/-/crop/885x578/0,40/-/preview/)

Разницу между классом и объектом можно представить по-другому.

Рассмотрим класс **Автомобиль**. Если мыслить абстрактно, то он представляет собой набор чертежей и инструкций, с помощью которых можно собрать машину. При этом каждая машина, которую мы будем собирать, должна обладать рядом характеристик, которые соответствуют нашему классу. Например:

1. цвет
2. объем двигателя
3. мощность
4. тип коробки передач

Также наш автомобиль может выполнять какие-то действия, характерные для всего класса. Например:

1. ехать
2. остановиться
3. заправиться
4. поставить на сигнализацию

Все объекты создаются по одному шаблону, то есть на выходе обязательно будут автомобили. Они будут иметь какой-то цвет, ехать они будут за счет наличия в них двигателя, скорость будет регулироваться с помощью коробки передач. Также объекты данного класса будут обладать одинаковыми методами: все машины этого класса будут ездить, периодически им будет нужна заправка, а от угона они будут защищены сигнализацией.

У созданных объектов могут различаться значения, описывающие состояние (атрибуты). Одна машина черная, другая — желтая. У одной объем двигателя 28942894 см3см3 и роботизированная коробка передач, а у другой — 19971997 см3см3 и автоматическая коробка передач.

**Объект 1.** Автомобиль Porsche Macan.

Атрибуты:

1. цвет: черный
2. объем двигателя: 28942894 см3см3
3. мощность: 440440 л.с.
4. тип коробки передач: роботизированная

Методы:

1. ехать
2. остановиться
3. заправиться
4. поставить на сигнализацию

**Объект 2.** Автомобиль BMW X3.

Атрибуты:

1. цвет: желтый
2. объем двигателя: 19971997 см3см3
3. мощность: 245245 л.с.
4. тип коробки передач: автоматическая

Методы:

1. ехать
2. остановиться
3. заправиться
4. поставить на сигнализацию

Создаваемые классом объекты похожие и разные одновременно. Различаются, как правило, атрибутами. Методы остаются одинаковыми.

Итак, класс – это описание объекта. Программа может использовать класс для создания такого количества объектов определенного типа, какое понадобится. Каждый объект, который создается на основе класса, называется **экземпляром класса** или **объектом класса**.

### Примечания

**Примечание 1.** Основное преимущество ООП перед процедурным программированием — изоляция кода на уровне классов, что позволяет писать более простой и лаконичный код.

**Примечание 2.** Фактически попытка объяснить классы и объекты подобна стремлению решить дилемму "что было раньше — курица или яйцо?". В случае с объектно-ориентированным программированием, в отличие от дилеммы "что было раньше — курица или яйцо?", мы знаем, что первым был именно класс. Нельзя создать экземпляр класса без самого класса.

### Принципы ООП

Исторически сложилось так, что ООП основывается на четырех принципах: 

- абстракция
- инкапсуляция
- наследование
- полиморфизм

Иногда количество принципов сокращают до трех, опуская принцип абстракции.

#### Абстракция

**Абстракция** — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором атрибутов и методов и при этом с достаточной точностью для решаемой задачи.

Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации. Пользователь типа не имеет прямого доступа к его реализации, но может работать с данными через предоставленный набор операций. Преимущество абстракции данных в разделении операций над данными и внутреннего представления этих данных, что позволяет изменять реализацию, не затрагивая пользователей данного типа.

**Пример 1.** Объекту класса Программист вряд ли понадобятся свойства "умение готовить еду" или "любимый цвет". Они не влияют на его особенности как программиста. А вот "основной язык программирования" и "рабочие навыки" — важные свойства, без которых программиста не опишешь.

**Пример 2.** Человек, управляющий скутером, знает, что при нажатии на гудок издается звук, но зачастую он не имеет представления о том, как на самом деле этот звук создается при нажатии на гудок.

Принцип абстракции позволяет нам скрывать детали и раскрывать только основные черты объекта.

#### Инкапсуляция

**Инкапсуляция** имеет два основных смысла. С одной стороны, она объединяет атрибуты и методы в одном объекте. С другой стороны, инкапсуляция обозначает сокрытие данных, то есть невозможность напрямую получить доступ к внутренней структуре объекта, так как это может быть небезопасно. Например, наполнить желудок едой можно напрямую, положив еду в желудок. Но это опасно. Поэтому прямой доступ к желудку закрыт. Чтобы наполнить его едой, нужно совершить ритуал через элемент интерфейса под названием рот.

Принцип инкапсуляции позволяет объектам содержать как свои данные, так и поведение, а также скрывать то, что ему потребуется, от внешнего программного кода.

#### Наследование

**Наследование** — способ создания класса на основе уже существующего, при котором **дочерний класс** заимствует атрибуты и методы **родительского класса**, а также добавляет собственные.

Дочерний класс часто называют **производным классом**, **наследником** или **потомком**, а родительский класс – **предком** или просто **родителем**.

Проведем аналогию с реальным миром. Если мы возьмем конкретный стол, то это объект, но не класс. А вот общее представление о столах, их назначении – это класс. Ему принадлежат все реальные объекты столов, какими бы они ни были. Класс столов дает общую характеристику всем столам в мире, описывая их общие свойства. Однако можно разделить все столы на письменные, обеденные и журнальные и для каждой группы создать свой класс, который будет наследником общего класса, но помимо этого будет вносить ряд своих особенностей.

Таким образом, общий класс будет родительским, а классы групп – дочерними. Дочерние классы наследуют особенности родительских, однако дополняют или в определенной степени модифицируют их характеристики. Когда мы создаем конкретный экземпляр стола, то должны выбрать, какому классу столов он будет принадлежать. Если он принадлежит классу журнальных столов, то получит все характеристики общего класса столов и класса журнальных столов. Но не особенности письменных и обеденных.

![](https://ucarecdn.com/2bd774f7-6ebe-43a5-a453-52e47aced103/)

Наследование может быть одиночным, а может быть множественным. При множественном наследовании, у класса может быть более одного родителя. В этом случае класс наследует атрибуты и методы всех родительских классов. Достоинства такого подхода в большей гибкости. В то же время множественное наследование — потенциальный источник ошибок, которые могут возникнуть из-за наличия одинаковых имён атрибутов и методов в родительских классах.

#### Полиморфизм

**Полиморфизм** – это множество форм. Однако в понятиях ООП имеется в виду, скорее, обратное. Объекты разных классов, с разной внутренней реализацией, могут иметь одинаковые интерфейсы. Например, для чисел есть операция сложения, обозначаемая знаком `+`. Однако мы можем определить класс, объекты которого также будут поддерживать операцию, обозначаемую этим знаком. Но это вовсе не значит, что объекты должны быть числами и будет получаться какая-то сумма. Операция `+` для объектов нашего класса может значить что-то иное. Но интерфейс, в данном случае это знак `+`, у чисел и нашего класса будет одинаков. Полиморфность же проявляется во внутренней реализации и результате операции.

Мы уже сталкивались с полиморфизмом операции `+` в языке Python. Для чисел она обозначает сложение, а для строк – конкатенацию. Внутренняя реализация кода для этой операции у чисел отличается от реализации таковой для строк.

Полиморфизм позволяет выполнять одно действие разными способами, другими словами, он позволяет определять один интерфейс и иметь множество реализаций.

#### Примечания

**Примечание 1.** Наследование является механизмом повторного использования кода. Установка отношения наследования между классами порождает иерархию классов. Наследование полезно с точки зрения повторного использования кода. Однако при использовании наследования мы можем создавать сильно связанные иерархии. Если не быть осторожным, наследование может привести к огромной иерархической структуре классов, которую трудно понять и поддерживать.

(https://ucarecdn.com/89261830-31bb-42ab-9162-ffaad384bca8/)

**Примечание 2.** При наследовании дочерний класс наследует все атрибуты и методы родительского класса, а также может дополнять (переопределять) их собственными.

**Примечание 3.** Хорошие статьи по основам ООП доступны по [ссылке](https://habr.com/ru/post/87119/) и [ссылке](https://habr.com/ru/post/87205/).

# 4. Атрибуты, свойства и методы
## 4.1 Атрибуты объектов и классов
### Тема урока: атрибуты объектов и классов

1. ООП в Python
2. Функция `dir()`
3. Атрибуты объектов
4. Атрибуты классов
5. Атрибут `__dict__`
6. Функции `getattr(), setattr(), hasattr()` и `delattr()`

**Аннотация.** Урок посвящен атрибутам объектов и классов в Python.

### ООП в Python

Язык программирования Python появился в 1991 году. К этому времени ООП уже становилось популярным и появлялись первые объектно-ориентированные языки программирования. Поэтому, ориентируясь на чужие успехи и неудачи, Гвидо ван Россум и его коллеги смогли спроектировать достаточно простую и мощную реализацию ООП в Python. Python поддерживает ООП на сто процентов: все данные в нем являются объектами. Числа, строки, списки, словари, функции, модули и даже сами типы данных — все это объекты. Поэтому их можно присваивать переменным, помещать в списки, хранить в словарях, передавать в функции в качестве аргументов и т. д.

Гвидо ван Россум разработал язык Python по принципу "всё является объектом". Подробнее об этом можно почитать в его блоге по [ссылке](http://python-history.blogspot.com/2009/02/first-class-everything.html).

Хотя Python — это объектно-ориентированный язык, в предыдущих курсах мы намеренно избегали рассмотрения ООП. Мы убеждены, что проще и интереснее начать изучение Python, не зная обо всех тонкостях объектно-ориентированного программирования, несмотря на то, что оно всегда было рядом с нами.

Приведенный ниже код:

```python
num = 10
flag = True
text = 'OOP'

print(type(num))
print(type(flag))
print(type(text))
```

выводит:

```no-highlight
<class 'int'>
<class 'bool'>
<class 'str'>
```

Приведенный ниже код:

```python
import math

def cube(num):
    return num ** 3

print(type(math))
print(type(cube))
print(type(print))
print(type(math.factorial))
print(type(str.upper))
print(type(int))
```

выводит:

```no-highlight
<class 'module'>
<class 'function'>
<class 'builtin_function_or_method'>
<class 'builtin_function_or_method'>
<class 'method_descriptor'>
<class 'type'>
```

Как мы видим, в Python всё является объектом, принадлежащим соответствующему классу.

### Функция dir()

В предыдущих курсах мы нередко сталкивались с типами данных, объекты которых имеют различные атрибуты и методы. Например, объекты типа `date` из модуля `datetime` обладают немалым количеством полезных атрибутов и методов.

 Тип данных и класс — это одно и то же.

Приведенный ниже код:

```python
from datetime import date

today = date(2022, 9, 25)

print(today.year)                 # год
print(today.month)                # месяц
print(today.day)                  # день
print(today.isoweekday())         # порядковый номер дня недели
print(today.toordinal())          # номер дня, соответствующий дате 2022-09-25
```

выводит:

```no-highlight
2022
9
25
7
738423
```

В примере выше `year, month` и `day` являются атрибутами, а `isoweekday()` и `toordinal()` — методами.

Для получения списка всех атрибутов и методов объекта можно воспользоваться встроенной функцией `dir()`.

Приведенный ниже код:

```python
from datetime import date

today = date(2022, 9, 25)

print(dir(today))
```

выводит:

```no-highlight
['__add__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__radd__', '__reduce__', '__reduce_ex__', '__repr__', '__rsub__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', 'ctime', 'day', 'fromisocalendar', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'isocalendar', 'isoformat', 'isoweekday', 'max', 'min', 'month', 'replace', 'resolution', 'strftime', 'timetuple', 'today', 'toordinal', 'weekday', 'year']
```

### Создание пользовательских классов и их объектов

В Python классы создаются с помощью инструкции `class`, за которой следует имя класса, после которого ставится двоеточие. Далее с новой строки и с отступом реализуется тело класса:

```python
class <название класса>:
    <тело класса>
```

Пример объявления класса с минимально возможным функционалом:

```python
class Cat:
    pass
```

Здесь для задания класса используется инструкция `class`, далее следует имя класса `Cat` и двоеточие. После идет тело класса, которое в нашем случае представлено оператором `pass`, который сам по себе ничего не делает и является просто заглушкой.

Как правило, имя класса начинается с заглавной буквы и обычно является существительным или словосочетанием. Имена классов соответствуют соглашению Upper Сamel Сase.

Upper Сamel Сase (UpperCamelCase) — стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы.

Чтобы создать объект класса, нужно воспользоваться следующим синтаксисом:

```python
<имя переменной> = <имя класса>()
```

В качестве примера создадим экземпляр класса `Cat`:

```python
cat = Cat()
```

Теперь переменная `cat` содержит ссылку на объект — **экземпляр класса** `Cat`. Стоит отметить, что объект класса и экземпляр класса — это одно и то же, однако на практике для однозначности используют именно сочетание экземпляр класса, так как сам класс, по сути, тоже является объектом.

### Атрибуты объектов

Вернемся к созданному ранее классу `Cat` и создадим два его экземпляра:

```python
class Cat:
    pass


cat1 = Cat()
cat2 = Cat()
```

Переменные `cat1` и `cat2` содержат ссылки на два разных объекта — экземпляра класса `Cat`, которые можно наделить различными атрибутами:

```python
cat1.breed = 'Британский'          # порода кошки
cat1.name = 'Кемаль'               # имя кошки
cat1.age = 1                       # возраст кошки

cat2.name = 'Роджер'
cat2.age = 5
```

Теперь `cat1` — это британский кот с именем Кемаль, которому `1` год, а `cat2` — кот с именем Роджер, которому `5` лет. Важно заметить, что указанные атрибуты принадлежат конкретному экземпляру класса `Cat`. Например, `cat2` не содержит атрибута `breed`, который есть у `cat1`.

К установленным объекту атрибутам можно обращаться, а также изменять их.

Приведенный ниже код:

```python
cat = Cat()

cat.breed = 'Британский'
cat.name = 'Кемаль'
cat.age = 1

print(cat.breed, cat.name)        # обращение к атрибутам

cat.age += 2                      # изменение значения атрибута
print(cat.age)
```

выводит:

```no-highlight
Британский Кемаль
3
```

При обращении к несуществующему атрибуту будет возбуждено исключение `AttributeError`.

Приведенный ниже код:

```python
cat = Cat()

cat.breed = 'Британский'
cat.name = 'Кемаль'
cat.age = 1

print(cat.color)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Cat' object has no attribute 'color'
```

### Атрибуты класса

Мы также можем устанавливать атрибуты на уровне всего класса, такие атрибуты называются **атрибутами класса**. Их значения одинаковы для всех экземпляров этого класса:

```python
class Cat:
    night_vision = True
    paws_count = 4
```

Теперь класс `Cat` имеет два атрибута, доступных по умолчанию всем его экземплярам.

Приведенный ниже код:

```python
class Cat:
    night_vision = True
    paws_count = 4


cat1 = Cat()
cat2 = Cat()

print(cat1.night_vision)
print(cat2.paws_count)
```

выводит:

```no-highlight
True
4
```

Так как атрибуты `night_vision` и `paws_count` являются атрибутами всего класса, то мы можем получить к ним доступ, используя точечную запись с именем класса.

Приведенный ниже код:

```python
class Cat:
    night_vision = True
    paws_count = 4


print(Cat.night_vision)
print(Cat.paws_count)
```

выводит:

```no-highlight
True
4
```

Как правило, названия атрибутов объектов и классов пишутся с маленькой буквы и соответствуют соглашению snake case.

Snake Case (snake_case) — стиль написания составных слов, при котором несколько слов разделяются символом нижнего подчеркивания (`_`) и не имеют пробелов в записи, причём каждое слово пишется с маленькой буквы.

### Атрибут __dict__

Все атрибуты, которыми мы наделяем созданные объекты, хранятся в специальном словаре, который доступен в качестве атрибута `__dict__`.

Приведенный ниже код:

```python
class Cat:
    pass


cat = Cat()

cat.breed = 'Британский'
cat.name = 'Кемаль'
cat.age = 1

print(cat.__dict__)
```

выводит:

```no-highlight
{'breed': 'Британский', 'name': 'Кемаль', 'age': 1}
```

Аналогичным образом мы можем получить доступ к атрибутам класса.

Приведенный ниже код:

```python
class Cat:
    night_vision = True
    paws_count = 4


print(Cat.__dict__)
```

выводит:

```no-highlight
{'__module__': '__main__', 'night_vision': True, 'paws_count': 4, '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>, '__doc__': None}
```

Обратите внимание, что помимо созданных нами атрибутов класса `night_vision` и `paws_count`, словарь `__dict__` также содержит и другие служебные атрибуты, в том числе описание самого словаря `__dict__`.

 Атрибуты объектов и классов, которые определил программист, называются **пользовательскими атрибутами**.

### Примечания

**Примечание 1.** ООП — один из самых мощных инструментов Python, однако нам необязательно его использовать. Мы можем писать мощные и эффективные программы и без него.

**Примечание 2.** Имена классов по стандарту именования PEP 8 должны соответствовать соглашению UpperCamelCase, однако​  
встроенные классы (`int, float, str, list, tuple, dict` и др.) этому правилу не следуют.

**​Примечание 3.** Аналогично функциям, классы поддерживают строку документации, которая доступна через атрибут `__doc__`.

Приведенный ниже код:

```python
class Cat:
    """Класс, описывающий кошку"""
    night_vision = True
.   paws_count = 4


print(Cat.__doc__)
```

выводит:

```no-highlight
Класс, описывающий кошку
```

**Примечание 4.** Прочитать подробнее о разных стилях именования можно по [ссылке](https://khalilstemmler.com/blogs/camel-case-snake-case-pascal-case/).

**Примечание 5.** Прочитать про соглашения об именах в Python можно на [русском](https://docs-python.ru/tutorial/pep-rukovodstvo-stilju-koda-python/soglashenija-imenah/) и [английском](https://visualgit.readthedocs.io/en/latest/pages/naming_convention.html) языках.

**Примечание 6.** Тип любого объекта можно получить через атрибут `__class__`.

Приведенный ниже код:

```python
class Cat:
    pass


cat = Cat()

print(type(cat))
print(cat.__class__)
print(type(cat) == cat.__class__)
```

выводит:

```no-highlight
<class '__main__.Cat'>
<class '__main__.Cat'>
True
```

**Примечание 7.** Атрибут класса можно изменить только через сам класс.

Приведенный ниже код:

```python
class Cat:
    night_vision = True


cat1 = Cat()
cat2 = Cat()

Cat.night_vision = False

print(cat1.night_vision)
print(cat2.night_vision)
```

выводит:

```no-highlight
False
False
```

При попытке изменения атрибута класса через его экземпляр мы лишь добавляем этому экземпляру атрибут с аналогичным именем.

Приведенный ниже код:

```python
class Cat:
    night_vision = True


cat1 = Cat()
cat2 = Cat()

cat1.night_vision = False

print(cat1.night_vision, cat1.__dict__)
print(cat2.night_vision, cat2.__dict__)
```

выводит:

```no-highlight
False {'night_vision': False}
True {}
```

Также в примере выше можно заметить, что поиск атрибута происходит сначала в словаре атрибутов экземпляра (`cat1.__dict__, cat2.__dict__`), а затем в словаре атрибутов класса (`Cat.__dict__`).

### Функции, работающие с атрибутами

Помимо уже знакомой нам точечной нотации, для работы с атрибутами классов и объектов можно использовать набор функций, позволяющих устанавливать атрибуты, получать их значения, удалять их, а также проверять их наличие у соответствующего класса или объекта.

#### Функция getattr()

Функция `getattr()` принимает три аргумента:

- `obj` — объект
- `name` — имя атрибута
- `default` — значение по умолчанию

Функция возвращает значение атрибута `name` объекта `obj`. Если объект `obj` не имеет атрибута `name`, возвращается значение по умолчанию `default`. Если значение по умолчанию не указано, возбуждается исключение `AttributeError`.

Приведенный ниже код: 

```python
class Cat:
    pass


cat = Cat()

cat.name = 'Кемаль'

print(getattr(cat, 'name'))
print(getattr(cat, 'age', None))
```

выводит:

```no-highlight
Кемаль
None
```

Так же, как и через точечную нотацию, с помощью функции `getattr()` можно получать значения атрибутов класса через экземпляры этого класса.

Приведенный ниже код:

```python
class Cat:
    night_vision = True
    paws_count = 4


cat = Cat()

print(getattr(cat, 'night_vision'))
print(getattr(cat, 'paws_count'))
```

выводит:

```no-highlight
True
4
```

#### Функция setattr()

Функция `setattr()` принимает три аргумента:

- `obj` — объект
- `name` — имя атрибута
- `value` — значение атрибута

Функция устанавливает объекту `obj` атрибут `name` со значением `value`. Если объект `obj` уже имеет атрибут `name`, его значение перезаписывается.

Приведенный ниже код: 

```python
class Cat:
    pass


cat = Cat()

cat.name = 'Кемаль'

setattr(cat, 'age', 1)
setattr(cat, 'name', 'Роджер')

print(cat.age)
print(cat.name)
```

выводит:

```no-highlight
1
Роджер
```

####  Функция delattr()

Функция `delattr()` принимает два аргумента:

- `obj` — объект
- `name` — имя атрибута

Функция удаляет атрибут `name` у объекта `obj`. Если объект не имеет атрибута `name`, возбуждается исключение `AttributeError`.

Приведенный ниже код:

```python
class Cat:
    pass


cat = Cat()

cat.name = 'Кемаль'
cat.age = 1

print(cat.__dict__)

delattr(cat, 'name')
delattr(cat, 'age')

print(cat.__dict__)
```

выводит:

```no-highlight
{'name': 'Кемаль', 'age': 1}
{}
```

При попытке удаления атрибута класса через его экземпляр с помощью функции `delattr()` возникнет ошибка, поскольку функция `delattr()` работает с конкретным объектом.

#### Функция hasattr()

Функция `hasattr()` принимает два аргумента:

- `obj` — объект
- `name` — имя атрибута

Функция возвращает `True`, если объект `obj` имеет атрибут `name`, или `False` в противном случае.

Приведенный ниже код: 

```python
class Cat:
    night_vision = True
    paws_count = 4


cat = Cat()

cat.name = 'Кемаль'

print(hasattr(cat, 'name'))
print(hasattr(cat, 'age'))
print(hasattr(cat, 'night_vision'))
```

выводит:

```no-highlight
True
False
True
```

## 4.2 Методы экземпляра класса. Часть 1
### Тема урока: методы экземпляра класса

1. Методы экземпляра класса
2. Метод `__init__()`
3. Аргумент `self`

**Аннотация.** Урок посвящен методам экземпляров классов в Python.

### Методы экземпляра класса

Если атрибуты отображают некоторые характеристики, которые свойственны объектам определенного класса, то методы определяют их поведение. В Python существует несколько типов методов, но в этом уроке мы сосредоточимся только на **методах экземпляра класса**. Метод экземпляра — это функция, которая определена внутри класса, принадлежит объекту этого класса и имеет доступ к атрибутам объекта.

Как правило, названия методов экземпляра являются глаголами и соответствуют соглашению Snake case.

Рассмотрим пустой класс `Cat`, определим внутри него методы экземпляра `say()` и `eat()` и попробуем применить их к конкретному объекту.

Приведенный ниже код:

```python
​class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

cat.say()
cat.eat()
```

выводит:

```python
Мяу
Мням
```

Обратите внимание, что за исключением того, что эти определения методов появляются в классе, они похожи на любое другое определение функции в Python. Они начинаются со строки заголовка, после которой идет выделенный отступом блок кода. Также следует заметить, что каждый метод имеет параметр `self`.

Параметр `self` требуется в каждом методе экземпляра. Метод оперирует атрибутами конкретного объекта, и когда метод исполняется, он должен знать, атрибутами какого объекта он должен оперировать. Именно здесь на первый план выходит параметр `self`. Когда метод вызывается, Python делает так, что параметр `self` ссылается на конкретный объект, который его вызвал в данный момент и которым вызванный метод должен оперировать.

 Параметр `self` часто называют **контекстным объектом**.

Иными словами, привычные нам вызовы методов через точечную нотацию:

```python
class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

cat.say()
cat.eat()
```

Python преобразует в следующее:

```python
class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

Cat.say(cat)
Cat.eat(cat)
```

поэтому оба приведенных выше кода являются эквивалентными и выводят:

```python
Мяу
Мням
```

Методы экземпляра доступны всем экземплярам соответствующего класса, поэтому мы можем создать несколько объектов класса `Cat`, и все они будут иметь общий функционал.

Приведенный ниже код:

```python
​class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat1 = Cat()
cat2 = Cat()

cat1.say()
cat2.eat()
```

выводит:

```no-highlight
​Мяу
Мням
```

Важно отметить, что параметр `self` — это обычная переменная, она может называться по-другому, но так категорически не рекомендуется делать. Соглашение об имени контекстного объекта — самое строгое из всех соглашений в мире Python. Если нарушить это соглашение, другие программисты просто не будут понимать ваш код. Кроме того, некоторые текстовые редакторы подсвечивают слово `self` определенным цветом, что довольно удобно.

Таким образом, при создании собственных методов экземпляра следует помнить о двух моментах:

- метод должен быть определен внутри класса (добавляется уровень отступов)
- метод всегда должен иметь хотя бы один параметр, и первый по счету параметр должен называться `self`

В примере выше методы `say()` и `eat()`, помимо экземпляра класса, не принимали никаких аргументов. Однако методы являются функциями, поэтому мы без проблем можем расширить их функционал, например, добавив дополнительный параметр.

Приведенный ниже код:

```python
class Cat:
    def say(self, sound):
        print(sound)

    def eat(self, meal):
        print(f'{meal} - это очень вкусно!')


cat1 = Cat()
cat2 = Cat()

cat1.say('Мяу')
cat1.eat('Молоко')

cat2.say('Мяяяу!')
cat2.eat('Рыба')
```

выводит:

```no-highlight
Мяу
Молоко - это очень вкусно!
Мяяяу!
Рыба - это очень вкусно!
```

### Метод __init__()

Рассмотрим следующее определение класса `Cat`:

```python
class Cat:
    pass
```

После создания экземпляра данного класса мы получаем объект, у которого нет никаких атрибутов. И если нам требуется, чтобы объект ими обладал, нам приходится определять их вручную для каждого объекта, либо определять атрибуты на уровне класса. Очевидно, оба способа имеют свои недостатки, так как в первом случае нам приходится определять каждый атрибут для каждого объекта, во втором случае — все экземпляры класса имеют атрибуты с одними и теми же значениями, что не всегда нужно. Решить данную проблему позволяет специальный метод `__init__()`.

 Метод `__init__()` называют **методом инициализации** или **инициализатором**.

Метод `__init__()` инициализирует атрибуты объекта. Сразу после создания объекта исполняется метод `__init__()`, и параметру `self` автоматически присваивается объект, который был только что создан, что позволяет тут же наделить его необходимыми атрибутами.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed                       # порода кошки
        self.name = name                         # имя кошки


cat = Cat('Британский', 'Кемаль')
```

создает экземпляр класса `Cat`, который имеет атрибуты `breed` и `name` со значениями `Британский` и `Кемаль` соответственно.

![](https://ucarecdn.com/de829ea9-39d6-4816-a0f6-3a9a593e7272/)

Важно уточнить, что метод `__init__()` исполняется после создания каждого экземпляра класса `Cat`, поэтому каждый объект будет иметь те значения атрибутов, которые были указаны при его создании.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин', 'Роджер')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
```

выводит:

```no-highlight
Британский Кемаль
Манчкин Роджер
```

Поскольку мы определили параметры `breed` и `name` для метода `__init__()`, они должны быть явно переданы при создании новых экземпляров класса `Cat`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat = Cat()
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Cat.__init__() missing 2 required positional arguments: 'breed' and 'name'
```

Однако если мы хотим, чтобы при создании объекта значения некоторых атрибутов можно было не указывать, мы можем установить им значения по умолчанию.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name=None):
        self.breed = breed
        self.name = name


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
```

выводит:

```no-highlight
Британский Кемаль
Манчкин None
```

Сигнатура метода `__init__()` полностью повторяет сигнатуру любой функции. С помощью `*args` и `**kwargs` метод `__init__()` может принимать произвольное количество позиционных и именованных аргументов соответственно.

Помимо значений аргументов, передаваемых в инициализатор, атрибутам можно устанавливать некоторые фиксированные значения.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name
        self.night_vision = True                 # способность видеть в темноте


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин', 'Роджер')

print(cat1.night_vision)
print(cat2.night_vision)
```

выводит:

```no-highlight
True
True
```

### Примечания

**Примечание 1.** Можно подумать, что метод `__init__()` отвечает за создание экземпляров класса, но это не так, он принимает в качестве аргумента уже созданный классом объект и инициализирует его.

**Примечание 2.** Возвращаемым значением метода `__init__()` должно быть значение `None`,  в противном случае будет возбуждено исключение.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name
        return self


cat = Cat('Британский', 'Кемаль')
```

приводит к возбуждению исключения:

```no-highlight
TypeError: __init__() should return None, not 'Cat'
```

**Примечание 3.** Класс может иметь только один инициализатор. При попытке определить в классе два инициализатора, предыдущий будет заменен следующим.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat = Cat('Британский', 'Кемаль')

print(cat.breed)
print(cat.name)
```

выводит:

```no-highlight
Британский
Кемаль
```

**Примечание 4.** Применение метода к объекту преобразуется в вызов функции, путем обращения к ней через соответствующий класс и передачи ей в качестве аргумента объекта, который этот метод вызвал.

Приведенный ниже код:

```python
nums = [1, 2, 3]
text = 'beegeek'

nums.append(4)
text = text.lower()
```

эквивалентен следующему коду:

```python
nums = [1, 2, 3]
text = 'beegeek'

list.append(nums, 4)
text = str.lower(text)
```

Это достаточно удобно использовать, если нам требуется воспользоваться методом как функцией.

Приведенный ниже код:

```python
names = ['timur', 'arthur', 'dima']

print(*map(str.title, names))
```

выводит:

```no-highlight
Timur Arthur Dima
```

## 4.3 Методы экземпляра класса. Часть 2
### Тема урока: методы экземпляра класса

1. Примеры проектирования классов

**Аннотация.** Урок посвящен проектированию классов.

### Примеры проектирования классов

Перед тем как вы приступите к решению задач, предлагаем вместе реализовать небольшой класс `PiggyBank`, описывающий копилку. Класс будем реализовывать постепенно, шаг за шагом развивая его функционал. 

Главной характеристикой любой копилки является количество хранящихся внутри нее монет, поэтому первое, что мы сделаем, определим метод `__init__()`, который будет принимать один аргумент — начальное количество монет внутри копилки:

```python
class PiggyBank:
    def __init__(self, balance):
        self.balance = balance                        # количество монет в копилке
```

Так как создаваемые копилки изначально, скорее всего, будут пустыми, параметру `balance` можно установить значение по умолчанию, равное `0`:

```python
class PiggyBank:
    def __init__(self, balance=0):
        self.balance = balance
```

Логичным продолжением будет реализация методов, позволяющих добавлять монету в копилку, а также вынимать монету из копилки. Назовем эти методы `add_coins()` и `remove_coins()` соответственно:

```python
class PiggyBank:
    def __init__(self, balance=0):
        self.balance = balance

    def add_coins(self):
        self.balance += 1                             # увеличиваем количество монет на единицу

    def remove_coins(self):
        self.balance -= 1                             # уменьшаем количество монет на единицу
```

Тут же мы можем разрешить методам `add_coins()` и `remove_coins()` принимать один аргумент — количество добавляемых/вынимаемых монет.

```python
class PiggyBank:
    def __init__(self, balance=0):
        self.balance = balance

    def add_coins(self, coins):
        self.balance += coins

    def remove_coins(self, coins):
        self.balance -= coins
```

На данном этапе мы уже имеем неплохой функционал: мы можем отслеживать состояние монет, а также увеличивать и уменьшать их количество.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, balance=0):
        self.balance = balance

    def add_coins(self, coins):
        self.balance += coins

    def remove_coins(self, coins):
        self.balance -= coins


piggybank = PiggyBank()

print(piggybank.balance)                              # по умолчанию баланс равен нулю 

piggybank.add_coins(4)                                # добавляем 4 монеты
piggybank.add_coins(3)                                # добавляем 3 монеты

print(piggybank.balance)

piggybank.remove_coins(2)                             # вынимаем 2 монеты
piggybank.remove_coins(1)                             # вынимаем 1 монету
piggybank.remove_coins(1)                             # вынимаем 1 монету

print(piggybank.balance)
```

выводит:

```no-highlight
0
7
3
```

Однако несложно заметить, что у такой реализации имеется ряд проблем: мы можем бесконечно пополнять копилку, а также вынимать из нее любое количество монет, в результате чего сделать баланс отрицательным.

Начнем с решения первой проблемы. Добавим методу `__init__()` дополнительный параметр `volume` со значением по умолчанию `400`, отвечающий за максимальное количество монет, которое может содержаться в копилке. Также модифицируем метод `add_coins()`, который не будет добавлять монеты в копилку, если ее вместимость не позволяет этого сделать:

```python
class PiggyBank:
    def __init__(self, balance=0, volume=400):
        self.balance = balance
        self.volume = volume                          # вместимость копилки

    def add_coins(self, coins):
        if self.balance + coins > self.volume:        # проверка на возможность добавить монеты
            print('Копилка слишком мала')
        else:
            self.balance += coins

    def remove_coins(self, coins):
        self.balance -= coins
```

Аналогично решим вторую проблему, модифицировав метод `remove_coins()`, который не будет вынимать монеты из копилки, если их в ней недостаточно:

```python
class PiggyBank:
    def __init__(self, balance=0, volume=400):
        self.balance = balance
        self.volume = volume

    def add_coins(self, coins):
        if self.balance + coins > self.volume:
            print('Копилка слишком мала')
        else:
            self.balance += coins

    def remove_coins(self, coins):
        if self.balance - coins < 0:
            print('В копилке недостаточно монет')
        else:
            self.balance -= coins
```

Теперь проверим работу модифицированных методов на практике.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, balance=0, volume=400):
        self.balance = balance
        self.volume = volume

    def add_coins(self, coins):
        if self.balance + coins > self.volume:
            print('Копилка слишком мала')
        else:
            self.balance += coins

    def remove_coins(self, coins):
        if self.balance - coins < 0:
            print('В копилке недостаточно монет')
        else:
            self.balance -= coins


piggybank = PiggyBank(0, 10)

print(piggybank.balance)    

piggybank.remove_coins(20)                            # пробуем из пустой копилки вынуть 20 монет
piggybank.add_coins(20)                               # пробуем добавить избыточное количество монет

print(piggybank.balance)
```

выводит:

```no-highlight
0
В копилке недостаточно монет
Копилка слишком мала
0
```

Вывод сообщений при попытке добавить или вынуть недопустимое количество монет можно заменить на возбуждение исключений:

```python
​class PiggyBank:
    def __init__(self, balance=0, volume=400):
        self.balance = balance
        self.volume = volume

    def add_coins(self, coins):
        if self.balance + coins > self.volume:
            raise ValueError('Копилка слишком мала')
        else:
            self.balance += coins

    def remove_coins(self, coins):
        if self.balance - coins < 0:
            raise ValueError('В копилке недостаточно монет')
        else:
            self.balance -= coins
```

Конечно, это далеко не все, улучшать класс можно и дальше, однако данного примера достаточно, чтобы не испытывать сложностей при решении представленных в данном уроке задач. Удачи!

## 4.4 Модификаторы доступа и аксессоры
### Тема урока: модификаторы доступа и аксессоры

1. Модификаторы доступа
2. Методы аксессоры (геттеры и сеттеры)

**Аннотация.** Урок посвящен модификаторам доступа и аксессорам.

### Модификаторы доступа

Ранее мы упоминали, что доступ к атрибутам объекта должны иметь только методы этого объекта. Такой подход защищает атрибуты от случайного повреждения. Однако во всех рассмотренных ранее классах атрибуты не являлись защищенными, ведь внешний код с легкостью мог получить к ним доступ .

В классических языках программирования (C++, Java, C#) доступ к атрибутам реализуется с помощью ключевых слов `protected` (защищенный), `private` (приватный) и `public` (публичный):

- доступ к защищенным атрибутам возможен только внутри этого класса, а также внутри унаследованных от него классов
- приватные атрибуты недоступны извне — с ними можно работать только внутри этого класса
- публичные атрибуты доступны для работы снаружи

С точки зрения разграничения доступа к атрибутам Python является особенным языком — в нем отсутствует механизм, который мог бы запретить внешнему коду взаимодействовать с атрибутами объекта или класса. Вместо этого создатели Python предложили следующий ряд соглашений:

- если имя атрибута начинается с одного нижнего подчеркивания (`_name`), то он считается **защищенным**
- если имя атрибута начинается с двух нижних подчеркиваний (`__name`), то он считается **приватным**

В Python все атрибуты являются публичными по умолчанию. Любой атрибут объекта может быть доступен за пределами класса, независимо от того, является он публичным, защищенным или приватным.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)
```

выводит:

```no-highlight
Кемаль
Роджер
```

Как мы видим, никаких проблем не возникает ни при обращении к атрибутам, ни при их изменении. Аналогичное поведение наблюдается и с защищенными атрибутами, то есть атрибутами, имя которых начинается с одного символа нижнего подчеркивания.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name


cat = Cat('Кемаль')
print(cat._name)

cat._name = 'Роджер'
print(cat._name)
```

выводит:

```no-highlight
Кемаль
Роджер
```

Иными словами, это больше вопрос ответственности программиста — он не должен работать за пределами класса с атрибутами, имена которых начинаются с нижнего подчёркивания.

Несколько иначе себя ведут приватные атрибуты. Если мы предварим имя атрибута двумя нижними подчеркиваниями, то есть сделаем его приватным, то код за пределами класса не сможет получить к нему доступ напрямую.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__name)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Cat' object has no attribute '__name'
```

На первый взгляд может показаться, что для внешнего кода приватного атрибута действительно не существует, однако если мы посмотрим на содержимое словаря атрибутов объекта, то увидим, что на самом деле приватный атрибут лишь получил другое имя.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__dict__)
```

выводит: 

```no-highlight
{'_Cat__name': 'Кемаль'}
```

Дело в том, что, делая атрибут приватным, на самом деле мы лишь неявно изменяем его имя. Такое поведение называется **искажением имени**.

Любой атрибут вида `__name` текстуально заменяется на `_class__name`, где `class` — это имя текущего класса.

Таким образом, возможность обратиться к приватному атрибуту, а также изменить его значение все же остается.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat._Cat__name = 'Роджер'

print(cat.__dict__)
```

выводит:

```no-highlight
{'_Cat__name': 'Роджер'}
```

#### Примечания

**Примечание 1.** Хорошая статья про именование с подчеркиванием в Python доступна по [ссылке](https://django.fun/ru/articles/python/naming-underscores-python/).

**Примечание 2.** Физически механизм ограничения доступа к атрибутам в Python реализован слабо, лишь на уровне соглашения, поэтому ответственность за соблюдение данного соглашения ложится на плечи программистов.

**Примечание 3.** Искажение имени приватного атрибута происходит лишь при его установке внутри класса. 

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat.__age = 1

print(cat.__dict__)
```

выводит:

```python
{'_Cat__name': 'Кемаль', '__age': 1}
```

###  Методы аксессоры

На практике широко принято делать все атрибуты класса и объекта защищенными или приватными, и предоставлять публичные методы для доступа к этим атрибутам и для их изменения. Так гарантируется, что класс или объект, владеющий этими атрибутами, будет держать под контролем все вносимые в них изменения.

#### Геттеры

Метод, который возвращает значение атрибута и при этом не изменяет его, называется **геттером**. Геттеры дают возможность программному коду, находящемуся за пределами класса, получать значения атрибутов безопасным способом, не подвергая эти атрибуты изменению программным кодом, находящимся вне метода.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name                               # имя кошки

    def get_name(self):                                 # геттер, используется для получения имени
        return self._name


cat = Cat('Кемаль')

print(cat.get_name())
```

выводит:

```no-highlight
Кемаль
```

#### Сеттеры

Метод, который сохраняет значение в атрибуте либо изменяет значение атрибута, называется **сеттером**. Сеттеры могут управлять тем, как атрибуты объекта изменяются. Когда программный код, находящийся вне класса, должен изменить в объекте значение атрибута, он, как правило, вызывает сеттер и передает новое значение в качестве аргумента. Если это необходимо, то метод, прежде чем он присвоит значение атрибуту, может выполнить проверку этого значения.

 Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):                           # сеттер, используется для изменения имени
        if isinstance(name, str) and name.isalpha():    # проверка имени перед заменой
            self._name = name
        else:
            raise ValueError('Некорректное имя')


cat = Cat('Кемаль')
print(cat.get_name())

cat.set_name('Роджер')
print(cat.get_name())
```

выводит:

```no-highlight
Кемаль
Роджер
```

В то время как код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')


cat = Cat('Кемаль')

cat.set_name(-1)                                        # некорректное имя
```

приводит к возбуждению исключения:

```no-highlight
ValueError: Некорректное имя
```

#### Делитеры

Метод, который удаляет атрибут из объекта, называется **делитером**. 

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    def del_name(self):                                 # делитер, используется для удаления имени
        del self._name


cat = Cat('Кемаль')

cat.del_name()

print(cat.get_name())
```

приводит к возбуждению исключения `AttributeError`:

```no-highlight
AttributeError: 'Cat' object has no attribute '_name'
```

#### Примечания

**Примечание 1.** Возбуждение исключения считается стандартной практикой при попытке установить атрибуту некорректное значение. Исключение может возбуждаться как при изменении значения атрибута, так и при создании экземпляра класса. В качестве примера рассмотрим тип `date` из модуля `datetime`.

Приведенный ниже код:

```python
from datetime import date

today = date(2022, 20, 3)                               # некорректное значение месяца
```

приводит к возбуждению исключения:

```no-highlight
ValueError: month must be in 1..12
```

**Примечание 2.** Названия геттер, сеттер и делитер происходят от английских getter, setter и deleter и используются напрямую без перевода.

## 4.5 Свойства, функция property()
### Тема урока: свойства, функция property()

1. Свойства
2. Функция `property()`
3. Объект `property`

**Аннотация.** Урок посвящен свойствам и функции `property()`.

### Свойства, функция property()

Уроком ранее мы выяснили, что защищенные и приватные переменные в Python на самом деле не являются скрытыми. Помимо этого мы познакомились с концепцией геттеров и сеттеров, которая позволяет избегать прямого доступа к атрибутам, а также добавлять дополнительную логику при изменении их значений.

Рассмотрим следующее определение класса `Cat`:

```python
class Cat:
    def __init__(self, name):
        self._name = name                              # имя кошки

    def get_name(self):                                # геттер, используется для получения имени
        return self._name

    def set_name(self, name):                          # сеттер, используется для изменения имени
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')
```

Экземпляр данного класса содержит атрибут `_name` и два метода `get_name()` и `set_name()`, позволяющих работать с этим атрибутом. Если мы решим добавить еще один атрибут экземпляру нашего класса, нам снова потребуется определить для него два метода — геттер и сеттер. 

Несмотря на то что геттеры и сеттеры даже в таком виде выполняют свою основную задачу, работать с атрибутами с помощью них становится несколько сложнее, так как атрибуты перестают быть атрибутами как таковыми — мы обращаемся к ним и изменяем их значения с помощью методов. Более того, для каждого атрибута нужно помнить оба его метода.

Самый популярный способ упростить работу с атрибутами, не потеряв все преимущества геттеров и сеттеров, — превратить их в **свойства**. Свойства предоставляют промежуточную функциональность между атрибутами и методами. Другими словами, они позволяют создавать методы, которые ведут себя как атрибуты.

В Python свойства определяются как атрибуты классов, за которыми закрепляются соответствующие геттеры, сеттеры и делитеры. Так как свойства являются атрибутами класса, они доступны всем экземплярам этого класса.

Для создания свойств используется встроенная функция `property()`. Она принимает четыре аргумента:

- `fget` — функция для получения значения атрибута
- `fset` — функция для установки значения атрибута
- `fdel` — функция для удаления атрибута
- `doc` — строка документации

Функция `property()` возвращает специальный объект `property` — свойство на основе переданных геттера, сеттера и делитера.

Все четыре аргумента функции `property()` являются необязательными и по умолчанию имеют значение `None`.

Приведенный ниже код определяет свойство `name`, за которым закреплены геттер `get_name()` и сеттер `set_name()`:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)                # создаем свойство name для управления именем
```

Теперь работать с атрибутом `_name` можно через свойство `name`. При этом во время обращения к свойству `name` как к атрибуту будет неявно вызываться метод `get_name()`, а во время установки значения свойству `name` как атрибуту будет неявно вызываться метод `set_name()`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat1 = Cat('Кемаль')
cat2 = Cat('Роджер')

print(cat1.name)                                       # равнозначно cat1.get_name()
print(cat2.name)                                       # равнозначно cat2.get_name()
```

выводит:

```no-highlight
Кемаль
Роджер
```

Чтобы убедиться в том, что обращение к свойству `name` неявно вызывает метод `get_name()`, мы можем добавить в данный метод вывод сообщения.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        print(f'Возвращаю имя {self._name}')
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat1 = Cat('Кемаль')
cat2 = Cat('Роджер')

print(cat1.name)
print(cat2.name)
```

выводит:

```no-highlight
Возвращаю имя Кемаль
Кемаль
Возвращаю имя Роджер
Роджер
```

Как уже было сказано выше, при установке значения свойству `name` неявно вызывается метод `set_name()`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat1 = Cat('Кемаль')
cat2 = Cat('Роджер')

cat1.name = 'Рэтчет'                                   # равнозначно cat1.set_name('Рэтчет')

print(cat1.name)
print(cat2.name)
```

выводит:

```no-highlight
Рэтчет
Роджер
```

Чтобы убедиться в том, что установка значения свойства `name` неявно вызывает метод `set_name()`, мы можем попытаться установить некорректное имя.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat = Cat('Кемаль')

cat.name = 1                                           # равнозначно cat.set_name(1)
```

приводит к возбуждению исключения:

```no-highlight
ValueError: Некорректное имя
```

Поскольку все аргументы функции `property()` являются необязательными, мы можем определять свойства, которые, например, доступны только для чтения. При попытке изменить значения такого свойства будет возбуждено исключение.

### Объект property

Свойства являются атрибутами классов, которые доступны всем экземплярам этих классов. Обращаясь к свойству через экземпляр класса, мы работаем с ним как с атрибутом, неявно вызывая соответствующие методы (геттер, сеттер и делитер). При этом само свойство является обычным объектом, и мы можем получить к нему доступ через класс, в котором это свойство определено.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


print(Cat.name)
print(type(Cat.name))
```

выводит (адрес может отличаться):

```no-highlight
<property object at 0x000001829C8F56C0>
<class 'property'>
```

Таким образом, свойство — это атрибут класса, который управляет атрибутами экземпляров. Мы также можем считать свойство набором методов (геттер, сеттер, делитер), собранных вместе в единый объект. Обратиться к методам, содержащимся в свойстве, можно через атрибуты `fget, fset` и `fdel`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


print(Cat.name.fget)                                   # обращаемся к геттеру свойства
print(Cat.name.fset)                                   # обращаемся к сеттеру свойства
print(Cat.name.fdel)                                   # обращаемся к делитеру свойства
```

выводит (адрес может отличаться):

```no-highlight
<function Cat.get_name at 0x000001F8C2FC1090>
<function Cat.set_name at 0x000001F8C2FC1120>
None
```

### Примечания

**Примечание 1.** `property` — это класс, предназначенный для работы как функция, а не как обычный класс, поэтому большинство разработчиков называют ее функцией. По этой же причине `property()` не соответствует соглашению Python об именовании классов.

**Примечание 2.** Значения, возвращаемые свойствами, необязательно должны быть фиксированными, они могут вычисляться при каждом обращении к ним.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    def get_info(self):
        return self.breed + ' ' + self.name
    
    info = property(get_info)


cat = Cat('Британский', 'Кемаль')

print(cat.info)
```

выводит:

```no-highlight
Британский Кемаль
```

Если вычисление значения довольно затратно, мы можем вычислить его единожды и сохранить, возвращая при последующих вызовах сохраненное ранее значение.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name
        self._info = None

    def get_info(self):
        if self._info is None:
            self._info = self.breed + ' ' + self.name
        return self._info
    
    info = property(get_info)


cat = Cat('Британский', 'Кемаль')

print(cat.info)
```

выводит:

```no-highlight
Британский Кемаль
```

**Примечание 3.** Если значение свойства, вычисляемого на основе различных атрибутов, можно изменять, нужно не забывать изменять и значения всех этих атрибутов.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    def get_info(self):
        return self.breed + ' ' + self.name
    
    def set_info(self, info):
        self.breed, self.name = info.split()
    
    info = property(get_info, set_info)


cat = Cat('Британский', 'Кемаль')

print(cat.info)
print(cat.breed, cat.name)

cat.info = 'Манчкин Роджер'

print(cat.info)
print(cat.breed, cat.name)
```

выводит:

```no-highlight
Британский Кемаль
Британский Кемаль
Манчкин Роджер
Манчкин Роджер
```

**Примечание 4.** Свойства позволяют проверять на корректность значения перед их заменой. Однако если в инициализаторе у нас нет должной проверки, экземпляр класса все равно можно будет создать с некорректными данными.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat = Cat(-1)                                          # устанавливаем некорректное имя при создании

print(cat.name)
```

выводит:

```no-highlight
-1
```

Решить данную проблему можно добавлением необходимой проверки в инициализатор.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat = Cat(-1)

print(cat.name)
```

приводит к возбуждению исключения:

```no-highlight
ValueError: Некорректное имя
```

Несложно заметить, что мы дублируем немалый объем кода, добавляя проверку как в сеттер, так и в инициализатор. Вместо этого гораздо удобнее было бы воспользоваться уже реализованной в сеттере проверкой. И мы можем сделать это, если воспользуемся свойством прямо в инициализаторе.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)


cat = Cat(-1)

print(cat.name)
```

приводит к возбуждению исключения:

```no-highlight
ValueError: Некорректное имя
```

Обратите внимание, что в инициализаторе мы не создаем атрибут `name`, мы обращаемся к уже имеющемуся свойству `name` и изменяем его значение, что приводит к вызову сеттера, внутри которого происходит создание атрибута `_name` с соответствующим значением.

**Примечание 5.** Третьим аргументом, передаваемым в функцию `property()`, является делитер. Он вызывается во время удаления свойства как атрибута.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def del_name(self):
        del self._name

    name = property(get_name, fdel=del_name)


cat = Cat('Кемаль')

del cat.name                                           # равнозначно cat.del_name()

print(cat.name)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Cat' object has no attribute '_name'.
```

**Примечание 6.** Четвертым аргументом, передаваемым в функцию `property()` является строка документации, которая может использоваться для описания создаваемого свойства.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def del_name(self):
        del self._name

    name = property(get_name, doc='Имя кошки. Доступно только для чтения.')


cat = Cat('Кемаль')

print(Cat.name.__doc__)
```

выводит:

```no-highlight
Имя кошки. Доступно только для чтения.
```

## 4.6 Декоратор @property
### Тема урока: декоратор @property

1. Декоратор `@property`

**Аннотация.** Урок посвящен декоратору `@property`.

### Декоратор @property

В предыдущем курсе мы познакомились с декораторами, однако до этого момента ни разу ими полноценно не пользовались.

Декоратор — функция, которая принимает в качестве аргумента функцию и возвращает новую функцию, которая расширяет функционал переданной.

Когда функция `property()` была добавлена в Python 2.2, синтаксис применения декораторов с помощью символа `@` еще не был доступен. Единственным способом создания свойств был вызов функции `property()` с соответствующим набором методов (геттер, сеттер и делитер). Синтаксис применения декораторов был добавлен в Python 2.4, и с того времени функция `property()` зачастую применяется именно как декоратор.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name                               # имя кошки

    @property
    def name(self):                                     # геттер свойства name
        return self._name

    @name.setter
    def name(self, name):                               # сеттер свойства name
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):                                     # делитер свойства name 
        del self._name
```

определяет в классе `Cat` свойство `name`, используя функцию `property()` в качестве декоратора.

Данный способ определения свойства заметно отличается от того, которым мы пользовались ранее. Нам больше не нужно определять три метода с разными именами `get_name, set_name` и `del_name`, вместо этого мы сразу определяем три метода с общим именем `name`, которое и является именем создаваемого свойства.

Сперва мы определяем метод `name()`, реализующий логику геттера, и декорируем его функцией `property()`. Другими словами, мы создаем свойство `name`, которое пока что доступно только для чтения. Далее мы снова определяем метод `name()`, реализующий логику сеттера, однако на этот раз декорируем его не функцией `property()`, а функцией `name.setter()`.

Дело в том, что все объекты `property` имеют три метода `getter(), setter()` и `deleter()`. Все они работают похожим образом. Например, метод `setter()` принимает в качестве аргумента некоторый метод `method` и возвращает новый объект `property`, который в качестве геттера и делитера имеет методы текущего объекта `property`, а в качестве сеттера — переданный метод `method`.

Когда мы декорируем второй метод `name()` функцией `name.setter()`, мы создаем новый объект `property` и переприсваиваем его имени `name`. Этот новый объект в качестве геттера имеет геттер предыдущего объекта `property`, а в качестве сеттера — метод, указанный при его создании.

Аналогично для свойства определяется и делитер. Мы создаем метод с тем же именем `name`, реализующий логику делитера, и декорируем его функцией `name.deleter()`, которая возвращает новый объект `property`, содержащий все методы предыдущего объекта `property`, а также делитер, указанный при его создании. Этот новый объект присваивается имени `name` и становится окончательным свойством с полным набором методов.

Таким образом, применение функции `property()` в качестве декоратора — это последовательное создание новых свойств и переприсваивание их одной и той же переменной. Для наглядности мы можем записать данный процесс без использования синтаксиса декораторов.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    name = property(get_name)        # свойство, имеющее только геттер

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = name.setter(set_name)     # свойство, имеющее геттер предыдущего свойства, а также сеттер

    def del_name(self):
        del self._name

    name = name.deleter(del_name)    # свойство, имеющее геттер и сеттер предыдущего свойства, а также делитер
```

эквивалентен коду, приведенному выше, и так же определяет свойство `name` с соответствующим набором методов (геттер, сеттер, делитер).

### Примечания

**Примечание 1.** Использование функции `property()` в качестве декоратора позволяет достаточно просто создавать свойства, доступные только для чтения.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name
```

создает свойство `name`, доступное только для чтения.

**Примечание 2.** При создании свойства с помощью синтаксиса декораторов методы, реализующие для него логику геттера, сеттера и делитера, должны иметь одно и то же имя — имя создаваемого свойства. Если мы поступим иначе, например, дадим сеттеру и делитеру другие имена, мы получим не одно свойство, а три.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):                  # первое свойство name, доступное только для чтения
        return self._name

    @name.setter
    def set_name(self, name):        # второе свойство set_name, доступное для чтения и записи
        self._name = name

    @name.deleter
    def del_name(self):              # третье свойство del_name, доступное для чтения и удаления
        del self._name


cat = Cat('Кемаль')

print(cat.name)
print(cat.set_name)
print(cat.del_name)
```

выводит:

```no-highlight
Кемаль
Кемаль
Кемаль
```

## 4.7 Декораторы @classmethod и @staticmethod
### Тема урока: декораторы @classmethod и @staticmethod

1. Методы экземпляра
2. Методы класса, декоратор `@classmethod`
3. Статические методы, декоратор `@staticmethod`

**Аннотация.** Урок посвящен декораторам `@classmethod` и `@staticmethod`.

### Методы в Python

В Python есть несколько типов методов:

1. методы экземпляра
2. методы класса
3. статические методы

### Методы экземпляра

Методы, с которыми мы познакомились в прошлых уроках, являлись методами экземпляра. Именно их мы используем большую часть времени. Как уже известно, методы экземпляра имеют обязательный параметр `self`, который указывает на конкретный экземпляр класса при вызове метода. Через переменную `self` методы экземпляра могут свободно обращаться к атрибутам объектов и полноценно с ними работать, что дает им возможность управлять их состоянием.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, age):
        self.name = name                                     # имя кошки
        self.age = age                                       # возраст кошки
        self.favorite_things = []                            # список любимых вещей кошки

    def about(self):
        return f'Имя: {self.name}, возраст: {self.age}'      # обращаемся к атрибутам объекта

    def loves(self, thing):
        self.favorite_things.append(thing)                   # изменяем значение атрибута объекта


cat = Cat('Кемаль', 1)

cat.loves('Тимур')
cat.loves('Дом')

print(cat.about())
print(cat.favorite_things)
```

выводит:

```no-highlight
Имя: Кемаль, возраст: 1
['Тимур', 'Дом']
```

Метод экземпляра также можно вызвать через класс, передав в качестве первого аргумента сам экземпляр класса.

Приведенный ниже код:

```python
cat = Cat('Кемаль', 1)

cat.loves('Тимур')                                           # вызов метода через экземпляр
Cat.loves(cat, 'Дом')                                        # вызов метода через класс

print(Cat.about(cat))                                        # вызов метода через класс
print(cat.favorite_things)
```

выводит:

```no-highlight
Имя: Кемаль, возраст: 1
['Тимур', 'Дом']
```

### Методы класса

Методы класса, как следует из названия, тесно связаны с классом, в котором они определены. В отличие от методов экземпляра, имеющих обязательный параметр `self`, указывающий на экземпляр класса, методы класса имеют обязательный параметр `cls`, который указывает на сам класс. Такие методы имеют возможность менять состояние класса, что в свою очередь отражается на всех экземплярах данного класса. Однако менять состояние конкретного объекта, как это делают методы экземпляра, они не могут, так как имеют доступ лишь к классу.

Присутствие параметра `cls` в методе класса обязательное. Мы не обязаны называть его `cls`, однако строго рекомендуется действовать согласно общепринятой практике.

Для создания методов класса используется декоратор `@classmethod`.

Приведенный ниже код:

```python
class MyClass:
    @classmethod
    def my_classmethod(cls):
        print('Это метод класса')
        print(cls)


MyClass.my_classmethod()
```

создает в классе `MyClass` метод класса `my_classmethod()` и выводит:

```no-highlight
Это метод класса
<class '__main__.MyClass'>
```

Как мы видим, метод класса `my_classmethod()` действительно имеет доступ лишь к классу `MyClass`.

Зачастую методы класса используются для добавления альтернативного способа создания экземпляров класса. Рассмотрим следующее определение класса `Cat`:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed                                   # порода кошки
        self.name = name                                     # имя кошки
```

Экземпляры данного класса имеют два атрибута — породу и имя. Скажем, мы заметили, что очень часто имеем дело с кошками британской породы и решили, что было бы удобно создавать объекты класса `Cat`, указывая лишь имя, а в качестве породы по умолчанию устанавливая `Британский`. Для этого мы можем реализовать метод класса, который принимает лишь имя кошки и возвращает объект класса `Cat` британской породы с указанным именем.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    @classmethod
    def british(cls, name):
        return cls('Британский', name)                       # равнозначно Cat('Британский', name)


cat = Cat.british('Кемаль')

print(cat.breed, cat.name)
```

 выводит:

```no-highlight
Британский Кемаль
```

На самом деле мы уже не раз сталкивались с методами класса, например, когда изучали такие типы данных как `dict` и `datetime`.

Приведенный ниже код:

```python
from datetime import datetime

cats = dict.fromkeys(['Кемаль', 'Роджер'])                   # словарь со значениями по умолчанию
dt = datetime.strptime('12.10.2022', '%d.%m.%Y')             # дата на основе строки

print(cats)
print(dt)
```

выводит:

```no-highlight
{'Кемаль': None, 'Роджер': None}
2022-10-12 00:00:00
```

### Статические методы

Статические методы, в отличие от методов экземпляра и методов класса, не имеют обязательного параметра `self` или `cls`. Поэтому статические методы не могут изменять ни состояние объекта, ни состояние класса. Статические методы можно считать обычными функциями, которые помещены в класс для удобства. Чаще всего это какой-то вспомогательный код, предназначенный для внутреннего использования.

Для создания статических методов используется декоратор `@staticmethod`.

Приведенный ниже код:

```python
class MyClass:
    @staticmethod
    def my_staticmethod():
        print('Это статический метод')


MyClass.my_staticmethod()
```

создает в классе `MyClass` статический метод класса `my_staticmethod()` и выводит:

```no-highlight
Это статический метод
```

Как мы видим, статический метод `my_staticmethod()` действительно не имеет доступа ни к классу, ни к объекту.

Статические методы могут вызываться внутри методов экземпляра или класса для вычисления каких-либо значений, которые напрямую не связаны с экземплярами класса или самим классом. Рассмотрим следующее определение класса `Cat`:

```python
class Cat:
    def __init__(self, name, age):
        self.name = name                                     # имя кошки
        self.age = age                                       # возраст кошки
```

Например, мы хотим определить метод `get_age()`, который мог бы возвращать возраст кошки как в кошачьих годах, так и в человеческих. Тогда мы можем определить статический метод `age_in_human_years()`, который переводит кошачьи года в человеческие, и использовать его внутри метода `get_age()`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def get_age(self, in_human_years=False):
        if in_human_years:
            return Cat.age_in_human_years(self.age)          # переводим кошачьи года в человеческие
        return self.age

    @staticmethod
    def age_in_human_years(age):
        return (age + (age < 5) - (age > 8)) * 7             # переводим кошачьи года в человеческие


cat = Cat('Кемаль', 2)

print(cat.get_age())                                         # возраст в кошачьих годах
print(cat.get_age(True))                                     # возраст в человеческих годах
```

выводит:

```no-highlight
2
21
```

### Примечания

**Примечание 1.** Помимо того, что методы экземпляра могут изменять состояние объекта, они так же могут получать доступ к самому классу через атрибут `__class__` экземпляра класса. Это означает, что методы экземпляра также могут изменять состояние класса.

Приведенный ниже код:

```python
class MyClass:
    def method(self):
        print('Это метод экземпляра')
        print(self)
        print(self.__class__)


obj = MyClass()

obj.method()
```

выводит (адрес может отличаться):

```no-highlight
Это метод экземпляра
<__main__.MyClass object at 0x000002733A5A6BC0>
<class '__main__.MyClass'>
```

**Примечание 2.** Методы класса и статические методы можно вызывать не только через класс, но и через экземпляр класса.

Приведенный ниже код:

```python
class MyClass:
    @classmethod
    def my_classmethod(cls):
        print('Это метод класса')
        print(cls)

    @staticmethod
    def my_staticmethod():
        print('Это статический метод')


obj = MyClass()

obj.my_classmethod()
obj.my_staticmethod()
```

выводит:

```no-highlight
Это метод класса
<class '__main__.MyClass'>
Это статический метод
```

## 4.8 Декоратор @singledispatchmethod
### Тема урока: декоратор @singledispatchmethod

1. Перегрузка методов
2. Варианты перегрузки инициализатора
3. Декоратор `@singledispatchmethod`

**Аннотация.** Урок посвящен альтернативным способам создания объектов и декоратору `@singledispatchmethod`.

### Перегрузка методов

Многие языки программирования (C++, C#, Java и другие) поддерживают перегрузку методов. Перегрузка методов позволяет определять множество одноименных методов с разной сигнатурой, то есть с разным количеством и типами принимаемых аргументов. Таким образом, методы могут выполнять различный код в зависимости от контекста их вызова.

Перегрузка методов — это приём программирования, который позволяет в зависимости от переданных в метод аргументов использовать определенную версию метода.

Python, к сожалению, не поддерживает перегрузку методов напрямую. Мы знаем, что в Python классы хранят имена методов во внутреннем словаре `__dict__`. Как и любой словарь, `__dict__` не может иметь повторяющихся ключей, поэтому в одном классе не может быть нескольких методов с одинаковыми именами.

Рассмотрим пустой класс `Cat`, в котором определим два метода с одинаковыми именами.

Приведенный ниже код:

```
class Cat:
    def say(self):
        print('meow')

    def say(self):
        print('мяу')


cat = Cat()

cat.say()
```

выводит:

```no-highlight
мяу
```

Как мы видим, Python запоминает только последнюю реализацию метода. Нечто подобное происходит и при написании отдельных функций вне классов.

Приведенный ниже код:

```python
def say_hello():
    print('Hello, World!')

def say_hello():
    print('Привет, мир!')

say_hello()
```

выводит:

```no-highlight
Привет, мир!
```

Последняя реализация нескольких одноименных функций преобладает над остальными реализациями.

### Перегрузка инициализатора

Поскольку метод инициализации `__init__()` является, по сути, обычным методом, мы не можем его перегружать. Мы можем обойти это ограничение несколькими способами, имитируя несколько инициализаторов. Рассмотрим каждый из них.

#### Использование необязательных аргументов

Наиболее простой способ имитации нескольких инициализаторов в классе — это необязательные аргументы с использованием значений по умолчанию. Таким образом, мы можем вызывать метод инициализации `__init__()` по-разному и каждый раз получать разное поведение.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed='Британский', name='Кемаль'):
        self.breed = breed                                    # порода кошки, по умолчанию Британский
        self.name = name                                      # имя кошки, по умолчанию Кемаль


cat1 = Cat()                                                  # не передаем ничего
cat2 = Cat(name='Роджер')                                     # передаем только имя
cat3 = Cat(breed='Шотландский', name='Роджер')                # передаем всё

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
print(cat3.breed, cat3.name)
```

выводит:

```no-highlight
Британский Кемаль
Британский Роджер
Шотладский Роджер
```

Использование необязательных аргументов в методе `__init__()` — это чистый и основанный на Python метод создания классов, имитирующих несколько инициализаторов.

#### Использование проверки типов аргументов

Другой способ имитации нескольких инициализаторов заключается в проверке типов аргументов, чтобы обеспечить различное поведение в зависимости от конкретного типа. Чтобы проверить тип в Python, мы обычно используем встроенную функцию `isinstance()`.

Приведенный ниже код:

```python
from datetime import date

class Cat:
    def __init__(self, breed, name, birth_date):
        self.breed = breed
        self.name = name
        if isinstance(birth_date, date):
            self.birth_date = birth_date                      # дата рождения кошки
        elif isinstance(birth_date, str):
            self.birth_date = date.fromisoformat(birth_date)  # дата рождения кошки на основе строки


cat1 = Cat('Британский', 'Кемаль', date(2021, 3, 31))         # передаем объект date
cat2 = Cat('Шотландский', 'Роджер', '2020-09-10')             # передаем строку

print(cat1.breed, cat1.name, cat1.birth_date)
print(cat2.breed, cat2.name, cat2.birth_date)
```

выводит:

```no-highlight
Британский Кемаль 2021-03-31
Шотладский Роджер 2020-09-10
```

Здесь внутри метода `__init__()` мы используем условный оператор, чтобы проверить, какой тип имеет переданный аргумент `birth_day`. Если аргумент имеет тип `date`, то мы просто сохраняем его в атрибут `birth_date`, если же тип строковый, то мы предварительно преобразуем его в тип `date` с помощью метода `fromisoformat()`. Обратите внимание, что аргумент должен представлять из себя строку, содержащую корректную дату в ISO формате.

Таким образом, мы имитируем два инициализатора. Один инциализатор принимает аргумент типа `date`, другой — `str`.

Техника в приведенном выше примере имеет серьезный недостаток, поскольку она плохо масштабируется. Если у нас есть аргументы, которые могут принимать значения разных типов, то наша реализация вскоре может стать нерабочей.

Приведенный ниже код:

```python
from datetime import date

class Cat:
    def __init__(self, breed, name, birth_date):
        self.breed = breed
        self.name = name
        if isinstance(birth_date, date):
            self.birth_date = birth_date
        elif isinstance(birth_date, str):
            self.birth_date = date.fromisoformat(birth_date)


cat = Cat('Британский', 'Кемаль', 1617173745)                 # передаем дату в формате Unix

print(cat.birth_date)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Cat' object has no attribute 'birth_date'
```

Так получается, поскольку у условного оператора в инициализаторе не было ветки, которая обрабатывает числовое значение для аргумента `birth_date`.

Чтобы устранить эту проблему, мы можем продолжить добавлять `elif`-ы, чтобы охватить все возможные форматы дат. Мы также можем добавить ветку `else`, чтобы перехватывать все неподдерживаемые форматы дат.

Приведенный ниже код:

```python
from datetime import date


class Cat:
    def __init__(self, breed, name, birth_date):
        self.breed = breed
        self.name = name
        if isinstance(birth_date, date):
            self.birth_date = birth_date
        elif isinstance(birth_date, str):
            self.birth_date = date.fromisoformat(birth_date)
        else:
            raise ValueError(f'неверный формат даты: {birth_date}')


cat = Cat('Британский', 'Кемаль', 1617173745)
```

приводит к возбуждению исключения:

```no-highlight
ValueError: неверный формат даты: 1617173745
```

Использование проверки типов аргументов для имитации нескольких инициализаторов относится, скорее, к анти-паттернам в Python.

#### Использование методов класса

Эффективным методом имитации нескольких инициализаторов является использование методов класса, которые создаются декоратором `@classmethod`. В отличие от обычных методов, методы класса не принимают текущий экземпляр `self` в качестве аргумента. Вместо этого они принимают сам класс, который обычно передается в качестве аргумента `cls`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    @classmethod
    def create_british_cat(cls, name):
        return cls('Британский', name)

    @classmethod
    def create_kemal_cat(cls, breed):
        return cls(breed, 'Кемаль')


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat.create_british_cat('Роджер')
cat3 = Cat.create_kemal_cat('Шотландский')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
print(cat3.breed, cat3.name)
```

выводит:

```no-highlight
Британский Кемаль
Британский Роджер
Шотландский Кемаль
```

Использование методов класса — это чистый и основанный на Python метод создания классов, имитирующих несколько методов инициализации.

### Использование декоратора @singledispatchmethod

Последний способ имитации нескольких инициализаторов заключается в создании универсальной функции одиночной диспетчеризации. Данный способ позволяет определить несколько инициализаторов и выборочно их использовать в зависимости от типа первого переданного в них аргумента.

**Универсальная функция** (generic function) представляет собой функцию, составленную из нескольких функций, реализующих одну и ту же операцию для различных типов. **Одиночная диспетчеризация** (single dispatch) — это алгоритм, который выбирает нужную реализацию на основе типа **одного аргумента**. Именно поэтому диспетчеризация называется одиночной.

Создание универсальной функции одиночной диспетчеризации происходит с помощью декоратора `@singledispatchmethod` из модуля `functools`, использование которого синтаксически схоже с использованием декоратора `@property`.

Приведенный ниже код:

```python
from functools import singledispatchmethod


class MyClass:
    @singledispatchmethod
    def base_implementation(self, arg):
        print('Базовая реализация')

    @base_implementation.register(int)
    def int_implementation(self, arg):
        print('Реализация для целочисленного аргумента')

    @base_implementation.register(str)
    def str_implementation(self, arg):
        print('Реализация для строкового аргумента')


obj = MyClass()

obj.base_implementation(1)
obj.base_implementation('bee')
obj.base_implementation([1, 2, 3])
```

определяет метод `base_implementation()`, имеющий две альтернативные реализации, и выводит:

```no-highlight
Реализация для целочисленного аргумента
Реализация для строкового аргумента
Базовая реализация
```

В примере выше мы сначала определяем метод `base_implementation()`, представляющий базовую реализацию, и применяем к нему декоратор `@singledispatchmethod`. Затем мы определяем метод `int_implementation()`, который является альтернативной реализацией метода `base_implementation()`, если в него будет передан целочисленный аргумент, и декорируем его с помощью `@base_implementation.register` с соответствующим аргументом `int`. Другими словами, декоратор `@base_implementation.register` закрепляет за методом `base_implementation()` метод `int_implementation()` и вызывает его, если передаваемый в него аргумент принадлежит типу `int`. Далее аналогично определяем альтернативную реализацию для строкового аргумента.

При вызове метода `base_implementation()` нужная реализация выбирается на основе типа аргумента, следующего после `self`. Если аргумент принадлежит типу `int`, будет вызван метод `int_implementation()`, если аргумент принадлежит типу `str` — метод `str_implementation()`, во всех остальных случаях — метод `base_implementation()`.

При использовании декоратора `@singledispatchmethod` альтернативные реализации не должны иметь то же имя, что и базовая реализация.

Используя данный способ для перегрузки метода `__init__()`, мы можем сымитировать наличие в классе нескольких инициализаторов.

Приведенный ниже код:

```python
from functools import singledispatchmethod


class Cat:
    @singledispatchmethod
    def __init__(self, breed, name, age):
        self.breed = breed
        self.name = name
        self.age = age

    @__init__.register(list)
    def _from_list(self, data):
        self.breed, self.name, self.age = data


cat1 = Cat('Британский', 'Кемаль', 1)                         # передаем все данные отдельно
cat2 = Cat(['Манчкин', 'Роджер', 1])                          # передаем список с данными

print(cat1.breed, cat1.name, cat1.age)
print(cat2.breed, cat2.name, cat2.age)
```

выводит:

```no-highlight
Британский Кемаль 1
Манчкин Роджер 1
```

на методов, являющихся альтернативными, зачастую предваряют одним символом нижнего подчеркивания, тем самым делая их защищенными.

### Примечания

**Примечание 1.** По сути, способ имитации нескольких инициализаторов с помощью декоратора `@singledispatchmethod` закрепляет за одним методом (базовым) другие методы (альтернативные), связывая их с определенными типами. Поэтому мы можем связать один метод сразу с несколькими типами.

Приведенный ниже код:

```python
from functools import singledispatchmethod


class Cat:
    @singledispatchmethod
    def __init__(self, breed, name, age):
        self.breed = breed
        self.name = name
        self.age = age

    @__init__.register(list)
    @__init__.register(tuple)
    def _from_list_tuple(self, data):
        self.breed, self.name, self.age = data


cat1 = Cat(('Британский', 'Кемаль', 1))
cat2 = Cat(['Манчкин', 'Роджер', 1])

print(cat1.breed, cat1.name, cat1.age)
print(cat2.breed, cat2.name, cat2.age)
```

выводит:

```no-highlight
Британский Кемаль 1
Манчкин Роджер 1
```

**Примечание 2.** При определении альтернативных реализаций метода мы можем использовать уже знакомые аннотации типов.

Приведенный ниже код:

```python
from functools import singledispatchmethod


class MyClass:
    @singledispatchmethod
    def base_implementation(self, arg):
        print('Базовая реализация')

    @base_implementation.register
    def int_implementation(self, arg: int):
        print('Реализация для целочисленного аргумента')

    @base_implementation.register
    def str_implementation(self, arg: str):
        print('Реализация для строкового аргумента')


obj = MyClass()

obj.base_implementation(1)
obj.base_implementation('bee')
obj.base_implementation([1, 2, 3])
```

выводит:

```no-highlight
Реализация для целочисленного аргумента
Реализация для строкового аргумента
Базовая реализация
```

Однако функционал данного способа несколько слабее того, что предлагают обычные аннотации типов. Например, мы не можем объединить несколько типов.

Приведенный ниже код:

```python
from functools import singledispatchmethod


class MyClass:
    @singledispatchmethod
    def base_implementation(self, arg):
        print('Базовая реализация')

    @base_implementation.register
    def intfloat_implementation(self, arg: int | float):
        print('Реализация для целочисленного и вещественного аргументов')


obj = MyClass()

obj.base_implementation(1)
obj.base_implementation(1.0)
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Invalid annotation for 'arg'. int | float is not a class.
```

Также мы не можем использовать абстрактные типы из модуля `typing`.

Приведенный ниже код:

```python
import typing
from functools import singledispatchmethod


class MyClass:
    @singledispatchmethod
    def base_implementation(self, arg):
        print('Базовая реализация')

    @base_implementation.register
    def iterable_implementation(self, arg: typing.Iterable):
        print('Реализация для итерируемого аргумента')


obj = MyClass()

obj.base_implementation('bee')
obj.base_implementation([1, 2, 3])
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Invalid annotation for 'arg'. typing.Iterable is not a class.
```

**Примечание 3.** Основным ограничением перегрузки методов с помощью декоратора `@singledispatchmethod` является то, что мы полагаемся лишь на тип одного аргумента — первого после `self`. Для перегрузки методов, основанной на типах нескольких аргументов, используются сторонние библиотеки, например, `multipledispatch` и `multimethod`, доступные по [ссылке](https://pypi.org/project/multipledispatch/) и [ссылке](https://pypi.org/project/multimethod/) соответственно.

**Примечание 4.** При имитации нескольких инициализаторов с помощью методов класса в Python обычно используют префикс `from` в названии метода. К примеру, встроенные типы `dict` и `date` имеют методы: `fromkeys(), fromtimestamp(), fromordinal(), fromisoformat()` и т.д.

**Примечание 5.** С помощью декоратора `@singledispatchmethod` можно перегружать любые методы в классе, будь то методы экземпляра, методы класса или статические методы.

Приведенный ниже код:

```python
from functools import singledispatchmethod


class MyClass:
    @singledispatchmethod
    def method(self, arg):
        print('Базовая реализация метода экземпляра')

    @method.register(int)                                     # перегружаем метод экземпляра
    def _method(self, arg):
        print('Реализация метода экземпляра для целочисленного аргумента')

    @singledispatchmethod
    @classmethod
    def class_method(cls, arg):
        print('Базовая реализация метода класса')

    @class_method.register(str)                               # перегружаем метод класса
    @classmethod
    def _class_method(cls, arg):
        print('Реализация метода класса для строкового аргумента')

    @singledispatchmethod
    @staticmethod
    def static_method(arg):
        print('Базовая реализация статического метода')

    @static_method.register(list)                             # перегружаем статический метод
    @staticmethod
    def _static_method(arg):
        print('Реализация статического метода для списочного аргумента')


obj = MyClass()

obj.method('bee')
obj.method(1)
print()

obj.class_method(1)
obj.class_method('bee')
print()

obj.static_method(1)
obj.static_method(['b', 'e', 'e'])
```

выводит:

```no-highlight
Базовая реализация метода экземпляра
Реализация метода экземпляра для целочисленного аргумента

Базовая реализация метода класса
Реализация метода класса для строкового аргумента

Базовая реализация статического метода
Реализация статического метода для списочного аргумента
```

# 5. Магические методы
## 5.1 Создание, инициализация и очищение объектов
### Тема урока: создание, инициализация и очищение объектов

1. Магические методы
2. Магические методы `__new__()` и `__init__()`
3. Реализация синглтона
4. Магический метод `__del__()`

**Аннотация.** Урок посвящен магическим методам `__new__(), __init__()` и `__del__()`.

### Магические методы

Магические методы – это общий термин, относящийся к специальным методам в классах Python. Для них нет единого определения, поскольку их применение разнообразно. Магические методы, как правило, добавляют в класс специальный функционал. Они всегда обрамлены двумя нижними подчеркиваниями, например, `__init__()`.

[![](https://ucarecdn.com/1758264d-dfab-4819-9325-ced37ee38a67/)](https://stepik.org/media/attachments/lesson/805763/star.png)

Магические методы не предназначены для прямого вызова, однако их вызов происходит автоматически при определенных действиях. Например, мы явно не вызываем метод `__init__()` при создании нового экземпляра класса, но вместо этого данный метод вызывается внутренне. Все, что нам нужно сделать, это реализовать метод внутри класса должным образом.

Поскольку магические методы характеризуются двойным подчеркиванием, их часто называют dunders, что означает Double Underscore.

### Методы __new__() и __init__()

В Python для создания экземпляра класса достаточно вызвать данный класс как функцию и передать ему соответствующий набор аргументов, если это необходимо.

Приведенный ниже код:

```python
class MyClass:
    pass


obj = MyClass()

print(obj)
print(type(obj))
```

создает экземпляр класса `MyClass`, присваивает его переменной `obj` и выводит (адрес может отличаться):

```no-highlight
<__main__.MyClass object at 0x000001FCABBE6560>
<class '__main__.MyClass'>
```

Когда мы вызываем класс, мы запускаем внутренний процесс **конструирования экземпляра класса**, который состоит из двух шагов:

1. создание нового пустого экземпляра класса
2. инициализация созданного экземпляра класса

Для выполнения первого шага все классы имеют магический метод `__new__()`, который отвечает за создание и возврат нового пустого экземпляра класса. Затем созданный экземпляр передается в метод `__init__()` для инициализации, то есть для установки его атрибутам необходимых значений.

Мы уже хорошо знакомы с процессом инициализации и методом `__init__()`, который в качестве первого аргумента `self` принимает уже созданный экземпляр класса, однако его создание всегда происходило без нашего ведома.

Непосредственное создание объекта происходит с помощью метода `__new__()`. Данный метод вызывается самым первым при конструировании объекта. Метод `__new__()` принимает в качестве первого обязательного аргумента класс, а затем, как правило, произвольное количество позиционных и именованных аргументов.

Приведенный ниже код:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)
        return instance


obj = MyClass()

print(obj)
print(type(obj))
```

выводит (адрес может отличаться):

```no-highlight
<__main__.MyClass object at 0x000002A321CF6C20>
<class '__main__.MyClass'>
```

В примере выше метод `__new__()` создает экземпляр класса `MyClass`, присваивает его переменной `instance` и возвращает данный экземпляр.

Для понимания процесса создания экземпляра стоит упомянуть важную деталь: в Python существует класс под названием `object`, который является родительским абсолютно для всех классов. Мы будем подробнее говорить об этом в модуле Наследование, однако сейчас предлагаем просто помнить об этом.

Класс `object` имеет множество базовых методов, одним из которых является метод `__new__()`, отвечающий за создание всех объектов в Python. Данный метод принимает в качестве аргумента класс и возвращает экземпляр этого класса.

Таким образом, конструкция `object.__new__(cls)` позволяет нам обратиться к методу `__new__()` класса `object` и создать экземпляр класса `cls`, в нашем случае класса `MyClass`.

#### Особенности метода __new__()

Первым обязательным аргументом метода `__new__()` пользовательского класса является сам класс, после которого, как правило, следуют произвольное количество позиционных и именованных аргументов. Дело в том, что аргументы, указываемые при вызове класса, передаются как в метод `__init__()`, так и в метод `__new__()`.

Приведенный ниже код:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print(args, kwargs)
        instance = object.__new__(cls)
        return instance


obj = MyClass(1, 2, c=3, d=4)
```

выводит: 

```no-highlight
(1, 2) {'c': 3, 'd': 4}
```

Для большей гибкости метод `__new__()` всегда рекомендуется определять именно с произвольным количеством позиционных и именованных параметров.

#### Ручное конструирование экземпляра класса

Конструирование экземпляра класса происходит при помощи последовательного вызова методов `__new__()` и `__init__()`, первый из которых отвечает за его создание, а второй — за инициализацию.

Приведенный ниже код:

```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name


cat = Cat('Кемаль')

print(type(cat))
print(cat.name)
```

выводит:

```no-highlight
1. Создание экземпляра класса Cat
2. Инициализация созданного экземпляра класса Cat
<class '__main__.Cat'>
Кемаль
```

Мы можем воссоздать весь этот процесс вручную, вызывая методы `__new__()` и `__init__()` напрямую.

Приведенный ниже код:

```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name


cat = Cat.__new__(Cat)
Cat.__init__(cat, 'Кемаль')

print(type(cat))
print(cat.name)
```

выводит:

```no-highlight
1. Создание экземпляра класса Cat
2. Инициализация созданного экземпляра класса Cat
<class '__main__.Cat'>
Кемаль
```

Метод `__new__()` является статическим методом. Однако при его определении в классе не нужно использовать декоратор `@staticmethod`, так как Python делает это автоматически.

### Реализация синглтона

При создании пользовательских классов, как правило, не требуется предоставлять собственную реализацию метода `__new__()`. Однако есть несколько интересных вариантов использования этого метода. Например, мы можем использовать метод `__new__()` для создания [синглтонов](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)#Python_2), то есть объектов существующих в единственном экземпляре.

Реализация синглтона возможна с атрибутом класса, содержащим единственный экземпляр класса, который будет возвращаться при каждом вызове метода `__new__()`.

Приведенный ниже код:

```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance                      


first = Singleton()
second = Singleton()

print(first)
print(second)
print(first is second)
```

выводит (адрес может отличаться):

```no-highlight
<__main__.Singleton object at 0x00000275CF7DB8B0>
<__main__.Singleton object at 0x00000275CF7DB8B0>
True
```

### Примечания

**Примечание 1.** Добавление нижних подчеркиваний к произвольному методу не сделает его магическим. Магические методы имеют для интерпретатора особое значение. Имена магических методов и их смысл определены создателями языка: создавать новые нельзя, можно только реализовывать существующие.

**Примечание 2.** Вместо явного обращения к методу `__new__()` родительского класса `object` можно использовать специальную функцию `super()`.

Приведенный ниже код:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)
        return instance
```

равнозначен коду:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        instance = super().__new__(cls)
        return instance
```

Функция `super()` возвращает специальный прокси-объект, который делегирует все вызовы методов классу-родителю текущего класса. В нашем случае классом-родителем является класс `object`, текущим — класс `MyClass`. Другими словами, объект, возвращаемый функцией `super()`, позволяет нам пользоваться методами родительского класса `object`. Подробнее о функции `super()` мы будем говорить в модуле Наследование.

**Примечание 3.** Метод `__new__()` всегда должен возвращать экземпляр того класса, в котором этот метод определен. В противном случае метод `__init__()` вызываться не будет.

Приведенный ниже код:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса MyClass')
        instance = 'instance'
        return instance                                 # возвращаем экземпляр класса str, а не MyClass

    def __init__(self):
        print('2. Инициализация созданного экземпляра класса MyClass')


obj = MyClass()
```

выводит:

```no-highlight
1. Создание экземпляра класса MyClass
```

При этом метод `__init__()` всегда должен возвращать значение `None`.

Приведенный ниже код:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса MyClass')
        instance = object.__new__(cls)
        return instance

    def __init__(self):
        print('2. Инициализация созданного экземпляра класса MyClass')
        return self


obj = MyClass()
```

приводит к возбуждению исключения:

```no-highlight
TypeError: __init__() should return None, not 'MyClass'
```

**Примечание 4.** Более подробно о методе `__new__()` можно прочитать в официальной документации по [ссылке](https://www.python.org/download/releases/2.2/descrintro/#:~:text=D().m()%20%23%20%22DCBA%22-,Overriding%20the%20__new__%20method,-When%20subclassing%20immutable).

**Примечание 5.** Хорошие статьи про объектную систему Python доступны по [ссылке](https://habr.com/ru/post/114576/) и [ссылке](https://habr.com/ru/post/114585/).

### Метод __del__()

Python является языком с автоматическим управлением памятью, поэтому он сам уничтожает объекты, когда понимает что они перестают быть нужными. Однако при уничтожении объекта необходимо освобождать не только память. Мы должны освободить или закрыть другие ресурсы, которые использовались объектом, например, открытые файлы или соединения.

Финализатор – это специальный метод, который используется для выполнения действий по очистке перед уничтожением объекта. В Python финализатор вызывается не вручную, а полностью автоматически. Его вызов происходит в том случае, когда счетчик ссылок на объект становится равным нулю.

Для определения финализатора используется магический метод `__del__()`.

Приведенный ниже код:

```python
class MyClass:
    def __del__(self):
        print('Bye')


obj = MyClass()

del obj
```

выводит:

```
Bye
```

Важно понимать, что оператор `del` не уничтожает объект, а удаляет связь между именем и объектом. В примере выше на созданный объект ссылается лишь имя `obj`, и после его удаления вызывается финализатор, так как счетчик ссылок на созданный объект становится равным нулю.

Приведенный ниже код:

```python
class MyClass:
    def __del__(self):
        print('Bye')


obj1 = MyClass()
obj2 = obj1

del obj1
```

несмотря на использование оператора `del`, ничего не выводит, так как счетчик ссылок на объект равен единице, а не нулю.

Таким образом, финализатор не запускается при удалении какой-либо одной ссылки на объект. Он вызывается только тогда, когда все ссылки на объект удалены.

#### Примечания

**Примечание 1.** В рамках этого конспекта мы считаем, что программа выполняется в IDLE python 3.10, то есть в среде, которая не удаляет все созданные этой программой объекты после ее завершения.

**Примечание 2.** Важно помнить, что локальные переменные функции существуют только при ее вызове. После завершения работы функции все ее локальные переменные удаляются, то есть удаляются связи между именами и объектами, что приводит к уменьшению счетчика ссылок на эти объекты.

Приведенный ниже код:

```python
class MyClass:
    def __del__(self):
        print('Bye')

def func():
    print('Hi')
    obj = MyClass()


func()
```

выводит:

```no-highlight
Hi
Bye
```

Приведенный ниже код:

```python
class MyClass:
    def __del__(self):
        print('Bye')

def func():
    print('Hi')
    obj = MyClass()
    return obj                    # возвращаем объект из функции


obj = func()
```

не приводит к вызову метода `__del__()`, так как созданный внутри функции объект возвращается и продолжает существовать, и выводит:

```no-highlight
Hi
```

Важно отметить, что поведение программы выше зависит от того, где она выполняется. Если среда программирования после завершения программы удаляет все созданные ею объекты, то для каждого из них будет вызван финализатор.

Приведенный ниже код:

```python
class MyClass:
    def __del__(self):
        print('Bye')

def func():
    print('Hi')
    obj = MyClass()
    return obj


obj = func()                      # объект существует, но удаляется средой после завершения программы
```

при выполнении в среде, которая удаляет все объекты после завершения программы, выводит:

```no-highlight
Hi
Bye
```

**Примечание 3.** Метод `__del__()` не является идеальным решением для очистки ненужных объектов, поскольку возможны ситуации, когда он не будет вызываться. Подробнее об этих ситуациях можно почитать по [ссылке](https://eli.thegreenplace.net/2009/06/12/safely-using-destructors-in-python/).

**Примечание 4.** Интересное обсуждение метода `__del__()` доступно по [ссылке](https://stackoverflow.com/questions/1481488/what-is-the-del-method-and-how-do-i-call-it).

**Примечание 5.** Не гарантируется, что метод `__del__()` будет вызван для объектов, которые все еще существуют, когда интерпретатор завершает работу.

## 5.2 Строковое представление объектов
### Тема урока: строковое представление объектов

1. Функции `str()` и `repr()`
2. Магические методы `__str__()` и `__repr__()`

**Аннотация.** Урок посвящен формальному и неформальному строковому представлению объектов.

### Функции str() и repr()

Для получения строкового представления объекта используются встроенные функции `str()` и `repr()`. Первая функция возвращает строковое представление объекта в неформальном виде (понятном человеку), вторая — в формальном виде (понятном интерпретатору Python).

Приведенный ниже код:

```python
from datetime import date

dt = date(2022, 10, 23)

dt_str = str(dt)
dt_repr = repr(dt)

print(dt_str, type(dt_str))
print(dt_repr, type(dt_repr))
```

выводит:

```no-highlight
2022-10-23 <class 'str'>
datetime.date(2022, 10, 23) <class 'str'>
```

Как мы видим, функция `str()` преобразует дату в привычный для любого человека формат. В то время как функция `repr()` представляет объект в формате, понятном интерпретатору Python или разработчику. Более того, строка, возвращаемая функцией `repr()`, является корректным Python выражением, поэтому может быть преобразована обратно в объект с помощью функции `eval()`.

Приведенный ниже код:

```python
import datetime

dt1 = datetime.date(2022, 10, 23)
dt2 = eval(repr(dt1))

print(dt2)
print(type(dt2))
```

выводит:

```no-highlight
2022-10-23
<class 'datetime.date'>
```

Если объект передается в функцию `print()` в качестве самостоятельного аргумента, то для его отображения автоматически вызывается функция `str()`.

### Магические методы __str__() и __repr__()

За строковое представление объектов отвечают методы `__str__()` и `__repr__()`. Именно эти методы вызываются, когда объект передается в функцию `str()` или `repr()`.

Приведенный ниже код:

```python
from datetime import date

dt = date(2022, 10, 23)

print(str(dt) == dt.__str__())
print(repr(dt) == dt.__repr__())
```

выводит:

```no-highlight
True
True
```

Если методы `__str__()` и `__repr__()` не определены в классе, то используются их базовые реализации.

Приведенный ниже код:

```python
class MyClass:
    pass


obj = MyClass()

print(str(obj))
print(repr(obj))
```

выводит (адрес может отличаться):

```no-highlight
<__main__.MyClass object at 0x0000022392277A90>
<__main__.MyClass object at 0x0000022392277A90>
```

Обратите внимание, что если методы `__str__()` и `__repr__()` явно не определены в классе, то их базовые реализации возвращают одно и то же значение.

Строковое представление объектов по умолчанию не очень информативно, поэтому при реализации собственных классов бывает полезно определить методы `__str__()` и `__repr__()`, чтобы получить удобное строковое представление объектов как в формальном, так и в неформальном виде.

Рассмотрим класс `Cat` с реализованными методами `__str__()` и `__repr__()`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name                        # имя кошки

    def __str__(self):
        return f'Кот по имени {self.name}'

    def __repr__(self):
        return f"Cat('{self.name}')"


cat = Cat('Кемаль')

print(str(cat))
print(repr(cat))
```

выводит:

```no-highlight
Кот по имени Кемаль
Cat('Кемаль')
```

Здесь метод `__str__()` возвращает строку, которая представляет собой неформальное описание объекта. Метод `__repr__()` возвращает формальное представление объекта, которое можно преобразовать обратно в объект с помощью функции `eval()`.

Принято, что метод `__repr__()` должен возвращать строку, которую можно преобразовать обратно в объект с помощью функции `eval()`.

### Примечания

**Примечание 1.** Аналогично функции `print()`, если объект передается в функцию `format()` в качестве самостоятельного аргумента, то для его отображения автоматически вызывается функция `str()`.

Приведенный ниже код:

```python
from datetime import date

dt = date(2022, 10, 23)

print('Дата: {}'.format(dt))
print(f'Дата: {dt}')             # f-строки неявно вызывают format()
```

выводит:

```no-highlight
Дата: 2022-10-23
Дата: 2022-10-23
```

Во всех остальных случаях, то есть когда объект не передается в качестве самостоятельного аргумента, а, например, является элементом коллекции, вызывается функция `repr()`.

 Приведенный ниже код:

```python
from datetime import date

dates = [date(2022, 10, 23)]

print(dates)
print('Даты: {}'.format(dates))
print(f'Даты: {dates}')
```

выводит:

```no-highlight
[datetime.date(2022, 10, 23)]
Даты: [datetime.date(2022, 10, 23)]
Даты: [datetime.date(2022, 10, 23)]
```

**Примечание 2.** Если в классе реализован метод `__repr__()`, но не реализован метод `__str__()`, то при передаче экземпляра данного класса в функцию `str()` вызывается реализованный метод `__repr__()`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"Cat('{self.name}')"


cat = Cat('Кемаль')

print(str(cat))
print(repr(cat))
```

выводит:

```no-highlight
Cat('Кемаль')
Cat('Кемаль')
```

Однако если в классе реализован `__str__()`, но не реализован метод `__repr__()`, то при передаче экземпляра данного класса в функцию `repr()` вызывается базовая реализация метода `__repr__()`

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f'Кот по имени {self.name}'


cat = Cat('Кемаль')

print(str(cat))
print(repr(cat))
```

выводит:

```no-highlight
Кот по имени Кемаль
<__main__.Cat object at 0x0000023C38CB6C80>
```

**Примечание 3.** Методы `__str__()` и `__repr__()` всегда должны возвращать объект типа `str`, в противном случае будет возбуждено исключение `TypeError`.

**Примечание 4.** Хорошая статья от RealPython про строковое представление объектов доступна по [ссылке](https://realpython.com/python-repr-vs-str/).

## 5.3 Сравнение объектов
### Тема урока: сравнение объектов

1. Магические методы `__eq__()` и `__ne__()`
2. Константа `NotImplemented`
3. Магические методы `__lt__()` и `__gt__()`
4. Магические методы `__le__()` и `__ge__()`
5. Декоратор `@total_ordering`

**Аннотация.** Урок посвящен сравнению объектов.

### Магические методы __eq__() и __ne__()

Рассмотрим класс `Point`, описывающий точку на плоскости, и создадим два экземпляра этого класса:

```python
class Point:
    def __init__(self, x, y):
        self.x = x                       # координата точки по оси x
        self.y = y                       # координата точки по оси y


p1 = Point(1, 2)
p2 = Point(1, 2)
```

Точки `p1` и `p2` являются разными объектами, и мы можем в этом убедиться, сравнив их с помощью оператора `is`.

Приведенный ниже код:

```python
print(p1 is p2)
```

выводит:

```no-highlight
False
```

Если мы попытаемся сравнить два данных объекта с помощью оператора `==`, мы также получим в качестве результата `False`, несмотря на то что оба объекта имеют равные значения атрибутов.

Приведенный ниже код:

```python
print(p1 == p2)
```

выводит:

```no-highlight
False
```

Дело в том, что сравнение на равенство по умолчанию является сравнением на идентичность. Другими словами, если в классе не определено, как будет происходить сравнение с помощью оператора `==`, оно будет равносильно сравнению с помощью `is`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p1)
print(p2 == p2)
```

выводит:

```no-highlight
True
True
```

Чтобы определить, как будет происходить сравнение на равенство, нам требуется определить в классе метод `__eq__()`. Когда мы сравниваем два объекта с помощью оператора `==`, Python автоматически вызывает данный метод у левого операнда, передавая методу в качестве аргумента правый операнд. То есть выражение `p1 == p2` равносильно вызову `p1.__eq__(p2)`.

Для возможности сравнивать экземпляры класса `Point` определим в нем метод `__eq__()`. Будем считать точки равными, если они имеют равные координаты по обеим осям.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y


p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2)
print(p1 == p3)
print(p2 == p3)
```

выводит:

```no-highlight
True
False
False
```

Как мы видим, теперь равенство объектов определяется иначе, а именно на основании их координат. Точка `p1` равна точке `p2`, так как их координаты совпадают, в то время как точки `p1` и `p2` не равны точке `p3`, так как их координаты не совпадают.

Однако определенный нами метод `__eq__()` работает верно лишь в том случае, когда мы сравниваем объект типа `Point` с объектом такого же типа. Если мы попытаемся сравнить точку `p1`, скажем, с кортежем, мы получим ошибку.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y


p1 = Point(1, 2)

print(p1 == (1, 2))
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'tuple' object has no attribute 'x'
```

Чтобы это исправить, мы можем добавить в метод `__eq__()` проверку на то, что объект, с которым происходит сравнение, принадлежит необходимому типу. В противном случае метод может возбуждать исключение или возвращать значение `False`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False


p1 = Point(1, 2)

print(p1 == (1, 2))
```

выводит:

```no-highlight
False
```

Аналогично сравнению на равенство для сравнения на неравенство с помощью оператора `!=` используется магический метод `__ne__()`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False

    def __ne__(self, other):
        if isinstance(other, Point):
            return self.x != other.x or self.y != other.y
        return True


p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 != p2)
print(p1 != p3)
print(p2 != p3)
```

выводит:

```no-highlight
False
True
True
```

Важно отметить, что Python автоматически реализует метод `__ne__()`, если метод `__eq__()` уже реализован.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False


p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 != p2)
print(p1 != p3)
print(p2 != p3)
```

выводит:

```no-highlight
False
True
True
```

Однако если нам требуется несколько иная реализация, мы всегда можем определить метод `__ne__()` вручную.

При реализованном методе `__ne__()` метод `__eq__()` автоматически не реализуется.

### Константа NotImplemented

Как уже говорилось ранее, при сравнении двух объектов с помощью оператора `==` Python автоматически вызывает метод `__eq__()` у первого объекта, передавая методу в качестве аргумента второй. Однако если мы попробуем вызвать метод `__eq__()` у объекта, в классе которого данный метод не реализован, вместо значений `True` или `False` мы получим значение `NotImplemented`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1.__eq__(p2))
```

выводит:

```no-highlight
NotImplemented
```

Дело в том, что когда мы пытаемся сравнить два объекта с помощью оператора `==`, например, `p1` и `p2`, Python сначала вызывает метод `__eq__()` у первого объекта `p1`, и если метод возвращает значение `True` или `False`, оно становится результатом сравнения. Но если метод возвращает константу `NotImplemented`, Python вызывает метод `__eq__()` у второго объекта `p2`. Аналогично, если метод второго объекта возвращает значение `True` или `False`, оно становится результатом сравнения, однако если метод вновь возвращает `NotImplemented`, результатом сравнения становится значение `False`, так как `p1` не знает, как сравнивать себя с `p2`, как и `p2` не знает, как сравнивать себя с `p1`.

Именно константу `NotImplemented` рекомендуется возвращать в методе `__eq__()`, если сравнение для объектов каких-либо типов не определено.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p2)
print(p1 == None)
print(p1 == (1, 2))
```

выводит:

```no-highlight
True
False
False
```

### Примечания

**Примечание 1.** Метод `__eq__()`, помимо сравнения с помощью оператора `==`, также вызывается при проверке на принадлежность с помощью оператора `in`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        print('Вызов метода __eq__()')
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False


p = Point(2, 2)        
points = [Point(1, 1), Point(2, 2), Point(3, 3)]

print(p in points)
```

выводит:

```no-highlight
Вызов метода __eq__()
Вызов метода __eq__()
True
```

**Примечание 2.** Ветка с обсуждением константы `NotImplemented` на StackOverflow доступна по [ссылке](https://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror).

**Примечание 3.** Обычно при переопределении магического метода `__eq__()` также переопределяют метод `__hash__()`. Подробнее об этом мы поговорим в уроках, посвященных хешированию объектов.

### Магические методы __lt__() и __gt__()

Мы научились реализовывать сравнение на равенство с помощью оператора `==`, однако без нашего внимания остались сравнения на больше/меньше с помощью операторов `>, <`. Аналогично сравнению на равенство, данные операции реализуются с помощью соответствующих магических методов.

Рассмотрим класс `Fruit`, описывающий фрукт, и создадим два экземпляра этого класса:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name                          # название фрукта
        self.mass = mass                          # масса фрукта в граммах

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass        # два фрукта равны, если равны их массы
        return NotImplemented


fruit1 = Fruit('банан', 150)
fruit2 = Fruit('яблоко', 180)
```

В данном классе определено сравнение на равенство по следующему правилу: два фрукта считаются равными, если равны их массы. Однако масса является численной величиной, поэтому помимо равенства мы можем определить, например, какой из фруктов меньше (больше), в зависимости от того, чья масса меньше (больше). Для этого нам потребуется реализовать магические методы `__lt__()` и `__gt__()`.

Магический метод `__lt__()` отвечает за сравнение на меньше. То есть выражение `fruit1 < fruit2` равносильно вызову `fruit1.__lt__(fruit2)`. За сравнение на больше отвечает магический метод `__gt__()`, и аналогично предыдущему методу выражение `fruit1 > fruit2` равносильно вызову `fruit1.__gt__(fruit2)`.

Приведенный ниже код:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, Fruit):
            return self.mass > other.mass
        return NotImplemented


fruit1 = Fruit('банан', 150)
fruit2 = Fruit('яблоко', 180)

print(fruit1 < fruit2)
print(fruit1 > fruit2)
print(fruit2 < fruit1)
print(fruit2 > fruit1)
```

выводит:

```no-highlight
True
False
False
True
```

### Магические методы __le__() и __ge__()

Помимо строгих сравнений на больше/меньше существуют нестрогие сравнения, которые допускают равенство (операторы `>=, <=`). Данные операции реализуются с помощью магических методов `__le__()` и `__ge__()`.

Магический метод `__le__()` отвечает за сравнение на меньше или равно. То есть выражение `fruit1 <= fruit2` равносильно вызову `fruit1.__le__(fruit2)`. За сравнение на больше или равно отвечает магический метод `__ge__()`, и аналогично предыдущему методу выражение `fruit1 >= fruit2` равносильно вызову `fruit1.__ge__(fruit2)`.

Приведенный ниже код:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, Fruit):
            return self.mass <= other.mass
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, Fruit):
            return self.mass >= other.mass
        return NotImplemented


fruit1 = Fruit('банан', 150)
fruit2 = Fruit('яблоко', 180)
fruit3 = Fruit('груша', 150)

print(fruit1 <= fruit2)
print(fruit1 >= fruit2)
print(fruit1 <= fruit3)
print(fruit1 >= fruit3)
```

выводит:

```no-highlight
True
False
True
True
```

### Декоратор @total_ordering

Реализовывать каждую операцию сравнения в классе достаточно утомительно и многословно, особенно если сравнение имеет сложную структуру. Конечно, мы можем упростить данный процесс, явно реализовав только сравнение на равенство и, например, сравнение на меньше, а все остальные операции сравнения построить на основе этих двух с помощью логических операторов `and, or` и `not`:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, Fruit):
            return not self.__lt__(other) and not self.__eq__(other)
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, Fruit):
            return self.__lt__(other) or self.__eq__(other)
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, Fruit):
            return not self.__lt__(other)
        return NotImplemented
```

Однако проблему многословности такой подход не решает, так как в нашем классе по-прежнему присутствуют определения методов `__gt__(), __le__()` и `__ge__()`.

Декоратор класса `@total_ordering` из модуля `functools` позволяет определить в классе лишь метод `__eq__()` и один из методов `__lt__(), __le__(), __gt__()` или `__ge__()`. Все недостающие методы декоратор определит и реализует самостоятельно.

Приведенный ниже код реализует в классе `Fruit` все возможные операции сравнения:

```python
from functools import total_ordering


@total_ordering
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented
```

Принцип декорирования классов мы пока опустим, о нем мы будем говорить в модуле Дополнительные возможности.

### Примечания

**Примечание 1.** Документация по всем операторам сравнения доступна по [ссылке](https://docs.python.org/3/reference/datamodel.html#object.__eq__).

**Примечание 2.** Если в классе реализовано сравнение на больше (меньше), то сравнение на меньше (больше) для объектов этого класса можно считать реализованным автоматически. Аналогично себя ведут и нестрогие сравнения на больше/меньше.

Приведенный ниже код:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented


fruit1 = Fruit('банан', 150)
fruit2 = Fruit('яблоко', 180)

print(fruit1 < fruit2)
print(fruit1 > fruit2)
```

выводит:

```no-highlight
True
False
```

Дело в том, что выражение `fruit1 > fruit2` приводит к вызову метода `__gt__()` у `fruit1`, который возвращает константу `NotImplemented`, так как метод не реализован. Далее Python пытается получить значение выражения `fruit2 < fruit1`, что приводит к вызову метода `__lt__()` у `fruit2`, и так как данный метод уже реализован, возвращается результат сравнения в виде значения `False`.

Несмотря на данную особенность реализации, рекомендуется явно определять все методы сравнения вручную либо с помощью декоратора `@total_ordering`.

**Примечание 3.** После реализации в классе операторов сравнения на больше/меньше появляется возможность сортировать экземпляры этого класса и выбирать среди них наименьший/наибольший.

Приведенный ниже код:

```python
from functools import total_ordering


@total_ordering
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __repr__(self):
        return f'Fruit({repr(self.name)}, {self.mass})'

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented


fruits = [Fruit('яблоко', 180), Fruit('груша', 160), Fruit('авокадо', 170), Fruit('банан', 150)]

print(sorted(fruits))
print(min(fruits))
print(max(fruits))
```

выводит:

```python
[Fruit('банан', 150), Fruit('груша', 160), Fruit('авокадо', 170), Fruit('яблоко', 180)]
Fruit('банан', 150)
Fruit('яблоко', 180)
```

**Примечание 4.** Любая операция сравнения реализуется с помощью соответствующего магического метода. Методы для сравнения на равенство есть у любого класса по умолчанию, в то время как методы для сравнения на больше/меньше необходимо реализовывать самостоятельно, и если этого не сделать, при попытке сравнения двух объектов на больше/меньше будет возбуждено исключение.

Приведенный ниже код:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass


fruit1 = Fruit('банан', 150)
fruit2 = Fruit('яблоко', 180)

print(fruit1 < fruit2)
```

приводит к возбуждению исключения:

```no-highlight
TypeError: '<' not supported between instances of 'Fruit' and 'Fruit'
```

**Примечание 5.** Магические методы `__eq__(), __ne__(), __gt__(), __lt__(), __ge__()` и `__le__()` буквально соответствуют английским equal (равно), not equal (не равно), greater than (больше, чем), less than (меньше, чем), greater than or equal (больше или равно) и less than or equal (меньше или равно) соответственно.

## 5.4 Унарные операторы и функции
### Тема урока: унарные операторы и функции

1. Магические методы `__pos__(), __neg__()` и `__invert__()`
2. Магические методы `__abs__(), __round__()` и т.д.

**Аннотация.** Урок посвящен унарным операторам и функциям.

### Унарные операторы

Помимо операций сравнения существуют операции, в которых участвует лишь один операнд. За такие операции отвечают унарные операторы `+, -` и `~`.

Приведенный ниже код:

```python
num = 10

print(+num)
print(-num)
print(~num)
```

выводит:

```no-highlight
10
-10
-11
```

Поведение унарных операторов определяется соответствующими магическими методами:

- `__pos__()` — определяет поведение для унарного плюса
- `__neg__()` — определяет поведение для унарного минуса
- `__invert__()` — определяет поведение для оператора инвертирования

Рассмотрим класс `Angle`, описывающий угол от −180°−180° до 180°180°, и определим в этом классе поведение унарных операторов. Унарный плюс будет возвращать исходный угол. Отрицание будет возвращать исходный угол, взятый со знаком минус. Инвертирование для неотрицательного угла будет возвращать смежный угол, для отрицательного — диаметрально противоположный.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value                       # градусная мера угла

    def __repr__(self):
        return f'Angle({self.value})'

    def __pos__(self):
        return Angle(self.value)

    def __neg__(self):
        return Angle(-self.value)

    def __invert__(self):
        if 0 <= self.value <= 180:
            return Angle(180 - self.value)
        return Angle(180 + self.value)


angle = Angle(100)

print(+angle)
print(-angle)
print(~angle)
```

выводит:

```no-highlight
Angle(100)
Angle(-100)
Angle(80)
```

Обратите внимание, что унарные операторы возвращают новые объекты того же класса, а не изменяют исходный.

### Функции abs(), round(), trunc() и т.д.

Значения, получаемые при передаче объектов в такие функции как `abs(), round(), trunc(), floor()` и `ceil()`, так же определяются магическими методами:

- `__abs__()` — определяет поведение для встроенной функции `abs()`
- `__round__()` — определяет поведение для встроенной функции `round()`; помимо экземпляра класса метод принимает необязательный аргумент `n`, который, как правило, означает количество знаков после запятой после округления
- `__trunc__()` — определяет поведение для функции `trunc()` из модуля `math`
- `__floor__()` — определяет поведение для функции `floor()` из модуля `math`
- `__ceil__()` — определяет поведение для функции `ceil()` из модуля `math`

Приведенный ниже код:

```python
import math

class Angle:
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return f'Angle({self.value})'

    def __abs__(self):
        return Angle(abs(self.value))

    def __round__(self, n=None):
        if n is None:
            return Angle(round(self.value))
        return Angle(round(self.value, n))

    def __trunc__(self):
        return Angle(math.trunc(self.value))

    def __floor__(self):
        return Angle(math.floor(self.value))

    def __ceil__(self):
        return Angle(math.ceil(self.value))


angle = Angle(-101.54)

print(abs(angle))
print(round(angle))
print(round(angle, 1))
print(math.trunc(angle))
print(math.floor(angle))
print(math.ceil(angle))
```

выводит:

```no-highlight
Angle(101.54)
Angle(-102)
Angle(-101.5)
Angle(-101)
Angle(-102)
Angle(-101)
```

Здесь функции `abs(), round(), trunc(), floor()` и `ceil()` возвращают новые экземпляры класса `Angle`. Например, функция `abs()` возвращает угол, градусная мера которого взята по модулю. Оставшиеся функции возвращают углы, градусные меры которых округлены соответствующим образом.

### Примечания

**Примечание 1.** Из встроенных типов оператор инвертирования `~` определен лишь для типов `int` и `bool`. Значение выражения `~x` определяется как `-(x + 1)`.

Приведенный ниже код:

```python
print(~0)
print(~1)
print(~9)
print(~-10)
print(~20)
print(~True)                                     # равнозначно ~1
print(~False)                                    # равнозначно ~0
```

выводит:

```no-highlight
-1
-2
-10
9
-21
-2
-1
```

## 5.5 Арифметические операции
### Тема урока: арифметические операции

1. Магические методы `__add__(), __sub__()` и `__mul__()`
2. Магические методы `__truediv__(), __floordiv__()` и `__mod__()`
3. Отраженные арифметические операции
4. Магические методы `__iadd__(), __isub__(), __imul__(), __itruediv__(), __ifloordiv__()` и `__imod__()` 

**Аннотация.** Урок посвящен арифметическим операторам.

### Арифметические операции

Многие встроенные типы поддерживают операции сложения, вычитания, умножения и деления с помощью операторов `+, -, *, /, //` и `%`.

Приведенный ниже код:

```python
num1 = 50
num2 = 20

print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 % num2)
```

выводит:

```no-highlight
70
30
1000
2.5
2
10
```

Чтобы разрешить выполнять с экземплярами нашего класса различные арифметические операции, нам требуется определить в классе соответствующие магические методы:

- `__add__()` — определяет поведение для сложения (оператор `+`)
- `__sub__()` — определяет поведение для вычитания (оператор `-`)
- `__mul__()` — определяет поведение для умножения (оператор `*`)
- `__truediv__()` — определяет поведение для обычного деления (оператор `/`)
- `__floordiv__()` — определяет поведение для целочисленного деления (оператор `//`)
- `__mod__()` — определяет поведение для деления по модулю (оператор `%`)

Рассмотрим класс `PiggyBank`, описывающий копилку. Определим в классе магический метод `__add__()`, который позволит складывать экземпляр класса `PiggyBank` с целым числом, характеризующим количество монет. Результатом такой операции будет новый экземпляр класса `PiggyBank` с увеличенным количеством монет.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins                     # количество монет в копилке

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)


bank1 = PiggyBank(10)
bank2 = bank1 + 5
bank3 = bank1 + 15

print(bank1)
print(bank2)
print(bank3)
```

выводит:

```no-highlight
PiggyBank(10)
PiggyBank(15)
PiggyBank(25)
```

Обратите внимание, что результатами арифметических операций являются новые объекты того же класса.

Так как арифметические операции реализуются с помощью магических методов, мы можем сделать их более функциональными. Например, мы можем определить сложение экземпляров класса `PiggyBank` не только с целыми числами, но и с другими экземплярами класса `PiggyBank`.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        if isinstance(other, int):
            return PiggyBank(self.coins + other)
        elif isinstance(other, PiggyBank):
            return PiggyBank(self.coins + other.coins)
        return NotImplemented


bank1 = PiggyBank(10)
bank2 = bank1 + 5
bank3 = bank1 + bank2

print(bank1)
print(bank2)
print(bank3)
```

выводит:

```no-highlight
PiggyBank(10)
PiggyBank(15)
PiggyBank(25)
```

Аналогичным образом мы можем реализовать любую необходимую арифметическую операцию, определив в классе соответствующий магический метод.

### Отраженные арифметические операции

Как уже говорилось ранее, при выполнении арифметических операций Python автоматически вызывает соответствующий магический метод у первого операнда, передавая методу в качестве аргумента второй. Это говорит о том, что для корректного выполнения арифметических операций мы должны располагать операнды в определенном порядке, так как у одного из них реализация выполняемой операции может отсутствовать.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)


bank = PiggyBank(10)

print(bank + 5)
```

выводит:

```no-highlight
PiggyBank(15)
```

В то время как приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)


bank = PiggyBank(10)

print(5 + bank)
```

приводит к возбуждению исключения, так как выражение `5 + bank` преобразуется в вызов `(5).__add__(bank)`, а для типа `int` не реализовано сложение с типом `PiggyBank`:

```no-highlight
TypeError: unsupported operand type(s) for +: 'int' and 'PiggyBank'
```

Для реализации арифметических операций, не учитывающих порядок операндов, в Python доступен дополнительный набор магических методов с префиксом `r`:

- `__radd__()` — определяет поведение для сложения (оператор `+`)
- `__rsub__()` — определяет поведение для вычитания (оператор `-`)
- `__rmul__()` — определяет поведение для умножения (оператор `*`)
- `__rtruediv__()` — определяет поведение для обычного деления (оператор `/`)
- `__rfloordiv__()` — определяет поведение для целочисленного деления (оператор `//`)
- `__rmod__()` — определяет поведение для деления по модулю (оператор `%`)

Магические методы с префиксом `r` отличаются от своих основных версий (без префикса `r`) лишь тем, что применяются к разным операндам. Например, при сложении `x + y` метод `__add__()` вызывается у первого операнда и преобразуется в вызов `x.__add__(y)`, в то время как метод `__radd__()` вызывается у второго операнда и преобразуется в вызов `y.__radd__(x)`.

При любой арифметической операции сначала происходит попытка вызвать основную версию магического метода (без префикса `r`) у первого операнда, и если он не определен явно или при его вызове была возвращена константа `NotImplemented`, происходит попытка вызова отраженной версии магического метода (с префиксом `r`) у второго операнда.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)

    def __radd__(self, other):
        print('Вызов метода __radd__()')
        return self.__add__(other)


bank = PiggyBank(10)

print(5 + bank)
```

выводит:

```no-highlight
Вызов метода __radd__()
PiggyBank(15)
```

Именно константу `NotImplemented` рекомендуется возвращать в методах, реализующих арифметические операции, если эти операции для объектов каких-либо типов не определены, как, например, это делает тип `int`.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)

    def __radd__(self, other):
        print('Вызов метода __radd__()')
        return self.__add__(other)


bank = PiggyBank(10)
num = 5

print(num.__add__(bank))
```

выводит:

```no-highlight
NotImplemented
```

### Примечания

**Примечание 1.** Определив в классе магический метод `__pow__()`, можно выполнять операцию возведения в степень с помощью оператора `**`.

**Примечание 2.** Определив в классе магический метод `__divmod__()`, можно передавать экземпляры класса во встроенную функцию `divmod()`.

**Примечание 3.** Помимо арифметических операций, в Python существуют операции двоичного сдвига и логические операции. Как и прежде, они реализуются с помощью соответствующих магических методов:

- `__lshift__()` — определяет поведение для двоичного сдвига влево (оператор `<<`)
- `__rshift__()` — определяет поведение для двоичного сдвига вправо (оператор `>>`)
- `__and__()` — определяет поведение для двоичного И (оператор `&`)
- `__or__()` — определяет поведение для двоичного ИЛИ (оператор `|`)
- `__xor__()` — определяет поведение для двоичного XOR, (оператор `^`)

Все приведенные выше методы также имеют отраженные версии (с префиксом `r`).

**Примечание 4.** После реализации в классе операторов сложения появляется возможность складывать экземпляры этого класса с помощью встроенной функции `sum()`.

Приведенный ниже код:

```
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        if isinstance(other, int):
            return PiggyBank(self.coins + other)
        elif isinstance(other, PiggyBank):
            return PiggyBank(self.coins + other.coins)
        return NotImplemented

    def __radd__(self, other):
        return self.__add__(other)


banks = [PiggyBank(10), PiggyBank(20), PiggyBank(30)]

print(sum(banks))
```

выводит:

```no-highlight
PiggyBank(60)
```

### Операторы составного присваивания

Помимо основных арифметических операторов (`+, -, *` и т.д.), в Python есть операторы составного присваивания (`+=, -=, *=`  и т.д.). Главным отличием данных операторов является то, что первые всегда создают новый объект, в то время как вторые изменяют исходный объект, если он принадлежит изменяемому типу данных.

Приведенный ниже код:

```python
nums = [1, 2, 3]
print(id(nums), nums)

nums = nums + [4, 5, 6]
print(id(nums), nums)
```

выводит (адреса могут отличаться):

```no-highlight
1912325834112 [1, 2, 3]
1912378506496 [1, 2, 3, 4, 5, 6]
```

В то время как приведенный ниже код:

```python
nums = [1, 2, 3]
print(id(nums), nums)

nums += [4, 5, 6]
print(id(nums), nums)
```

выводит (адреса могут отличаться):

```no-highlight
2891153376640 [1, 2, 3]
2891153376640 [1, 2, 3, 4, 5, 6]
```

 Поведение операторов составного присваивания определяется соответствующими магическими методами:

- `__iadd__()` — определяет поведение для сложения (оператор `+=`)
- `__isub__()` — определяет поведение для вычитания (оператор `-=`)
- `__imul__()` — определяет поведение для умножения (оператор `*=`)
- `__itruediv__()` — определяет поведение для обычного деления (оператор `/=`)
- `__ifloordiv__()` — определяет поведение для целочисленного деления (оператор `//=`)
- `__imod__()` — определяет поведение для деления по модулю (оператор `%=`)

Префикс `i` в названиях методов составного присваивания является сокращением слова inplace (на месте).

Рассмотрим класс `PiggyBank`, описывающий копилку. Определим в классе магический метод `__add__()`, который позволит складывать экземпляр класса `PiggyBank` с целым числом, характеризующим количество монет. Результатом такой операции будет новый экземпляр класса `PiggyBank` с увеличенным количеством монет. Также определим в классе магический метод `__iadd__()`, реализующий аналогичную операцию сложения с целым числом, однако результатом которой будет исходный измененный объект, так как экземпляры класса `PiggyBank` являются изменяемыми.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins                         # количество монет в копилке

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)       # создаем и возвращаем новый объект

    def __iadd__(self, other):
        self.coins += other
        return self                                # возвращаем измененный объект


bank = PiggyBank(10)

bank += 10
bank += 5

print(bank)
```

выводит:

```no-highlight
PiggyBank(25)
```

Аналогичным образом мы можем реализовать любую необходимую арифметическую операцию с помощью оператора составного присваивания, определив в классе соответствующий магический метод. И если экземпляры класса являются изменяемыми, результатом такой операции должен являться измененный исходный экземпляр.

### Примечания

**Примечание 1.** Если в классе не определены магические методы с префиксом `i`, но определены их основные версии (без префикса `i`), то операторами составного присваивания пользоваться можно. Однако результатами таких арифметических операций всегда будут новые объекты. Это удобно в том случае, когда экземпляры класса являются неизменяемыми.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        print('Вызов метода __add__()')
        return PiggyBank(self.coins + other)

    def __iadd__(self, other):
        print('Вызов метода __iadd__()')
        self.coins += other
        return self


bank = PiggyBank(10)

bank += 10

print(bank)
```

выводит:

```no-highlight
Вызов метода __iadd__()
PiggyBank(20)
```

В то время как приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        print('Вызов метода __add__()')
        return PiggyBank(self.coins + other)


bank = PiggyBank(10)

bank += 10                       # вызовы методов с префиксом i делигируются их основным версиям

print(bank)
```

выводит:

```no-highlight
Вызов метода __add__()
PiggyBank(20)
```

**Примечание 2.** Для неизменяемых объектов арифметические операции с операторами составного присваивания равнозначны обычным арифметическим операциям и являются, по сути, лишь краткой записью.

Приведенный ниже код:

```python
num = 10
print(id(num), num)

num += 5                         # создается новый объект, так как исходный является неизменямым
print(id(num), num)
```

выводит (адреса могут отличаться):

```no-highlight
2275079553552 10
2275079553712 15
```

**Примечание 3.** Таблица всех операторов составного присваивания:

|Составной оператор|Магический метод|
|---|---|
|`+=`|`__iadd__()`|
|`-=`|`__isub__()`|
|`*=`|`__imul__()`|
|`/=`|`__itruediv__()`|
|`//=`|`__ifloordiv__()`|
|`%=`|`__imod__()`|
|`**=`|`__ipow__()`|
|`<<=`|`__ilshift__()`|
|`>>=`|`__irshift__()`|
|`&=`|`__iand__()`|
|`^=`|`__ixor__()`|
|`\|=`|`__ior__()`|

## 5.6 Вызываемые объекты
###  Тема урока: вызываемые объекты

1. Вызываемые объекты
2. Магический метод `__call__()`

**Аннотация.** Урок посвящен вызываемым объектам.

### Вызываемые объекты

C самого начала изучения Python мы используем функции, как встроенные, так и написанные самостоятельно. Отличительной особенностью функций является то, что их можно вызывать с помощью круглых скобок `()`, передавая необходимый набор аргументов, если это требуется.

Приведенный ниже код:

```python
def add(a, b):
    return a + b

mul = lambda a, b: a * b

print(add(1, 2))                           # вызываем собственную функцию
print(mul(1, 2))                           # вызываем собственную лямбда функцию
print(len([1, 2, 3]))                      # вызываем встроенную функцию
```

выводит:

```no-highlight
3
2
3
```

Любая функция является вызываемой, то есть представляет собой объект, который можно вызвать. Однако не только функции являются вызываемыми. Например, если мы вызовем встроенную функцию `map()`, то в качестве результата получим объект типа `map`.

Приведенный ниже код:

```python
numbers = map(abs, [-1, 2, -3, 4, -5])

print(numbers)
print(type(numbers))
```

выводит (адрес может отличаться):

```no-highlight
<map object at 0x0000028C708A6C80>
<class 'map'>
```

Что дает нам заключить, что на самом деле `map()` является не функцией, а классом.

Приведенный ниже код:

```no-highlight
print(map)
```

выводит:

```no-highlight
<class 'map'>
```

Дело в том, что зачастую мы не совсем четко используем слово "функция", так как мыслим в терминах **утиной типизации**. Мы называем `map()` функцией, потому что она ведет себя как функция (мы можем ее вызвать с помощью круглых скобок). Но корректнее будет назвать `map()` **вызываемым объектом**.

Утиная типизация — это концепция, характерная для языков программирования с динамической типизацией, согласно которой конкретный класс объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает.

Таким образом, и функции, и классы в Python являются вызываемыми объектами.

### Магический метод __call__()

Функции и классы являются вызываемыми, однако мы можем создать собственные вызываемые объекты, реализовав в классе магический метод `__call__()`. Данный метод позволяет экземплярам класса вести себя так, как будто они функции, то есть мы можем вызывать их, передавать их в функции, которые ожидают в качестве аргумента функцию, и так далее.

Рассмотрим класс `Cat`, описывающий кошку. Определим в классе магический метод `__call__()`, при вызове которого будет выводиться сообщение с указанием имени кошки.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name                   # имя кошки

    def __call__(self):
        print('Меня зовут', self.name)


cat = Cat('Кемаль')

cat()                                      # равнозначно cat.__call__()
```

выводит:

```no-highlight
Меня зовут Кемаль
```

Магический метод `__call__()`, являясь обычным методом экземпляра, может принимать произвольное количество аргументов. И если они есть, то при вызове экземпляров класса их потребуется передать.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def __call__(self, speech):
        print('Меня зовут', self.name, 'и я делаю', speech)


cat = Cat('Кемаль')

cat('Мяу')                                 # равнозначно cat.__call__('Мяу')
cat('Мяяяяяy')                             # равнозначно cat.__call__('Мяяяяяy')
```

выводит:

```python
Меня зовут Кемаль и я делаю Мяу
Меня зовут Кемаль и я делаю Мяяяяяy
```

#### Сценарии использования метода __call__()

**Сценарий 1.** Класс с реализованным методом `__call__()` может быть хорошей альтернативой замыканиям.

Рассмотрим функцию `line_generator()`, представляющую генератор линейных функций �=��+�y=kx+b. Данная функция принимает в качестве аргументов параметры �k и �b и возвращает линейную функцию с данными параметрами.

Приведенный ниже код:

```python
def line_generator(k, b):
    def func(x):
        return k * x + b
    return func

line_func1 = line_generator(2, 5)          # получаем функцию y = 2*x + 5
line_func2 = line_generator(-6, 9)         # получаем функцию y = -6*x + 9

print(line_func1(10))                      # выводим значение 2*10 + 5 = 25
print(line_func2(4))                       # выводим значение -6*4 + 9 = -15
```

выводит:

```no-highlight
25
-15
```

Аналогичный генератор мы можем реализовать с помощью класса `LineGenerator`, определив в нем магический метод `__call__()`.

Приведенный ниже код:

```python
class LineGenerator:
    def __init__(self, k, b):
        self.k = k
        self.b = b

    def __call__(self, x):
        return self.k * x + self.b


line_func1 = LineGenerator(2, 5)           # получаем функцию y = 2*x + 5
line_func2 = LineGenerator(-6, 9)          # получаем функцию y = -6*x + 9

print(line_func1(10))                      # выводим значение 2*10 + 5 = 25
print(line_func2(4))                       # выводим значение -6*4 + 9 = -15
```

выводит:

```no-highlight
25
-15
```

Несмотря на то что объекты класса `LineGenerator` не являются функциями, они являются вызываемыми объектами, которые в полной мере выполняют поставленную задачу.

**Сценарий 2.** Метод `__call__()` позволяет реализовывать декораторы на основе классов.

Рассмотрим декоратор `uppercase_decorator()`, который преобразовывает строковый результат декорируемой функции в верхний регистр.

Приведенный ниже код:

```python
def uppercase_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs).upper()
    return wrapper

@uppercase_decorator
def greet(name):
    return f'Привет, {name}'

print(greet('Кемаль'))
```

выводит:

```no-highlight
ПРИВЕТ, КЕМАЛЬ
```

Аналогичный декоратор мы можем реализовать с помощью класса `UppercaseDecorator`, определив в нем магический метод `__call__()`.

Приведенный ниже код:

```python
class UppercaseDecorator:
    def __init__(self, func):
        self.func = func
 
    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs).upper()


@UppercaseDecorator
def greet(name):
    return f'Привет, {name}'

print(greet('Кемаль'))
```

выводит:

```no-highlight
ПРИВЕТ, КЕМАЛЬ
```

Как мы видим, принцип создания декораторов на основе классов довольно прост. Достаточно запомнить декорируемую функцию, а затем расширить ее функционал в магическом методе `__call__()`.

**Сценарий 3.** Магический метод `__call__()` может быть полезен в классах, чьи экземпляры часто изменяют своё состояние. Вызов экземпляра класса может быть интуитивно понятным способом изменить состояние объекта.

Рассмотрим класс `Point`, описывающий точку на плоскости. Определим в классе метод `__call__()`, позволяющий изменять координаты точки по обеим осям.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __call__(self, x, y):
        self.x, self.y = x, y


point = Point(1, 2)
print(point.x, point.y)

point(3, 4)
print(point.x, point.y)
```

выводит:

```no-highlight
1 2
3 4
```

### Примечания

**Примечание 1.** Чтобы проверить, является ли объект вызываемым, нужно проверить у него наличие метода `__call__()`.

Приведенный ниже код:

```python
print(hasattr(int, '__call__'))
print(hasattr(len, '__call__'))
print(hasattr(1, '__call__'))
```

выводит:

```no-highlight
True
True
False
```

Однако на практике для этого используется встроенная функция `callable()`, которая возвращает `True`, если переданный объект является вызываемым, или `False` в противном случае.

Приведенный ниже код:

```python
print(callable(int))
print(callable(len))
print(callable(1))
```

выводит:

```no-highlight
True
True
False
```

**Примечание 2.** Замыкание — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.

**Примечание 3.** Хорошая статья на тему вызываемых объектов в Python доступна по [ссылке](https://www.pythonmorsels.com/class-function-and-callable/).

## 5.7 Преобразования типов
### Тема урока: преобразование типов

1. Магический метод `__bool__()`
2. Магические методы `__int__(), __float__()` и `__complex__()`

**Аннотация.** Урок посвящен преобразованию типов.

### Магический метод __bool__()

Любой объект в Python можно проверить на истинность и привести к логическому типу с помощью функции `bool()`.

Приведенный ниже код:

```python
obj1 = 10
obj2 = []

print(bool(obj1))
print(bool(obj2))

print('bee' if obj1 else 'geek')
print('bee' if obj2 else 'geek')
```

выводит:

```no-highlight
True
False
bee
geek
```

Мы уже знакомы с тем, как приводятся к логическому типу экземпляры встроенных классов. Например, любое ненулевое число или любой непустой список преобразуются в значение `True`. Однако если мы попытаемся привести к логическому типу экземпляры собственных классов, то заметим, что все они без исключения преобразуются в значение `True`.

Рассмотрим класс `Angle`, описывающий угол от −180°−180° до 180°180°, и приведем его экземпляры к логическому типу.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value                      # градусная мера угла


print(bool(Angle(-110)))
print(bool(Angle(0)))
print(bool(Angle(0.0)))
print(bool(Angle(120.1)))
```

выводит:

```no-highlight
True
True
True
True
```

За приведение экземпляра класса к логическому типу и его поведение при передаче в функцию `bool()` отвечает магический метод `__bool__()`. Реализовав данный метод в классе, мы можем определить, какие экземпляры считаем истинными, а какие ложными.

Реализуем в классе `Angle` магический метод `__bool__()`. Будем считать экземпляр класса истинным, если он представляет ненулевой угол, в противном случае будем считать его ложным.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        return self.value != 0


print(bool(Angle(-110)))
print(bool(Angle(0)))
print(bool(Angle(0.0)))
print(bool(Angle(120.1)))
```

выводит:

```no-highlight
True
False
False
True
```

Помимо магического метода `__bool__()`, за приведение объекта к логическому типу и его поведение при передаче в функцию `bool()` может отвечать и магический метод `__len__()`, о котором мы будем говорить чуть позже в модуле Протоколы. Если в классе не реализован метод `__bool__()`, то происходит попытка вызова метода `__len__()`, и если он реализован и возвращает ненулевое значение, то объект считается истинным, в противном случае объект считается ложным.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __len__(self):
        print('Вызов метода __len__()')
        return self.value != 0


print(bool(Angle(-110)))
print(bool(Angle(0)))
print(bool(Angle(120.1)))
```

выводит:

```no-highlight
Вызов метода __len__()
True
Вызов метода __len__()
False
Вызов метода __len__()
True
```

Если в классе отсутствуют оба магических метода `__bool__()` и `__len__()`, то все экземпляры этого класса считаются истинными. Если же в классе присутствуют оба данных метода, то для всех логических приведений будет использоваться именно метод `__bool__()`.

### Магические методы __int__(), __float__() и __complex__()

В Python объекты одних типов можно преобразовывать в объекты других типов. Например, строку можно преобразовать в целое число или целое число преобразовать в вещественное.

Приведенный ниже код:

```python
print(int('10'))
print(int(10.1))
print(float(10))
print(float('10.1'))
print(complex('1+5j'))
```

выводит:

```no-highlight
10
10
10.0
10.1
(1+5j)
```

Преобразовывать экземпляры собственных классов в объекты типа `int, float` и `complex` можно, определив в классе ряд магических методов:

- `__int__()` — определяет поведение экземпляра при передаче в функцию `int()`. Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип `int`
- `__float__()` — определяет поведение экземпляра при передаче в функцию `float()`. Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип `float`
- `__complex__()` — определяет поведение экземпляра при передаче в функцию `complex()`. Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип `complex`

Определим в классе `Angle` методы `__int__()` и `__float__()`, которые позволят преобразовывать экземпляры этого класса в целые и вещественные числа соответственно.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)


angle1 = Angle(100)
angle2 = Angle(100.1)

print(int(angle1))
print(int(angle2))
print(float(angle1))
print(float(angle2))
```

выводит:

```no-highlight
100
100
100.0
100.1
```

### Примечания

**Примечание 1.** Вызов магического метода `__bool__()` (в определенных случаях `__len__()`) происходит во время любых логических приведений. Например, при проверке на истинность с помощью условного оператора `if`.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        print('Вызов метода __bool__()')
        return bool(self.value)


angle = Angle(100)

if angle:
    print('I am True')
else:
    print('I am False')
```

выводит:

```no-highlight
Вызов метода __bool__()
I am True
```

**Примечание 2.** Встроенные функции `all()` и `any()` так же приводят к вызову метода `__bool__()` (в определенных случаях `__len__()`), поэтому реализовав в классе приведение к логическому типу, мы можем полноценно пользоваться данными функциями, передавая им в качестве аргументов экземпляры собственных классов.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        print('Вызов метода __bool__()')
        return bool(self.value)


angles = [Angle(100), Angle(110), Angle(-50), Angle(0)]

print(all(angles))
print()
print(any(angles))
```

выводит:

```no-highlight
Вызов метода __bool__()
Вызов метода __bool__()
Вызов метода __bool__()
Вызов метода __bool__()
False

Вызов метода __bool__()
True
```

**Примечание 3.** Если методы `__int__()`, `__float__()` и `__complex__()` не определены, соответствующие функции будут обращаться к методу `__index__()`, который указывает на то, что объект имеет целочисленный тип. Этот метод должен возвращать целое число, которое и будет передаваться в эти функции. Наличие этого метода у класса так же позволяет применять к экземпляру этого класса функции преобразования в другую систему счисления, такие как `bin()`, `oct()` и `hex()`.

Приведенный ниже код:

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __index__(self):
        print('Вызов метода __index__()')
        return self.value


angle = Angle(100)

print(int(angle))
print(float(angle))
print(bin(angle))
print(oct(angle))
print(hex(angle))
```

выводит:

```no-highlight
Вызов метода __index__()
100
Вызов метода __index__()
100.0
Вызов метода __index__()
0b1100100
Вызов метода __index__()
0o144
Вызов метода __index__()
0x64
```

## 5.8 Работа с атрибутами объектов
### Тема урока: работа с атрибутами объектов

1. Операции с атрибутами
2. Магические методы `__getattribute__()` и `__getattr__()`
3. Магический метод `__setattr__()`
4. Магический метод `__delattr__()`

**Аннотация.** Урок посвящен работе с атрибутами объектов.

### Операции с атрибутами

Атрибуты являются важной частью любого объекта, целью которых является хранение информации об объекте. Атрибуты можно устанавливать, получать, изменять их значения, а также удалять:

```python
class MyObject:
    pass


obj = MyObject()

obj.attr = 1                                            # установка атрибута
obj.attr                                                # получение значения атрибута
obj.attr = 2                                            # изменение значения атрибута
del obj.attr                                            # удаление атрибута
```

Каждая из представленных операций выполняется путем вызова соответствующего магического метода:

- `__getattribute__()` — вызывается при обращении к любому атрибуту
- `__getattr__()` — вызывается при обращении к несуществующему атрибуту
- `__setattr__()` — вызывается при установке атрибута или изменении его значения
- `__delattr__()` — вызывается при удалении любого атрибута

### Методы __getattribute__() и __getattr__()

В Python операция обращения к атрибуту определяется не одним, а двумя магическими методами: `__getattribute__()` и `__getattr__()`. Разница между ними в том, что метод `__getattribute__()` вызывается первым и вызывается всегда, а метод `__getattr__()` вызывается только в том случае, если атрибута, к которому происходит обращение, не существует. Если атрибут существует, метод `__getattribute__()` возвращает его значение, в противном случае вызывается метод `__getattr__()`.

Метод `__getattribute__()` может либо сам вызвать метод `__getattr__()`, либо возбудить исключение `AttributeError`, и тогда метод `__getattr__()` будет вызван автоматически.

#### Метод __getattribute__()

Рассмотрим класс `Cat` и определим в нем метод `__getattribute__()`, внутри которого дополнительно будем выводить информирующий текст.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name                                # имя кошки
        
    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return object.__getattribute__(self, attr)      # получение значения атрибута attr объекта self


cat = Cat('Кемаль')

print(cat.name)
```

выводит:

```no-highlight
Возвращаю значение атрибута name
Кемаль
```

Для понимания принципа получения значения атрибута в теле метода `__getattribute__()` нужно вспомнить про существование базового класса `object`. Здесь мы обращаемся к методу `__getattribute__()` класса `object` и передаем ему в качестве аргумента объект и имя атрибута, значение по которому хотим получить. Метод `__getattribute__()` класса `object` возвращает значение атрибута по указанному имени или возбуждает исключение `AttributeError`, если атрибут с указанными именем не был найден.

Может возникнуть вопрос, почему мы пользуемся базовой реализацией метода `__getattribute__()`, вместо того чтобы обратиться к атрибуту через словарь атрибутов `__dict__`. Дело в том, что обращение к словарю `__dict__` приведет к бесконечным рекурсивным вызовам метода `__getattribute__()`, так как словарь `__dict__` сам является атрибутом.

 Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return self.__dict__[attr]


cat = Cat('Кемаль')

print(cat.name)
```

выводит:

```no-highlight
Возвращаю значение атрибута name
Возвращаю значение атрибута __dict__
Возвращаю значение атрибута __dict__
Возвращаю значение атрибута __dict__
Возвращаю значение атрибута __dict__
...
```

до тех пор, пока не будет достигнуто максимальное значение глубины рекурсии, а затем возбуждает исключение:

```no-highlight
RecursionError: maximum recursion depth exceeded while calling a Python object
```

Метод `__getattribute__()` может вести себя так, будто атрибут заведомо существует, и не выполнять каких-либо дополнительных проверок. Если атрибута не существует, базовая реализация все равно возбудит исключение `AttributeError`, и управление будет передано методу `__getattr__()`.

#### Метод __getattr__()

Как уже было сказано, метод `__getattr__()` вызывается только в двух случаях:

- если в теле метода `__getattribute__()` было возбуждено исключение `AttributeError`
- если метод `__getattr__()` был явно вызван в теле метода `__getattribute__()`

Применять метод `__getattr__()` можно по-разному. Cамый простой вариант — возврат значения по умолчанию при обращении к несуществующему атрибуту, вместо привычного возбуждения исключения `AttributeError`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name
        
    def __getattr__(self, attr):
        print(f'Возвращаю значение по умолчанию')
        return None


cat = Cat('Кемаль')

print(cat.name)                                         # обращение к существующему атрибуту
print(cat.age)                                          # обращение к несуществующему атрибуту
print(cat.breed)                                        # обращение к несуществующему атрибуту
```

выводит:

```no-highlight
Кемаль
Возвращаю значение по умолчанию
None
Возвращаю значение по умолчанию
None
```

Также с помощью метода `__getattr__()` можно имитировать наличие различных атрибутов, которыми объект на самом деле не обладает.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed                              # порода кошки
        
    def __getattr__(self, attr):
        if attr == 'info':
            return f'Имя: {self.name}\nПорода: {self.breed}'
        raise AttributeError


cat = Cat('Кемаль', 'Британский')

print(cat.info)                                         # обращение к несуществующему атрибуту
```

выводит:

```no-highlight
Имя: Кемаль
Порода: Британский
```

### Метод __setattr__()

Метод `__setattr__()` вызывается при установке атрибута или при изменении его значения. Данный метод может быть полезен в том случае, если перед установкой атрибута мы хотим как-либо модифицировать его имя или значение, например, предварить его имя символом нижнего подчеркивания, чтобы сделать атрибут защищенным.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    def __setattr__(self, attr, value):
        attr = '_' + attr
        self.__dict__[attr] = value


cat = Cat('Кемаль', 'Британский')

print(cat.__dict__)
```

выводит:

```no-highlight
{'_name': 'Кемаль', '_breed': 'Британский'}
```

Важно заметить, что установка атрибута или изменение его значения внутри метода `__setattr__()` происходит напрямую через словарь атрибутов `__dict__`. Если попытаться сделать это через точечную нотацию, то, во-первых, метод `__setattr__()` будет рекурсивно вызывать сам себя, а во-вторых, будет устанавливать атрибут с фиксированным именем.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def __setattr__(self, attr, value):
        print(f'Устанавливаю атрибуту {attr} значение {value}')
        attr = '_' + attr
        self.attr = value


cat = Cat('Кемаль', 'Британский')

print(cat.__dict__)
```

выводит:

```no-highlight
Устанавливаю атрибуту name значение Кемаль
Устанавливаю атрибуту attr значение Кемаль
Устанавливаю атрибуту attr значение Кемаль
Устанавливаю атрибуту attr значение Кемаль
...
```

до тех пор, пока не будет достигнуто максимальное значение глубины рекурсии, а затем возбуждает исключение:

```no-highlight
RecursionError: maximum recursion depth exceeded while calling a Python object
```

Обратите внимание, что второй и последующий вызовы устанавливают значение атрибуту `attr`, а не `name`, так как именно оно указано после точки.

Вместо обращения к словарю атрибутов `__dict__`, метод `__setattr__()` может использовать свою базовую реализацию из класса `object`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    def __setattr__(self, attr, value):
        attr = '_' + attr
        object.__setattr__(self, attr, value)


cat = Cat('Кемаль', 'Британский')

print(cat.__dict__)
```

выводит:

```no-highlight
{'_name': 'Кемаль', '_breed': 'Британский'}
```

### Метод __delattr__()

Метод `__delattr__()` вызывается при удалении атрибута.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    def __delattr__(self, attr):
        print(f'Удаляю атрибут {attr}')
        del self.__dict__[attr]


cat = Cat('Кемаль', 'Британский')

del cat.name
print(cat.__dict__)

del cat.breed
print(cat.__dict__)
```

выводит:

```no-highlight
Удаляю атрибут name
{'breed': 'Британский'}
Удаляю атрибут breed
{}
```

Аналогично методу `__setattr__()`, удаление атрибута внутри метода `__delattr__()` происходит напрямую через словарь атрибутов `__dict__`.

Вместо обращения к словарю атрибутов `__dict__`, метод `__delattr__()` может использовать свою базовую реализацию из класса `object`.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    def __delattr__(self, attr):
        print(f'Удаляю атрибут {attr}')
        object.__delattr__(self, attr)


cat = Cat('Кемаль', 'Британский')

del cat.name
print(cat.__dict__)

del cat.breed
print(cat.__dict__)
```

выводит:

```no-highlight
Удаляю атрибут name
{'breed': 'Британский'}
Удаляю атрибут breed
{}
```

### Примечания

**Примечание 1.** Вызов функций `getattr(), setattr()` и `delattr()`, аналогично точечной нотации, приводит к вызовам соответствующих магических методов `__getattribute__(), __getattr__(), __setattr__()` и `__delattr__()`.

Приведенный ниже код:

```python
class Cat:
    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return object.__getattribute__(self, attr)
    
    def __getattr__(self, attr):
        print(f'Возвращаю значение по умолчанию')
        return None
    
    def __setattr__(self, attr, value):
        print(f'Устанавливаю атрибуту {attr} значение {value}')
        self.__dict__[attr] = value
    
    def __delattr__(self, attr):
        print(f'Удаляю атрибут {attr}')
        del self.__dict__[attr]


cat = Cat()

setattr(cat, 'name', 'Кемаль')
print()
getattr(cat, 'name')
print()
getattr(cat, 'breed')
print()
delattr(cat, 'name')
```

выводит:

```no-highlight
Устанавливаю атрибуту name значение Кемаль
Возвращаю значение атрибута __dict__

Возвращаю значение атрибута name

Возвращаю значение атрибута breed
Возвращаю значение по умолчанию

Удаляю атрибут name
Возвращаю значение атрибута __dict__
```

**Примечание 2.** Интересные статьи по методам  `__getattribute__(), __getattr__(), __setattr__()` и `__delattr__()` на [русском](https://docs-python.ru/tutorial/klassy-jazyke-python/nastrojka-dostupa-atributam-klassa/) и [английском](https://realpython.com/python-getter-setter/) языках.

## 5.9 Хеширование объектов. Часть 1
### Тема урока: хеширование объектов

1. Хеширование
2. Области применения хеширования
3. Встроенная функция `hash()`
4. Сужение диапазона хеш-значений
5. Характеристики хорошей хеш-функции
6. Создание собственной хеш-функции

**Аннотация.** Урок посвящен хешированию объектов.

### Хеширование

Хеш-функция — функция, осуществляющая преобразование набора входных данных **произвольного размера** в последовательность **фиксированного размера**, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, называется **хешированием**, а результат преобразования называется **хешем, хеш-значением** или **хеш-кодом**.

![](https://ucarecdn.com/5af6d57f-1945-47bf-8170-bf76f0994843/-/crop/1290x297/0,81/-/preview/)

#### Принцип работы хеширования

Рассмотреть принцип работы хеширования можно на примере одной из популярных хеш-функций — SHA-1. Например, название нашей онлайн-школы `beegeek` после преобразования данной хеш-функцией будет выглядеть следующим образом:

```no-highlight
d7dd6be4b4a8a123f201ecbcacaf5883f1cec5e0
```

Если мы незначительно изменим входные данные, записав вместо строчной `b` заглавную `B`, то хеш-значение примет вид:

```no-highlight
4f27087e433ab69ec25abfee3eb192980c0887eb
```

Несложно заметить, что небольшие изменения во входных данных приводят к большим изменениям в хеш-значениях. Такой эффект называется **лавинообразным эффектом** и является одной из характеристик хорошей хеш-функции.

Опробовать различные популярные хеш-функции, такие как SHA-1 и MD5, можно по [ссылке](http://www.sha1-online.com/).

В определении хеш-функции, приведенном в начале урока, было сказано, что она преобразует данные произвольного размера в данные фиксированного размера. Например, рассматриваемая хеш-функция SHA-1 всегда возвращает строку из `40` цифр и/или строчных латинских символов, независимо от объема входных данных: это может быть как строка из `7` символов, так и из `7000`.

Например, хеш-значение [манифеста будущего программиста](https://stepik.org/media/attachments/lesson/886253/%D0%9C%D0%B0%D0%BD%D0%B8%D1%84%D0%B5%D1%81%D1%82_%D0%B1%D1%83%D0%B4%D1%83%D1%89%D0%B5%D0%B3%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%B0.pdf) имеет вид 🐍:

```no-highlight
935236841881d38b87a69fe6d90f1c29fe5d0129
```

#### Коллизия хеш-функции

**Коллизией хеш-функции** называется ситуация, когда у двух **разных** наборов входных данных **совпадают** хеш-значения. Коллизии существуют для большинства хеш-функций, но для хороших хеш-функций частота их возникновения сведена к минимуму.

В некоторых частных случаях, когда множество различных входных данных конечно, можно задать хеш-функцию, не имеющую коллизий. Однако для хеш-функций, принимающих на вход произвольное количество данных переменной длины и возвращающих хеш-значения постоянной длины, коллизии обязаны существовать, поскольку хотя бы для одного значения хеш-функции соответствующее ему множество входных данных будет бесконечно — и любые два набора данных из этого множества образуют коллизию.

#### Детерминированность

Одной из характеристик хеш-функции является **детерминированность**, то есть при одинаковых входных данных она возвращает одинаковый результат. Из этого следуют два следующих утверждения:

1. если мы имеем два равных набора данных, то хеш-значения этих наборов тоже будут равны
2. если мы имеем два набора данных, хеш-значения которых не равны, то и сами наборы тоже будут не равны

Важно понимать, что из равенства хеш-значений двух наборов данных мы не можем однозначно заключить, что эти наборы тоже равны, поскольку любая хеш-функция, работающая с произвольным количеством данных, может иметь коллизии.

### Области применения хеширования

Хеш-функции — незаменимый и повсеместно распространенный инструмент, используемый для выполнения целого ряда задач, в число которых можно отнести проверку целостности данных и безопасное хранение паролей в базах данных.

#### Проверка целостности данных

Для проверок целостности данных зачастую используются простые хеш-функции. Например, один пользователь передает другому определенный набор данных, а затем хеш от него. Получатель информации, захешировав полученную информацию у себя и сравнив хеши, может удостовериться, что он получил именно те данные, которые были отправлены.

Хеш-значение, используемое для проверки целостности данных при их передаче или хранении, называется **контрольной суммой**.

#### Работа с большими объемами информации

Хеш-функция может облегчить работу с большими объемами информации. Например, в текст, состоящий из нескольких миллионов различных строк нужно добавить еще одну, при условии, что там ее еще нет. Чтобы не заниматься посимвольным сравнением каждой строки, можно предварительно вычислить хеш каждой из них, и уже сделать сравнение по нему. Вся работа упрощается и ускоряется в разы.

#### Хранение паролей

Одна из областей применения хеширования — хранение паролей. В целях безопасности онлайн-сервисы не хранят пароли в явном виде, они хранят их хеш-значения. Когда мы пытаемся выполнить вход в свою учетную запись и вводим пароль, происходит сравнение хеш-значения введенного пароля и хеш-значения фактического пароля, хранящегося в базе данных онлайн-сервиса.

К примеру, если мы забудем пароль к какому-либо онлайн-сервису, скорее всего, придется воспользоваться функцией восстановления пароля. В этом случае мы, впрочем, не получим свой старый пароль, поскольку онлайн-сервис на самом деле сам его не знает. Он знает лишь его хеш-значение.

Если вы, воспользовавшись функцией восстановления, вдруг получили старый пароль в открытом виде, то можете быть уверены: используемый вами сервис не хеширует пользовательские пароли, что очень плохо.

### Встроенная функция hash()

Встроенная функция `hash()` используется для вычисления хеш-значения объекта. Она принимает один аргумент:

- `object` — объект, хеш-значение которого требуется вычислить

Функция возвращает **целое число**, представляющее хеш-значение переданного объекта.

Приведенный ниже код:

```python
print(hash(1))                          # хеш-значение целого числа
print(hash(2.5))                        # хеш-значение вещественного числа
print(hash('bee'))                      # хеш-значение строки
print(hash((1, 2, 3)))                  # хеш-значение кортежа
```

выводит (хеш-значения могут отличаться):

```no-highlight
1
1152921504606846978
7327928671037089808
529344067295497451
```

В Python хеш-значениями небольших целых чисел являются сами числа. Исключение представляет число `-1`, его хеш-значение равно `-2`.

Приведенный ниже код:

```python
print(hash(1))
print(hash(69))
print(hash(314))
print(hash(2077))
print(hash(-1))
```

выводит:

```no-highlight
1
69
314
2077
-2
```

Почитать о том, почему `hash(-1) == -2`, можно по [ссылке](https://stackoverflow.com/questions/10130454/why-do-1-and-2-both-hash-to-2-in-cpython) и [ссылке](https://omairmajid.com/posts/2021-07-16-why-is-hash-in-python/).

Для более сложных типов данных, например, `str`, встроенная функция `hash()` возвращает новое хеш-значение при каждом новом запуске программы.

Приведенный ниже код:

```python
print(hash('beegeek'))
print(hash('beegeek'))
print(hash('beegeek!'))
print(hash('beek'))
print(hash('geek'))
```

выводит (хеш-значения могут отличаться):

```no-highlight
3750473969066821398
3750473969066821398
-5101520736652926912
6279574873516782143
-8122464414691433199
```

Обратите внимание на то, что первые два значения всегда будут равны между собой, поскольку данный код работает в рамках одного запуска программы. Если программу перезапустить, значения будут совершенно другими.

Дело в том, что Python по умолчанию использует рандомизацию хешей для некоторых типов (например, `str`), чтобы сделать хеш-значения менее предсказуемыми. Это делает функцию `hash()` более безопасной и позволяет избежать возникновения [DoS-атаки](https://ru.wikipedia.org/wiki/DoS-%D0%B0%D1%82%D0%B0%D0%BA%D0%B0), которая может использовать уязвимость хеш-функций на веб-серверах. Злоумышленники могут использовать слабый алгоритм хеширования, чтобы преднамеренно создавать коллизии хешей, перегружая сервер и делая его недоступным.

Функция `hash()` может работать не только с числами и строками, но и с большинством встроенных типов данных.

Приведенный ниже код:

```python
print(hash(None))
print(hash(print))
print(hash(hash))
```

выводит (хеш-значения могут отличаться):

```no-highlight
-9223363241050908545
4611694664844004019
8646416648793
```

Встроенная функция `hash()` не работает с экземплярами встроенных изменяемых типов данных, таких как `list, set` и `dict`. Такие объекты являются **нехешируемыми**.

Приведенный ниже код:

```python
print(hash(['bee', 'geek']))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'list'
```

Встроенная функция `hash()` работает с экземплярами типа `tuple` только в том случае, если их элементами являются хешируемые объекты.

Приведенный ниже код:

```python
print(hash(('bee', 'geek', 1)))
```

выводит (хеш-значение может отличаться):

```no-highlight
8983813428229996918
```

В то время как приведенный ниже код:

```python
print(hash(('bee', 'geek', [1, 2, 3])))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'list'
```

Функция `hash()` также работает с экземплярами типа `frozenset`.

### Примечания

**Примечание 1.** Ни в коем случае нельзя сохранять хеш-значения, возвращаемые функцией `hash()`, в базу данных для дальнейшего использования. Во-первых, они могут быть различными при каждом новом запуске программы, во-вторых, алгоритм хеширования может поменяться в новых версиях Python.

**Примечание 2.** Переменная окружения — это переменная, значение которой присваивается извне. Как правило, ее устанавливают в командной строке перед тем, как обратиться к исполняемому файлу Python. После этого ОС позволяет программе Python получать доступ к такой переменной. ​​​​​Мы можем отключить рандомизацию для хешей, установив фиксированное начальное значение для переменной окружения `PYTHONHASHSEED`. Подробнее о переменной можно почитать по [ссылке](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED).

**Примечание 3.** На 64-х разрядном компьютере встроенная функция `hash()` возвращает целочисленное значение из диапазона `[-2305843009213693950; 2305843009213693950]`.

**Примечание 4.** В Python равные числовые значения имеют равные хеш-значения, независимо от их типа.

Приведенный ниже код:

```python
from decimal import Decimal
from fractions import Fraction

print(hash(17))
print(hash(17.0))
print(hash(Decimal(17)))
print(hash(complex(17, 0)))
print(hash(Fraction(17, 1)))
```

выводит:

```no-highlight
17
17
17
17
17
```

Подробнее почитать про хеширование чисел можно по [ссылке](https://docs.python.org/3/library/stdtypes.html#numeric-hash).

**Примечание 5.** Хеш-значение пустой строки равно нулю.

Приведенный ниже код:

```python
print(hash(''))
```

выводит:

```no-highlight
0
```

**Примечание 6.** Хеш-значение булевых констант `True` и `False` равны `1` и `0` соответственно.

Приведенный ниже код:

```python
print(hash(True))
print(hash(False))
```

выводит:

```no-highlight
1
0
```

**Примечание 7.** Алгоритм и различные настройки встроенной функции `hash()` можно получить с помощью модуля `sys`.

Приведенный ниже код:

```python
import sys

print(sys.hash_info)
```

выводит:

```no-highlight
sys.hash_info(width=64, modulus=2305843009213693951, inf=314159, nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, seed_bits=128, cutoff=0)
```

Подробнее по [ссылке](https://docs.python.org/3/library/sys.html#sys.hash_info).

### Сужение диапазона хеш-значений

Хеш-значения, возвращаемые встроенной функцией `hash()`, могут быть достаточно велики, так как они принадлежат диапазону `[-2305843009213693950; 2305843009213693950]`. Для сужения данного диапазона и уменьшения величины хеш-значений часто используется оператор деления с остатком (`%`).

Например, если нам необходимо сузить диапазон хеш-значений до `100` чисел, то каждое вычисленное хеш-значение мы можем поделить с остатком на `100`.

Приведенный ниже код:

```python
def hash_function(obj):
    return hash(obj) % 100

data = [2077, 3.14, 'bee', 'geek', (1, 2, 3)]

for obj in data:
    print(hash_function(obj))
```

выводит (хеш-значения могут отличаться):

```no-highlight
77
43
29
67
51
```

Здесь функция `hash_function()` вычисляет хеш-значение объекта с помощью встроенной функции `hash()` и делит его с остатком на `100`. Таким образом, функция `hash_function()` гарантирует, что результатом ее выполнения всегда является целое число из диапазона `[0; 100)`.

Результатом деления с остатком отрицательного числа на положительное число является **неотрицательное число**.

### Характеристики хорошей хеш-функции

При знакомстве с хеш-функциями мы упомянули, что они обладают или могут обладать рядом свойств. Например, любая хеш-функция является детерминированной, а хорошая хеш-функция также подвержена лавинообразному эффекту. Дополнительно к характеристикам хорошей хеш-функции можно отнести следующее:

- равномерное распределение хеш-значений
- минимальное количество коллизий
- быстрое вычисление хеш-значений

Встроенная функция `hash()` по праву является примером хорошей хеш-функции, так как она обладает всеми упомянутыми характеристиками. Во-первых, она подвержена лавинообразному эффекту.

Приведенный ниже код:

```python
print(hash('beegeek'))
print(hash('Beegeek'))                  # заменяем лишь первый символ строки
```

выводит (хеш-значения могут отличаться):

```no-highlight
8630382989964334220
5789365726824330891
```

Во-вторых, она выполняется быстро даже на очень больших входных данных. На современном компьютере вызов функции `hash()` со строкой из `100` миллионов символов выполняется практически мгновенно.

 Приведенный ниже код:

```python
from time import perf_counter

start = perf_counter()

hash('b' * 100_000_000)

end = perf_counter()
print(end - start)                      # результат в секундах
```

выводит (результат может отличаться):

```no-highlight
0.041030700027476996
```

В-третьих, встроенная функция `hash()` достаточно равномерно распределяет хеш-значения. Посмотрим на распределение ею хеш-значений печатных символов ASCII. Для наглядности сузим диапазон генерируемых хеш-значений до `[0; 20)`.

Приведенный ниже код:

```python
from collections import defaultdict
from string import printable

hashes = defaultdict(int)

for char in printable:
    hashes[hash(char) % 20] += 1

for hash_value, hash_count in sorted(hashes.items()):
    print(hash_value, '■' * hash_count)
```

выводит:

```no-highlight
0 ■■
1 ■■■■■■
2 ■■■■■■■■
3 ■■■
4 ■■■
5 ■■■■■■■
6 ■■■■
7 ■■■■■■■■
8 ■■■■■■
9 ■■■■■■■
10 ■■
11 ■■■■■■■
12 ■■■■■
13 ■■■■
14 ■■■
15 ■■■■■■
16 ■■■■
17 ■■■■■
18 ■■■■
19 ■■■■■■
```

Подводя итог, хорошая хеш-функция должна обладать как минимум следующими четырьмя свойствами:

1. **Лавинообразный эффект.** Небольшое изменение входных данных должно существенно изменять хеш-значение
2. **Быстрое вычисление.** Поскольку хеш-функции используются при построении хеш-таблиц, а они используются для быстрого поиска данных, то сама хеш-функция должна работать очень быстро
3. **Минимальное количество коллизий.** Хеш-функция не должна возвращать много одинаковых значений для разных входных данных
4. **Равномерное распределение хешей.** Хеш-функция должна равномерно распределять хеш-значения при большом количестве входных данных, тем самым минимизируя количество коллизий и эффективно используя весь доступный диапазон чисел

### Создание собственной хеш-функции

Создание хорошей хеш-функции задача не из простых. Однако попытка создать хеш-функцию с нуля — отличный способ узнать, как работает хеширование.

**1 версия хеш-функции.** Хеш-функция перебирает все символы переданной строки и для каждого символа вычисляет его номер в таблице Unicode с помощью функции `ord()`, а затем вычисляет сумму всех полученных номеров:

```python
def hash_function(obj):
    return sum(ord(character) for character in obj)
```

Приведенный ниже код:

```python
print(hash_function('Python'))
```

выводит:

```no-highlight
642
```

Такая реализации хеш-функции содержит серьезную проблему, она работает только со строковым аргументом.

**2 версия хеш-функции.** Хеш-функция сначала преобразует переданный объект в строку с помощью функции `str()`, а затем выполняет указанное выше преобразование:

```python
def hash_function(obj):
    return sum(ord(character) for character in str(obj))
```

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function(123))
print(hash_function(12.34))
print(hash_function(None))
print(hash_function(True))
```

выводит:

```no-highlight
642
150
248
400
416
```

Теперь хеш-функция работает с объектом любого типа. Однако новая версия хеш-функции все еще содержит проблемы. Очевидно, что небольшое изменение начальных данных мало влияет на итоговое хеш-значение. В этом несложно убедиться, если поменять последний символ переданной строки.

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('Pythoo'))
print(hash_function('Pythop'))
```

выводит:

```no-highlight
642
643
644
```

Также функция нечувствительна к порядку символов во входных данных, а это значит, что анаграммы одного и того же слова, такие как `Python` и `yPthon`, приводят к возникновению коллизий.

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('yPthon'))
print(hash_function('thonPy'))
```

выводит:

```no-highlight
642
642
642
```

Чтобы решить указанные проблемы, можно использовать не только порядковый номер символа в таблице Unicode, но и его позицию (индекс) в начальных данных.

**3 версия хеш-функции.** Здесь мы берем сумму произведений, полученных путем умножения порядковых значений символов и их соответствующих индексов. Обратите внимание, что мы нумеруем индексы с единицы, а не с нуля, в противном случае первый символ всегда будет отбрасываться, так как его значение будет умножаться на ноль:

```python
def hash_function(obj):
    return sum(index * ord(character) for index, character in enumerate(str(obj), start=1))
```

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('yPthon'))
print(hash_function('thonPy'))
```

выводит:

```no-highlight
2301
2260
2223
```

Теперь наша хеш-функция довольно универсальна и не приводит к возникновению большого количества коллизий. Можно заметить, что чем больше входные данные, тем больше будет хеш-значение.

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('Beegeek'*1000))
print(hash_function('Stepik'*10000000))
```

выводит:

```no-highlight
2301
2380463000
187200003610000000
```

Мы всегда можем справиться с неограниченным ростом с помощью оператора `%`:

```python
def hash_function(obj):
    return sum(index * ord(character) for index, character in enumerate(str(obj), start=1)) % 123456761
```

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('Beegeek'*1000))
print(hash_function('Stepik'*10000000))
```

выводит:

```no-highlight
2301
34784541
116170254
```

Использование оператора `%` позволяет загнать вычисляемое хеш-значение в нужный диапазон. В нашем случае получаем, что хеш-значения будут в диапазоне `[0; 123456761)`. Однако нужно помнить, что выбор меньшего пула хеш-значений увеличивает вероятность возникновения коллизий. В качестве максимального количества хеш-значения рекомендуется использовать большую константу (желательно простое число).

Из существенных минусов нашей хеш-функции остается медленная скорость работы при больших входных данных. Подумайте над тем, как можно ее оптимизировать.

### Примечания

**Примечание 1.** Встроенная функция `hash()` не является [криптостойкой](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F). Криптостойкие хеш-функции доступны в модуле [hashlib](https://docs.python.org/3/library/hashlib.html).

**Примечание 2.** Онлайн-сервис по вычислению хеш-значений доступен по [ссылке](https://emn178.github.io/online-tools/index.html).

## 5.10 Хеширование объектов. Часть 2
### Тема урока: хеширование объектов

1. Хешируемость и неизменяемость
2. Хеширование пользовательских классов
3. Магический метод `__hash__()`
4. Hash-Equal контракт

**Аннотация.** Урок посвящен хешированию объектов.

### Хешируемость и неизменяемость

Как мы знаем, встроенные типы `list, set, dict` являются изменяемыми и нехешируемыми.

Приведенный ниже код:

```python
nums = {1, 2, 3}

print(hash(nums))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'set'
```

В отличие от обычного множества (тип `set`), неизменяемое множество (тип `frozenset`) является хешируемым.

Приведенный ниже код:

```python
nums = frozenset({1, 2, 3})

print(hash(nums))
```

выводит (число может отличаться):

```no-highlight
-272375401224217160
```

Хешируемость объектов играет важную роль в Python. В частности, от того, является ли объект хешируемым, зависит возможность его использования в качестве ключа в словаре, а также его возможность быть элементом множества.

Приведенный ниже код:

```python
nums = {1, 2, 3}

obj = {nums: 'numbers'}

print(obj)
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'set'
```

В то время как код:

```python
nums = frozenset({1, 2, 3})

obj = {nums: 'numbers'}

print(obj)
```

выводит:

```no-highlight
{frozenset({1, 2, 3}): 'numbers'}
```

В словарях хешируемыми должны быть только ключи, при этом значения по соответствующим ключам могут иметь произвольный тип.

Хешируемость объектов тесно связана с их изменяемостью, то есть со способностью изменять свое внутреннее состояние в течение жизни. Все встроенные изменяемые коллекции в Python не являются хешируемыми. Это не значит, что мы не можем создать хешируемый и изменяемый тип одновременно, однако на практике так не поступают. Если тип является хешируемым, то он должен быть неизменяемым, иначе могут возникнуть проблемы.

### Хеширование пользовательских классов

По умолчанию в пользовательских классах сравнение на равенство является сравнением на идентичность. Другими словами, если в классе не определено, как будет происходить сравнение с помощью оператора `==`, оно будет равносильно сравнению с помощью оператора `is`.

Идентичность объекта определяется с помощью функции `id()`. Другими словами, объекты идентичны, если они имеют одинаковый идентификатор во время выполнения программы.

Для последующих примеров рассмотрим класс `Point`, описывающий точку на плоскости.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self._x = x                          # координата точки по оси x
        self._y = y                          # координата точки по оси y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 is p1)
print(p1 == p1)

print(p1 is p2)
print(p1 == p2)
```

выводит:

```no-highlight
True
True
False
False
```

По умолчанию все пользовательские классы **являются хешируемыми** и имеют реализованный магический метод `__hash__()`, который и вызывает встроенная функция `hash()`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1))
print(hash(p2))
```

выводит (числа могут отличаться):

```no-highlight
117433932722
117433932728
```

Поскольку у равных объектов должны быть равны и хеш-значения, то магический метод `__hash__()` по умолчанию использует идентификатор объекта. А именно, базовая реализация метода `__hash__()` возвращает значение `id(obj) // 16`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1), id(p1) // 16)
print(hash(p2), id(p2) // 16)
```

выводит (числа могут отличаться):

```no-highlight
150672559026 150672559026
150672559032 150672559032
```

По умолчанию в пользовательских классах методы `__eq__()` и `__hash__()` реализованы таким образом, что экземпляры этих классов равны только сами себе и не равны никаким другим объектам, а сравнения на равенство (`x == y`), идентичность (`x is y`) и сравнение хеш-значений (`hash(x) == hash(y)`) являются эквивалентными операциями.

### Магический метод __hash__()

Если пользовательский класс переопределяет магический метод `__eq__()`, то он дополнительно должен переопределить магический метод `__hash__()` таким образом, чтобы равные объекты имели равные хеш-значения.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented

    def __hash__(self):
        return hash((self.x, self.y))


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p2)
print(hash(p1) == hash(p2))
```

выводит:

```no-highlight
True
True
```

В нашем случае две точки равны в том случае, если равны их соответствующие координаты `x` и `y`. Хеш-значение точки вычисляется на основе кортежа, содержащего обе его координаты, поэтому равные точки будут иметь одинаковые хеш-значения.

Вычисление хеш-значения объекта на основе значений всех его атрибутов является распространенной практикой.

Как было сказано выше, хешируемость тесно связана с изменяемостью. Приведем ряд правил, которым нужно следовать при создании хешируемого пользовательского класса:

1. Если пользовательский класс не переопределяет метод `__eq__()`, то он не должен переопределять метод `__hash__()`
2. Если изменяемый пользовательский класс переопределяет метод `__eq__()`, то он не должен переопределять метод `__hash__()`
3. Если неизменяемый пользовательский класс переопределяет метод `__eq__()`, то переопределение метода `__hash__()` остается на выбор. Однако если он переопределяет метод `__hash__()`, то он должен быть реализован таким образом, чтобы равные экземпляры имели одинаковые хеш-значения

Отдельного рассмотрения требует ситуация, когда класс переопределяет метод `__eq__()`, но не переопределяет метод `__hash__()`. В таком случае метод `__hash__()` будет иметь значение `None`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented


p = Point(1, 2)

print(Point.__hash__)
```

выводит:

```no-highlight
None
```

Если метод `__hash__()` в классе имеет значение `None`, то при попытке вычислить хеш-значение экземпляра такого класса будет возбуждено исключение `TypeError`.

 Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented


p = Point(1, 2)

print(hash(p))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'Point'
```

Если пользовательский класс не имеет согласованных рабочих методов `__hash__()` и `__eq__()`, то его экземпляры не могут быть ключами в словарях и элементами в множествах.

Мы также можем явно заменить метод `__hash__()` значением `None`, чтобы сделать класс нехешируемым.

Приведенный ниже код:

```python
class Point:
    __hash__ = None
    
    def __init__(self, x, y):
        self.x = x
        self.y = y


p = Point(1, 2)

print(hash(p))
```

 приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'Point'
```

### Hash-Equal контракт

Методы `__eq__()` и `__hash__()` тесно связаны друг с другом, и при реализации одного метода, нужно думать над реализацией другого. Так, если два объекта являются равными, то должны быть равны и их хеш-значения. Если два объекта имеют различные хеш-значения, то и сами объекты должны быть различны.

### Примечания

**Примечание 1.** Функция `hash()` обрезает значение, возвращаемое методом `__hash__()`, до определенного размера. На 64-х разрядном компьютере встроенная функция `hash()` возвращает целочисленное значение из диапазона `[-2305843009213693950; 2305843009213693950]`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented

    def __hash__(self):
        return 123456789012345678901234567890


p = Point(1, 2)

print(hash(p))
```

выводит:

```no-highlight
248789772095949448
```

Очевидно, что напечатанное значение равняется `123456789012345678901234567890 % 2305843009213693951` 🤓.

**Примечание 2.** В ситуациях, когда сравнение экземпляров класса и вычисление их хеш-значений происходит на основе атрибутов, удобно определить свойство, возвращающее кортеж с этими атрибутами.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __eq__(self, other):
        if isinstance(other, Point):
            return self._fields == other._fields
        return NotImplemented

    def __hash__(self):
        return hash(self._fields)
    
    @property
    def _fields(self):
        return self.x, self.y, self.z


p1 = Point(1, 2, 3)
p2 = Point(1, 2, 3)
p3 = Point(4, 5, 6)

print(p1 == p2)
print(p1 == p3)
print(hash(p1) == hash(p2))
print(hash(p1) == hash(p3))
```

выводит:

```no-highlight
True
False
True
False
```

**Примечание 3.** Подробнее о методе `__hash__()` можно почитать в официальной документации по [ссылке](https://docs.python.org/3/reference/datamodel.html#object.__hash__%C2%A0).

## 5.11 Особенности работы словарей и множеств
### Тема урока: особенности работы словарей и множеств

1. Особенности работы словарей и множеств
2. Производительность и потребляемая память
3. Изменяемые ключи
4. Подводные камни и обратная сторона реализации

**Аннотация.** Урок посвящен особенностям работы словарей и множеств.

### Особенности работы словарей

Чтобы объект мог быть ключом словаря, он должен быть хешируемым. Согласно [документации](https://docs.python.org/3/glossary.html#term-hashable), объект является хешируемым, если у него есть хеш-значение, которое никогда не меняется в течение всей его жизни (для этого нужен метод `__hash__()`), и если его можно сравнивать с другими объектами (для этого нужен метод `__eq__()`). Равные объекты должны иметь равные хеш-значения.

Такие требования к объекту возникают из-за внутреннего устройства самих словарей. Мы не будем говорить о том, как в точности они работают в актуальной версии языка, мы покажем лишь их идейную интерпретацию, которой достаточно, чтобы понять любое поведение, связанное со словарями.

Словарь можно представить в виде списка, элементами которого являются другие списки. Сам список для удобства будем называть **таблицей**, его элементы — **корзинами**:

```python
[[], [], [], [], ...]
```

Элементы словаря или **пары ключ-значение** хранятся в корзинах и представляют собой кортежи из двух элементов:

```python
(ключ, значение)
```

Таблица всегда имеет длину, то есть определенное количество корзин. Будем считать, что по умолчанию пустая таблица имеет `10` корзин:

```python
[[], [], [], [], [], [], [], [], [], []]
```

Рассмотрим одну пустую таблицу и покажем, как в ней происходят операции добавления пары и поиска пары по ключу.

**Добавление пары.** Чтобы добавить пару в таблицу, нужно вычислить хеш-значение ее ключа, а затем полученный результат поделить с остатком на длину таблицы, в нашем случае на `10`. Результатом будет число в диапазоне `[0; 10)`, которое представляет индекс корзины, в которую необходимо поместить данную пару.

Например, нам нужно добавить пару `('one', 1)` в таблицу. Мы вычисляем хеш-значение ключа этой пары, делим его с остатком на `10` и получаем в результате число `5`. `5` — это индекс корзины, в которую нужно поместить пару `('one', 1)`. После добавления данной пары в таблицу она примет вид:

```python
[[], [], [], [], [], [('one', 1)], [], [], [], []]
```

При вычислении хеш-значений строковых объектов Python использует рандомизацию, поэтому при перезапуске программы результаты могут отличаться.

Дополнительно добавим в таблицу пару `('two', 2)`. Выполняем аналогичные вычисления и получаем индекс корзины, в которую нужно поместить данную пару. Он равен `1`. После добавления пары `('two', 2)` таблица примет вид:

```python
[[], [('two', 2)], [], [], [], [('one', 1)], [], [], [], []]
```

При добавлении очередной пары в таблицу, она может попасть как в пустую корзину, так и в занятую. Случай попадания в пустую корзину рассмотрен выше. Случай попадания в занятую корзину может значить то, что мы пытаемся добавить пару с уже имеющимся ключом. Если это так, мы обновляем значение пары по этому ключу, если нет — помещаем пару в конец корзины.

Например, нам нужно добавить пару `('three', 3)` в таблицу. Мы вычисляем хеш-значение ключа этой пары, делим его с остатком на `10` и получаем в результате число `5`. Корзина с индексом `5` уже содержит одну пару, поэтому сперва мы сравниваем их ключи, и так как они не равны, помещаем пару `('three', 3)` в конец корзины. После добавления данной пары в таблицу она примет вид:

```python
[[], [('two', 2)], [], [], [], [('one', 1), ('three', 3)], [], [], [], []]
```

Например, нам нужно добавить пару `('three', 'три')` в таблицу. Мы вычисляем хеш-значение ключа этой пары, делим его с остатком на `10` и получаем в результате число `5`. Корзина с индексом `5` содержит две пары `('one', 1)` и `('three', 3)`. Мы сравниваем наш ключ с ключом первой пары, и так как они не совпадают, переходим ко второй. Снова выполняем сравнение ключей, и так как они совпадают, обновляем значение этой пары с `3` на `три`. После добавления пары `('three', 'три')` в таблицу она примет вид:

```python
[[], [('two', 2)], [], [], [], [('one', 1), ('three', 'три')], [], [], [], []]
```

**Поиск пары по ключу.** Поиск пары по ключу происходит ровно по тому же алгоритму, что и ее добавление. Нам нужно вычислить хеш-значение ключа, поделить его с остатком на длину таблицы и попасть в нужную корзину. Затем в этой корзине путем сравнения ключей на равенство найти искомую пару.

Например, нам нужно найти в таблице пару по ключу `two`. Мы вычисляем хеш-значение этого ключа, делим его с остатком на `10` и получаем в результате число `1`. `1` — это индекс корзины, в которой мы должны искать пару, имеющую в качестве ключа значение `two`. В нашей таблице в этой корзине содержится лишь одна пара — `('two', 2)`. Мы сравниваем наш ключ и ключ этой пары, и так как они совпадают, данная пара является искомой.

Например, нам нужно найти в таблице пару по ключу `three`. Мы вычисляем хеш-значение этого ключа, делим его с остатком на `10` и получаем в результате число `5`. `5` — это индекс корзины, в которой мы должны искать пару, имеющую в качестве ключа значение `three`. В нашей таблице в этой корзине содержатся две пары `('one', 1)` и `('three', 'три')`. Мы сравниваем наш ключ с ключом первой пары, и так как они не совпадают, переходим ко второй. Снова выполняем сравнение ключей, и так как они совпадают, пара `('three', 'три')` является искомой.

Чтобы поиск в таблице происходил быстро, количество корзин в ней нужно увеличивать по мере их заполнения.

Теперь проверим, как все вышесказанное работает непосредственно в Python. Для этого определим класс `Key`, описывающий ключ, в методах `__hash__()` и `__eq__()` которого дополнительно добавим вывод текста, чтобы отслеживать вызов этих методов.

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        print('Вызов метода __hash__()', self.data)
        return hash(self.data)
    
    def __eq__(self, other):
        print('Вызов метода __eq__()')
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

data[Key('one')] = 1
data[Key('two')] = 2
data[Key('three')] = 3

print()                                                 # пустая строка для удобства восприятия
print(data)
```

выводит:

```no-highlight
Вызов метода __hash__() one
Вызов метода __hash__() two
Вызов метода __hash__() three

{Key('one'): 1, Key('two'): 2, Key('three'): 3}
```

В Python поиск пары по ключу в словарях происходит очень быстро, так как пары практически никогда не попадают в одну корзину. Достигается это благодаря равномерному распределению хеш-значений функцией `hash()`, а также большому количеству пустых корзин. Если количество пустых корзин уменьшается, Python перестраивает словарь, вновь увеличивая их количество.

Однако мы без проблем можем смоделировать ситуацию, когда ключи попадают в одну корзину, если зафиксируем их хеш-значения. Для этого обновим метод `__hash__()` в классе `Key`, чтобы он всегда возвращал единицу.

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        print('Вызов метода __hash__()', self.data)
        return 1
    
    def __eq__(self, other):
        print('Вызов метода __eq__()', self.data, other.data)
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

data[Key('one')] = 1
data[Key('two')] = 2

print()
print(data)
```

выводит:

```no-highlight
Вызов метода __hash__() one
Вызов метода __hash__() two
Вызов метода __eq__() one two

{Key('one'): 1, Key('two'): 2}
```

Здесь происходит вычисление хеш-значения `Key('one')` для определения корзины, в которую попадет пара с данным ключом. Затем то же самое выполняется для `Key('two')`. Так как хеш-значения `Key('one')` и `Key('two')` равны, они гарантированно попадают в одну и ту же корзину, поэтому после происходит их сравнение для определения того, не происходит ли добавление пары с уже имеющимся ключом. И так как ключи не равны, добавляемая пара попадает в конец корзины.

Теперь выполним добавление пары с уже имеющимся ключом и посмотрим на то, как будут вызываться методы `__hash__()` и `__eq__()`.

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        print('Вызов метода __hash__()', self.data)
        return 1
    
    def __eq__(self, other):
        print('Вызов метода __eq__()', self.data, other.data)
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

data[Key('one')] = 1
data[Key('two')] = 2

print()
data[Key('two')] = 'два'

print()
print(data)
```

выводит:

```no-highlight
Вызов метода __hash__() one
Вызов метода __hash__() two
Вызов метода __eq__() one two

Вызов метода __hash__() two
Вызов метода __eq__() one two
Вызов метода __eq__() two two

{Key('one'): 1, Key('two'): 'два'}
```

Добавление пар `(Key('one'), 1)` и `(Key('two'), 2)` происходит так же, как и в примере выше. После следует добавление пары `(Key('two'), 'два')`, которая попадает в корзину с двумя добавленными ранее парами. Затем происходит сравнение ключа добавляемой пары с ключом первой пары в корзине. Так как они не равны, сравнение переходит ко второй паре в корзине. Добавляемый ключ совпадает с ключом второй пары в корзине, поэтому значение пары `(Key('two'), 2)` меняется с `2` на `два`.

Аналогичное поведение наблюдается и при поиске пары по ключу: вычисление хеш-значения ключа и его поиск в соответствующей корзине.

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        print('Вызов метода __hash__()', self.data)
        return 1
    
    def __eq__(self, other):
        print('Вызов метода __eq__()', self.data, other.data)
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

data[Key('one')] = 1
data[Key('two')] = 2

print()
data[Key('two')]
```

выводит:

```no-highlight
Вызов метода __hash__() one
Вызов метода __hash__() two
Вызов метода __eq__() one two

Вызов метода __hash__() two
Вызов метода __eq__() one two
Вызов метода __eq__() two two
```

#### Быстрое сравнение ключей

В операциях добавления пары и поиска пары по ключу Python так или иначе выполняет сравнение ключей. Чтобы эта операция выполнялась как можно быстрее, прямое сравнение ключей на равенство выполняется не сразу. Сперва происходит сравнение ключей на идентичность, затем на неравенство их хеш-значений и только после сравнение на равенство.

В виде функции такое последовательное сравнение ключей имеет вид:

```python
def fast_match(key, target_key):                        # key и target_key — сравниваемые ключи
    if key is target_key:
        return True                                     # ключи равны, если это один и тот же объект                 
    if hash(key) != hash(target_key):
        return False                                    # ключи не равны, если не равны их хеш-значения
    return key == target_key
```

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        print('Вызов метода __hash__()', self.data)
        return 1
    
    def __eq__(self, other):
        print('Вызов метода __eq__()', self.data, other.data)
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

key = Key('one')

data[key] = 1
data[key] = 'один'

print()
print(data)
```

выводит:

```no-highlight
Вызов метода __hash__() one
Вызов метода __hash__() one

{Key('one'): 'один'}
```

Здесь при добавлении пары с уже имеющимся ключом метод `__eq__()` не вызывается, так как ключи этих пар представлены одним и тем же объектом.

#### Примечания

**Примечание 1.** Словари в Python нередко модифицируются. Они становятся быстрее и эффективнее работают с памятью, однако основная идея их внутреннего устройства — хеширование — остается неизменной. Видео с подробным рассказом о внутреннем устройстве словарей и их эволюции от Реймонда Хеттингера, разработчика ядра Python, доступно по [ссылке](https://www.youtube.com/watch?v=37S53yFg9wc&t=15s&ab_channel=IgorStarikov). Слайды, используемые в выступлении, доступны по [ссылке](https://stepik.org/media/attachments/lesson/903604/Pycon2017CompactDictTalk.pdf). Видео переведено и озвучено на русский язык, поэтому настоятельно рекомендуется к просмотру.

**Примечание 2.** Устройство множеств (типы `set` и `frozenset`) практически повторяет устройство словарей. Отличие лишь в том, что в множествах хранятся не пары, а сами элементы (как если бы это был ключ словаря, но без сопровождающего его значения).

**Примечание 3.** Структура данных, в виде которой реализованы типы данных `dict` и `set` , называется **хеш-таблицей**. Ознакомиться ближе с этой структурой данных можно в отрывке из книги "Грокаем алгоритмы", доступной по [ссылке](https://stepik.org/media/attachments/lesson/886253/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B.pdf). Подробнее о хеш-таблицах мы будем говорить в одном из наших следующих [курсов](https://stepik.org/media/attachments/lesson/886253/%D0%BC%D0%B5%D0%BC%D0%B0%D1%81%D0%B8%D0%BA.jpg).

**Примечание 4.** Исходный код типов `dict` и `set` доступен по [ссылке](https://github.com/python/cpython/blob/main/Objects/dictobject.c) и [ссылке](https://github.com/python/cpython/blob/main/Objects/setobject.c).

**Примечание 5.** Объект `dict`, построенный как `dict([(key1, value1), (key2, value2)])`, равен объекту `dict([(key2, value2), (key1, value1)])`, но порядок ключей в них может отличаться, если при хешировании `key1` и `key2` возникает коллизия.

Приведенный ниже код:

```python
DIAL_CODES = [(86, 'China'),
              (91, 'India'),
              (1, 'United States'),
              (62, 'Indonesia'),
              (55, 'Brazil'),
              (92, 'Pakistan'),
              (880, 'Bangladesh'),
              (234, 'Nigeria'),
              (7, 'Russia'),
              (81, 'Japan')]

d1 = dict(DIAL_CODES)
print('d1:', d1.keys())

d2 = dict(sorted(DIAL_CODES))
print('d2:', d2.keys())

d3 = dict(sorted(DIAL_CODES, key=lambda x:x[1]))
print('d3:', d3.keys())
```

выводит (порядок ключей может отличаться):

```no-highlight
d1: dict_keys([86, 91, 1, 62, 55, 92, 880, 234, 7, 81])
d2: dict_keys([1, 7, 55, 62, 81, 86, 91, 92, 234, 880])
d3: dict_keys([880, 55, 86, 91, 62, 81, 234, 92, 7, 1])
```

Как мы видим, все получающиеся словари равны, потому что содержат одни и те же пары `key: value`, однако порядок ключей в них разный:

- `d1` построен из кортежей, представленных в исходном порядке
- `d2` построен из кортежей, отсортированных по телефонному коду
- `d3` построен из кортежей, отсортированных по названию страны

**Примечание 6.** Когда в словарь добавляется новый элемент, Python может решить, что словарь следует перестроить. Все это зависит от реализации, поэтому уверенно предсказать, когда такое случится, невозможно. Если при обходе всех ключей словаря мы будем одновременно изменять их, то может оказаться, что будут просмотрены не все элементы – даже не все из тех, что уже присутствовали в словаре перед добавлением новых. Именно поэтому **модификация содержимого словаря в процессе обхода – неудачная мысль**. Если необходимо просмотреть и добавить элементы в словарь, сделайте это в два этапа: прочитайте словарь от начала до конца, а все необходимые изменения соберите во втором словаре. Затем обновите первый словарь с помощью второго.

#### Поиск в словарях, множествах и списках

Благодаря грамотной реализации словарей и множеств в виде структур, построенных на хешировании, поиск в них происходит достаточно быстро. В этом степе мы покажем, насколько быстро выполняется данная операция в словарях и множествах, а для наглядности дополнительно покажем скорость поиска в списках.

При поиске объекта в списке необходимо перебирать список поэлементно, и если искомый объект находится в самом конце, то список придется перебрать полностью.

В качестве тестовых данных возьмем словарь, множество и список, элементами которых являются различные целые числа. С помощью оператора `in` будем выполнять поиск каждого числа, находящегося в коллекции.

**1 этап.** Рассмотрим коллекции из `10000` элементов.

Приведенный ниже код:

```python
from time import perf_counter

def search_time_test(collection, numbers):
    start = perf_counter()
    
    for num in numbers:
        num in collection
    
    end = perf_counter()
    return end - start

numbers = range(10000)

d = dict(zip(numbers, numbers))
s = set(numbers)
l = list(numbers)

print(search_time_test(d, numbers))                # результат в секундах
print(search_time_test(s, numbers))                # результат в секундах
print(search_time_test(l, numbers))                # результат в секундах
```

выводит (время может отличаться):

```no-highlight
0.00030620000325143337
0.00024690001737326384
0.20942239998839796
```

Здесь все коллекции на поиск `10000` элементов затратили менее секунды, однако словарь и множество сделали это не просто быстро, а очень быстро.

**2 этап.** Рассмотрим коллекции из `100000` элементов.

Приведенный ниже код:

```python
from time import perf_counter

def search_time_test(collection, numbers):
    start = perf_counter()
    
    for num in numbers:
        num in collection
    
    end = perf_counter()
    return end - start

numbers = range(100000)

d = dict(zip(numbers, numbers))
s = set(numbers)
l = list(numbers)

print(search_time_test(d, numbers))
print(search_time_test(s, numbers))
print(search_time_test(l, numbers))
```

выводит (время может отличаться):

```no-highlight
0.00274089997401461
0.0027747999993152916
20.910516000003554
```

Увеличив количество элементов в коллекциях в `10` раз, время поиска в списке выросло в `100` раз, в то время как словарь и множество хоть и выполнили поиск медленнее, чем в предыдущем этапе, по-прежнему затратили на все операции менее секунды.

**3 этап.** Рассмотрим коллекции из `1000000` элементов.

Приведенный ниже код:

```python
from time import perf_counter

def search_time_test(collection, numbers):
    start = perf_counter()
    
    for num in numbers:
        num in collection
    
    end = perf_counter()
    return end - start

numbers = range(1000000)

d = dict(zip(numbers, numbers))
s = set(numbers)
l = list(numbers)

print(search_time_test(d, numbers))
print(search_time_test(s, numbers))
print(search_time_test(l, numbers))
```

выводит (время может отличаться):

```no-highlight
0.025614199985284358
0.02500779996626079
2152.579886399966
```

Увеличение количества элементов в `100` раз привело к тому, что для поиска всех элементов списку потребовалось целых полчаса, в то время как словарю и множеству — менее секунды.

### Потребляемая память

Реализация `dict` – пример компромисса, когда жертвуют памятью ради скорости: накладные расходы словаря в части памяти велики, зато доступ производится быстро независимо от размера словаря. При обработке большого количества записей лучше хранить их в списке кортежей, а не в списке словарей. Замена словарей кортежами значительно снижает потребление памяти.

Приведенный ниже код:

```python
from pympler import asizeof

tuples = [('Python', 1991) for _ in range(1000000)]
dicts = [{'Python': 1991} for _ in range(1000000)]

tuples_size = asizeof.asizeof(tuples)
dicts_size = asizeof.asizeof(dicts)

print('Размер списка с кортежами', tuples_size, 'байт')
print('Размер списка с словарями', dicts_size, 'байт')
```

выводит:

```no-highlight
Размер списка с кортежами 8448872 байт
Размер списка с словарями 240448816 байт
```

В примере выше список, содержащий словари, занимает примерно в `30` раз больше памяти, чем список, содержащий кортежи.

### Изменяемые ключи

При работе со словарями и множествами важно, чтобы ключи были неизменяемыми объектами. В противном случае мы можем попасть в ситуацию, когда не сможем найти соответствующее значение для изменившегося ключа.

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        return hash(self.data)
    
    def __eq__(self, other):
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

key = Key('one')
  
data[key] = 1                # добавляем в словарь
key.data = 'один'            # изменяем ключ

print(key in data)           # ищем в словаре
```

выводит:

```no-highlight
False
```

### Подводные камни и обратная сторона реализации

Иногда при работе со словарями можно наткнуться на неочевидное поведение, связанное с их внутренней реализацией.

Приведенный ниже код:

```python
data = {}

data[True] = 'yes'
data[1] = 'no'
data[1.0] = 'maybe'

print(data)
```

выводит:

```no-highlight
{True: 'maybe'}
```

вместо ожидаемого:

```no-highlight
{True: 'yes', 1: 'no', 1.0: 'maybe'}
```

Причина такого поведения связана с тем, что Python считает объекты `True, 1` и `1.0` равными, более того, их хеш-значения также равны.

Приведенный ниже код:

```python
print(True == 1 == 1.0)
print(hash(True) == hash(1) == hash(1.0))
```

 выводит:

```no-highlight
True
True
```

Когда в словарь добавляются значения по ключам `1` и `1.0`, Python просто перезаписывает значение по ключу `True`. Это своего рода оптимизация, ведь если ключи считаются равными, то зачем тратить время на их обновление.

Аналогичное поведение ожидает нас и при работе с множествами.

Приведенный ниже код:

```python
data = set()

data.add(True)
data.add(1)
data.add(1.0)

print(data)
```

выводит:

```no-highlight
{True}
```

### Примечания

**Примечание 1.** Нужно помнить, что класс `bool` является наследником класса `int`, а значит, значения `False` и `True` ведут себя как значения `0` и `1` почти во всех контекстах, за исключением, быть может, преобразования в строку.

# 6. Протоколы
## 6.1 Протокол итерируемых объектов и итераторов
### Тема урока: протокол итерируемых объектов и итераторов

1. Итерируемые объекты и итераторы
2. Протокол итерируемых объектов, магический метод `__iter__()`
3. Протокол итераторов, магический метод `__next__()`

**Аннотация.** Урок посвящен протоколу итерируемых объектов и итераторов.

### Итерируемые объекты и итераторы

В языке Python под **итерируемым объектом** подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К примеру, уже известные нам списки (тип `list`), строки (тип `str`), кортежи (тип `tuple`), множества (тип `set`) и словари (тип `dict`) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Если подходить более формально, в Python существуют два типа итерируемых объектов:

1. итераторы
2. коллекции и последовательности

**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор так же сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возбуждению исключения `StopIteration`.

**Коллекция** — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

Также среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции называются **последовательностями**. Например, списки, строки и кортежи являются последовательностями, а множества и словари нет.

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию `iter()`, передав ей нужную коллекцию в качестве аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.

Подробнее об итераторах и коллекциях можно почитать в рамках курса для профессионалов по [ссылке](https://stepik.org/lesson/668458/step/1?unit=666568).

### Протокол итерируемых объектов и итераторов

**У всех итерируемых объектов** есть магический метод `__iter__()`, который преобразует итерируемый объект в итератор. Встроенная функция `iter()` вызывает за кулисами именно этот магический метод.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)                    # равнозначно words.__iter__()

print(type(words))
print(type(iterator))
```

выводит:

```no-highlight
<class 'list'>
<class 'list_iterator'>
```

**У всех итераторов** есть магический метод `__next__()`, который обеспечивает выдачу очередного элемента. Встроенная функция `next()` вызывает за кулисами именно этот магический метод. 

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)                    # равнозначно words.__iter__()

print(next(iterator))                     # равнозначно iterator.__next__()
print(next(iterator))                     # равнозначно iterator.__next__()
```

выводит:

```
hello
beegeek
```

Когда элементы в итераторе закончились, очередной вызов функции `next()` возбуждает исключение `StopIteration`.

Если объект итератором не является, то есть у него нет магического метода `__next__()`, то вызов функции `next()` приведет к ошибке.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(next(words))
```

приводит к возбуждению исключения:

```
TypeError: 'list' object is not an iterator
```

**У всех итераторов** есть и метод `__iter__()`, который возвращает сам итератор (сам себя). Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator1 = iter(words)                   # равнозначно words.__iter__()
iterator2 = iter(iterator1)               # равнозначно iterator1.__iter__()

print(iterator1 is iterator2)
```

выводит:

```no-highlight
True
```

Таким образом, если функции `iter()` передается итератор, то она возвращает его же. Если же функции `iter()` передать итерируемый объект, не являющийся итератором (например, список), то она вернет совсем другой объект – итератор на основе этого итерируемого объекта.

Возникает вопрос, для чего итераторы содержат магический метод `__iter__()`. Все дело в том, что цикл `for` ожидает, что у объекта, по которому идет итерирование, есть не только магический метод `__next__()`, но и `__iter__()`. Задача метода `__iter__()` – превращать итерируемый объект в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект.

Если циклу `for` передается не итератор, а итерируемый объект, то его метод `__iter__()` должен возвращать не сам объект, а итератор на основе этого итерируемого объекта.

Получается, в итераторах метод `__iter__()` нужен лишь для совместимости. Ведь если `for` работает как с итераторами, так и с итерируемыми объектами, но последние требуют преобразования к итератору, и `for` вызывает `__iter__()` без оценки того, что ему передали, то требуется, чтобы оба – итератор (`iterator`) и итерируемый объект (`iterable`) – поддерживали этот метод. С точки зрения наличия в классе метода `__iter__()` итераторы можно считать подвидом итерируемых объектов.

### Примечания

**Примечание 1.** Итерируемый объект (`iterable`) и итератор (`iterator`) – это протоколы, правила.

**Примечание 2.** Особенности итерируемых объектов и итераторов:

1. любой объект, не вызывающий исключение `TypeError` при передаче в функцию `iter()`, — итерируемый объект
2. любой объект, не вызывающий исключение `TypeError` при передаче в функцию `next()`, — итератор
3. любой объект, возвращающий сам себя при передаче в функцию `iter()`, — итератор

**Примечание 3.** После реализации в классе метода `__iter__()`, экземпляры данного класса можно преобразовывать в коллекции с помощью встроенных функций `list(), set(), tuple()` и `str()`.

**Примечание 4.** Встроенная функция `iter()` преобразует итерируемый объект в итератор. Именно в таком виде функция используется в большинстве случаев.

```python
iter(iterable) -> iterator
```

Однако мы можем использовать функцию `iter()` в еще одном полезном сценарии:

```python
iter(callable, sentinel) -> iterator
```

Если функции `iter()` передается два аргумента, то первый аргумент `callable` должен являться функцией, а второй аргумент `sentinel` — некоторым стоп-значением. В этом случае, созданный итератор будет вызывать указанную функцию `callable` и проверять полученное значение на равенство со значением `sentinel`. Если полученное значение равно `sentinel`, то возбуждается исключение `StopIteration`, иначе итератор выдает значение, полученное из функции `callable`.

Например, с помощью функции `iter()` мы можем создать бесконечный итератор, генерирующий единственное значение — `0`.

Приведенный ниже код:

```python
zero_iterator = iter(int, -1)

for i in range(5):
    print(next(zero_iterator))

print(type(zero_iterator))
```

выводит:

```no-highlight
0
0
0
0
0
<class 'callable_iterator'>
```

Функция `int()`, которую мы передаем в качестве первого аргумента в функцию `iter()`, всегда возвращает значение `0`, при этом вторым аргументом (стоп-значением) является `-1`, которое не будет возвращено никогда. Таким образом, мы построили бесконечный итератор, генерирующий единственное нулевое значение.

**Примечание 5.** Объекты типа `range` не являются итераторами несмотря на то, что не хранят все свои элементы явно. Подробнее об особенностях `range` объектов можно почитать в рамках курса для профессионалов по [ссылке](https://stepik.org/lesson/673155/step/12?unit=671418).

### Примеры создания итераторов

**Пример 1.** Реализуем класс `Counter`, экземплярами которого являются итераторы, генерирующие последовательность целых чисел от значения `low` до значения `high` включительно с шагом один.

**Реализация класса.** Определяем класс `Counter` с методами, реализующими протокол итератора:

1. `__iter__()` — метод,  возвращающий сам итератор
2. `__next__()` — метод, возвращающий следующий элемент итератора или возбуждающий исключение `StopIteration`

```python
class Counter:                             
    def __init__(self, low, high):
        self.low = low
        self.high = high
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.low > self.high:
            raise StopIteration
        self.low += 1
        return self.low - 1
```

Приведенный ниже код:

```python
counter1 = Counter(3, 10)               # создаем итератор Counter, передавая значения low=3, high=10

for i in counter1:                      # неявно вызываем функцию next()
    print(i)

counter2 = Counter(100, 103)            # создаем итератор Counter, передавая значения low=100, high=103
print(next(counter2))                   # явно вызываем функцию next()
print(next(counter2))                   # явно вызываем функцию next()
```

выводит:

```no-highlight
3
4
5
6
7
8
9
10
100
101
```

Напомним, что цикл `for` за кулисами вызывает один раз метод `__iter__()` у итерируемого объекта для получения итератора, а затем метод `__next__()` до тех пор, пока не будет возбуждено исключение `StopIteration`.

**Пример 2.** Реализуем класс итератор `EvenNumbers`, экземплярами которого являются бесконечные итераторы, генерирующие последовательность всех целых четных чисел от значения `begin`.

**Реализация класса.** Определяем класс `EvenNumbers` с методами, реализующими протокол итератора:

1. `__iter__()` — метод,  возвращающий сам итератор 
2. `__next__()` — метод, возвращающий следующий элемент итератора или возбуждающий исключение `StopIteration`

```python
class EvenNumbers:                             
    def __init__(self, begin):                 
        self.begin = begin + begin % 2
    
    def __iter__(self):
        return self
    
    def __next__(self):
        value = self.begin
        self.begin += 2
        return value
```

Приведенный ниже код:

```python
evens1 = EvenNumbers(10)                # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = EvenNumbers(101)               # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
```

выводит:

```no-highlight
10
12
14
16
18
20
102
104
106
108
```

Обратите внимание, что наш итератор является бесконечным, так как метод `__next__()` не возбуждает исключение `StopIteration`. При работе с бесконечными итераторами нужно быть осторожными, чтобы не попасть в бесконечный цикл.

Приведенный ниже код:

```python
evens = EvenNumbers(2)                  # все четные числа от 2 до бесконечности

for num in evens:
    print(num)
```

бесконечно печатает четные числа:

```no-highlight
2
4
6
8
10
12
14
16
...
```

**Пример 3.** Реализуем класс итератор `Factorials`, экземплярами которого являются бесконечные итераторы, генерирующие последовательность факториалов всех натуральных чисел (от `1` до бесконечности).

**Реализация класса.** Определяем класс `Factorials`с методами, реализующими протокол итератора:

1. `__iter__()` — метод,  возвращающий сам итератор 
2. `__next__()` — метод, возвращающий следующий элемент итератора или возбуждающий исключение `StopIteration`

```python
class Factorials:
    def __init__(self):
        self.value = 1
        self.index = 1
        
    def __iter__(self):
        return self
        
    def __next__(self):
        self.value *= self.index
        self.index += 1
        return self.value
```

Приведенный ниже код:

```python
infinite_factorials = Factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
    else:
        break
```

выводит:

```no-highlight
Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800
```

### Примеры создания итерируемых объектов

Для создания итератора нам требуется определить методы `__next__()` и `__iter__()`, в то время как для создания итерируемого объекта достаточно определить только метод `__iter__()`, возвращаемым значением которого является итератор. При реализации метода `__iter__()` у итерируемых объектов удобно пользоваться всеми возможностями генераторов, а именно: генераторными выражениями и генераторными функциями (ключевые слова `yield` и `yield from`).

**Пример 1.** Реализуем класс `Order`, описывающий список покупок, экземпляры которого поддерживают итерацию.

**Реализация класса.** Определяем класс `Order` с методом, реализующим протокол итерируемого объекта:

1. `__iter__()` — метод, возвращающий итератор

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)          # список покупок
        self.customer = customer        # имя покупателя

    def __iter__(self):
        yield from self.cart            # или с помощью выражения return (elem for elem in self.cart)
```

Приведенный ниже код:

```python
order = Order(['банан', 'яблоко', 'лимон'], 'Элой')

for item in order:
    print(item)
```

выводит:

```no-highlight
банан
яблоко
лимон
```

Подробнее о генераторах можно почитать в рамках курса для профессионалов по [ссылке](https://stepik.org/lesson/640048/step/1?unit=636568).

## 6.2 Протокол последовательностей
### Тема урока: протокол последовательностей

1. Магический метод `__len__()`
2. Магические методы `__getitem__(), __setitem__()` и `__delitem__()`
3. Магический метод `__contains__()`

**Аннотация.** Урок посвящен протоколу последовательностей.

### Протокол последовательностей

В предыдущем уроке мы упомянули **последовательности** — коллекции, элементы которых пронумерованы индексами и расположены в строгом порядке. В Python существует несколько типов, подходящих под это определение, и несмотря на то что они имеют ряд различий между собой, все они могут обрабатываться одинаково. Поэтому если объект ведет себя как последовательность, то мы считаем его последовательностью, независимо от его типа. Или более формально: если объект удовлетворяет протоколу последовательности, то он является последовательностью.

**Утиная типизация** заключается в том, что, вместо проверки типа чего-либо в Python, мы склонны проверять, какое поведение оно поддерживает: если что-то похоже на утку и крякает как утка, то это утка.

Итак, последовательностью считается объект, поддерживающий следующие операции:

- индексация
- срезы
- проверка на принадлежность (оператор `in`)
- наличие длины
- итерирование

К уже знакомым нам последовательностям можно отнести такие типы как `list, str, tuple` и `range`. Если мы рассмотрим, например, типы `list` и `str`, то отметим, что списки являются изменяемыми, а строки нет. Также списки в качестве элементов могут содержать объекты произвольных типов, в то время как строки, по сути, представляют собой коллекции символов. Однако и списки, и строки, являются последовательностями, так как удовлетворяют протоколу последовательности.

Объект типа `range` отличается тем, что не хранит явно все элементы последовательности в памяти. Он хранит только начальное значение, конечное значение и шаг последовательности.

### Создание собственных последовательностей

Объект считается последовательностью, если он ведет себя как последовательность. Поэтому мы можем создавать собственные классы, определяя в них все операции последовательности путем добавления соответствующих магических методов, таким образом превращая их экземпляры в последовательности.

Последовательности бывают изменяемые и неизменяемые, и вторые несколько проще, так как не поддерживают добавление и удаление элементов, то есть в них определено меньшее количество магических методов, поэтому мы начнем именно с них.

Для реализации протокола неизменяемой последовательности необходимо определить следующие магические методы:

- `__len__()` — определяет поведение при передаче в функцию `len()`, возвращает количество элементов в последовательности
- `__getitem__()` — определяет поведение при доступе к элементу, используя синтаксис `self[key]` 
- `__iter__()` — определяет поведение при передаче в функцию `iter()`, возвращает итератор для последовательности
- `__contains__()` — определяет поведение при проверке на принадлежность с помощью оператора `in` (`not in`)

Рассмотрим класс `Order`, описывающий список покупок, экземплярами которого являются неизменяемые последовательности.

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)                  # список покупок
        self.customer = customer                # имя покупателя

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(len(order))
print(order[1])
print('дыня' in order)
print('лимон' in order)
print(*order, sep=', ')
```

выводит:

```no-highlight
3
яблоко
False
True
банан, яблоко, лимон
```

Обратите внимание, что метод `__getitem__()` в качестве аргумента `key` принимает индекс, а метод `__contains__()` в качестве аргумента `item` принимает объект, наличие которого требуется проверить.

Для реализации протокола изменяемой последовательности необходимо к вышеуказанным методам добавить следующие магические методы:

- `__setitem__()` — определяет поведение при присваивании значения элементу, используя синтаксис `self[key] = value`
- `__delitem__()` — определяет поведение при удалении элемента с помощью оператора `del`

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def check_key(self, key):                   # отдельный метод для проверки индекса на корректность
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return key

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        key = self.check_key(key)
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart

    def __setitem__(self, key, value):
        key = self.check_key(key)
        self.cart[key] = value

    def __delitem__(self, key):
        key = self.check_key(key)
        del self.cart[key]


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(*order, sep=', ')

order[1] = 'ананас'
del order[2]

print(*order, sep=', ')
```

выводит:

```no-highlight
банан, яблоко, лимон
банан, ананас
```

Обратите внимание, что метод `__setitem__()` сперва принимает индекс (`key`), а после устанавливаемое значение (`value`).

### Срезы последовательностей

Помимо доступа к элементам по индексам, последовательности поддерживают срезы, синтаксис которых нам уже хорошо знаком.

Приведенный ниже код:

```python
nums = [1, 2, 3, 4, 5]

print(nums[1:])
print(nums[:3])
print(nums[1:3])
print(nums[1:4:2])
```

выводит:

```no-highlight
[2, 3, 4, 5]
[1, 2, 3]
[2, 3]
[2, 4]
```

Перед тем как разобраться, как на самом деле работают срезы в Python, следует поговорить о встроенной функции `slice()`, которая возвращает специальный объект типа `slice`. Данный объект напоминает объект типа `range`, он также имеет начальное значение, конечное значение и шаг.

Приведенный ниже код:

```python
slice1 = slice(10)                              # start=None, stop=10, step=None  
slice2 = slice(1, 10)                           # start=1, stop=10, step=None
slice3 = slice(1, 10, 2)                        # start=1, stop=10, step=2

print(slice1)
print(slice2)
print(slice3)
```

выводит:

```no-highlight
slice(None, 10, None)
slice(1, 10, None)
slice(1, 10, 2)
```

Синтаксис создания объектов типа `slice` полностью совпадает с синтаксисом создания `range` объектов. Неуказанные значения при создании `slice` объекта принимают значение `None`.

Срезы в Python реализуются с помощью `slice` объектов. Именно они автоматически создаются и указываются в качестве индексов, когда мы используем синтаксис срезов.

Приведенный ниже код:

```python
nums = [1, 2, 3, 4, 5]

print(nums[slice(1, None, None)])               # равнозначно nums[1:]
print(nums[slice(3)])                           # равнозначно nums[:3]
print(nums[slice(1, 3)])                        # равнозначно nums[1:3]
print(nums[slice(1, 4, 2)])                     # равнозначно nums[1:4:2]
```

выводит:

```no-highlight
[2, 3, 4, 5]
[1, 2, 3]
[2, 3]
[2, 4]
```

У каждого `slice` объекта имеются атрибуты `start, stop` и `step`, в которых содержатся начальное значение, конечное значение и шаг соответственно.

Приведенный ниже код:

```python
slice1 = slice(10)                              # start=None, stop=10, step=None  
slice2 = slice(1, 10)                           # start=1, stop=10, step=None
slice3 = slice(1, 10, 2)                        # start=1, stop=10, step=2

print(slice1.start, slice1.stop, slice1.step)
print(slice2.start, slice2.stop, slice2.step)
print(slice3.start, slice3.stop, slice3.step)
```

выводит:

```no-highlight
None 10 None
1 10 None
1 10 2
```

Таким образом, чтобы реализовать возможность использовать срезы, требуется лишь обработать ситуацию, когда в магические методы, работающие с индексами (`__getitem__(), __setitem__(), __delitem__()`), передается объект типа `slice`.

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if isinstance(key, slice):
            return Order(self.cart[key], self.customer)
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart


order1 = Order(['банан', 'яблоко', 'лимон', 'дыня', 'грейпфрут'], 'Кемаль')
order2 = order1[1:]
order3 = order1[2:4]
order4 = order1[1:5:2]

print(*order2, sep=', ')
print(*order3, sep=', ')
print(*order4, sep=', ')
```

выводит:

```no-highlight
яблоко, лимон, дыня, грейпфрут
лимон, дыня
яблоко, дыня
```

Аналогичным образом можно реализовать методы `__setitem__()` и `__delitem__()`, чтобы пользоваться срезами и в них.

### Примечания

**Примечание 1.** Чтобы определить поведение при передаче в функцию `reversed()`, используется магический метод `__reversed__()`.

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart

    def __reversed__(self):
        return reversed(self.cart)


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(*order, sep=', ')
print(*reversed(order), sep=', ')
```

выводит:

```no-highlight
банан, яблоко, лимон
лимон, яблоко, банан
```

**Примечание 2.** Магический метод `__contains__()` можно считать как частью протокола последовательности, так и нет. Дело в том, что если данный метод не определен, Python самостоятельно перебирает всю последовательность и возвращает `True`, если находит искомый элемент, или `False` в противном случае.

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __iter__(self):
        print('Вызов метода __iter__()')
        yield from self.cart


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print('арбуз' in order)
print('лимон' in order)
```

выводит:

```no-highlight
Вызов метода __iter__()
False
Вызов метода __iter__()
True
```

Метод `__iter__()` также может быть опущен, так как если у объекта есть длина и возможность обращаться к его элементам по индексам, то этого достаточно, чтобы проитерироваться по нему вручную. Таким образом, если в некотором классе определены методы `__len__()` и `__getitem__()`, то его экземпляры уже можно назвать последовательностью.​​​​

**Примечание 3.** Неуказанные значения при создании `slice` объекта принимают значение `None`. Так происходит из-за того, что заранее неизвестно, к последовательности какой длины он будет применяться. Конечно, мы можем самостоятельно обрабатывать неуказанные значения, однако удобнее воспользоваться методом `indices()`. Данный метод принимает в качестве аргумента длину последовательности, к которой будет применяться срез, и возвращает кортеж из трех целых чисел, представляющих конечные значения `start, stop` и `step`.

Приведенный ниже код:

```python
slice1 = slice(10)                              # start=None, stop=10, step=None  
slice2 = slice(1, 10)                           # start=1, stop=10, step=None
slice3 = slice(1, 10, 2)                        # start=1, stop=10, step=2

print(slice1.indices(5))
print(slice2.indices(50))
print(slice3.indices(8))
```

выводит:

```no-highlight
(0, 5, 1)
(1, 10, 1)
(1, 8, 2)
```

**Примечание 4.** Не забывайте, что если в классе определен магический метод `__len__()`, но не определен магический метод `__bool__()`, то именно `__len__()` будет использоваться для всех логических приведений.

Приведенный ниже код:

```python
class MyClass:
    def __len__(self):
        return 0


print(bool(MyClass()))
```

выводит:

```no-highlight
False
```

**Примечание 5.** Реализовав в классе магические методы `__getitem__()` и `__len__()` мы можем передавать его экземпляры в функцию `choice()` модуля `random`. 

Приведенный ниже код:

```python
from random import choice

class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __iter__(self):
        print('Вызов метода __iter__()')
        yield from self.cart


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(choice(order))
print(choice(order))
```

выводит две случайные покупки, например:

```no-highlight
лимон
банан
```

## 6.3 Оператор with
### Тема урока: оператор with

1. Управление ресурсами в Python
2. Оператор `with`

**Аннотация.** Урок посвящен оператору `with`.

### Управление ресурсами в Python

Python является языком с управляемой памятью, то есть программисту, пишущему код на Python, не нужно беспокоиться о работе с памятью и заниматься ее освобождением. Как только данные программы (объекты) становятся не нужны, сборщик мусора автоматически удаляет их и освобождает память, которую они занимали.

![](https://ucarecdn.com/117e7ec0-8aa0-4cc6-a1d7-e0aa93d5d163/)   Почитать про устройство и механизмы очистки памяти в Python можно по [ссылке](https://stepik.org/lesson/624148/step/1?unit=619836) и [ссылке](https://stepik.org/lesson/624149/step/1?unit=619837).

Однако при работе с **внешними ресурсами**, такими как файлы, очень важно своевременно их освобождать (закрывать). В некоторых случаях Python может самостоятельно закрыть файл, но лучше на это не рассчитывать и закрывать файл явно.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')
file.write('Python generation!')
file.close()
```

создает текстовый файл с именем `output.txt` и записывает в него строку текста `Python generation!`.

Ручное закрытие файлов, а также отдача закрытия на откуп Python, обладают одним существенным недостатком: если между открытием файла и его закрытием будет возбуждено исключение, то файл может остаться открытым и недоступным для других процессов, что может привести к проблемам. В лучшем случае файл окажется открыт слишком долго, а в худшем случае не сохранится часть данных.

Вывод данных в файл при помощи методов `write()` и `writelines()` [буферизируется](https://docs-python.ru/tutorial/metody-fajlovogo-obekta-potoka-python/metod-file-write/), поэтому записываемые данные могут попасть на диск не сразу. Для форсирования сброса можно использовать файловый метод `flush()`.

Для того чтобы гарантировать закрытие файла даже при наличии исключений, мы можем использовать конструкцию `try-finally`.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')

try:
    file.write('Python generation!')
finally:
    file.close()
```

гарантированно закрывает файл, даже если между его открытием и закрытием будет возбуждено исключение. Мы также можем обработать возникшее исключение с помощью блока `except`, после чего закрыть файл:

```python
file = open('output.txt', mode='w', encoding='utf-8')

try:
    file.write('Python generation!')
except Exception as error:
    print(f'При записи в файл возникла ошибка: {error}')
finally:
    file.close()
```

### Оператор with

Подход, основанный на использовании конструкции `try-finally`, для освобождения внешних ресурсов рабочий, однако достаточно громоздкий. При его использовании мы пишем один и тот же код каждый раз, когда нам нужно освободить ресурс.

В Python для удобного и своевременного освобождения ресурсов есть специальный оператор `with`.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')

try:
    file.write('Python generation!')
finally:
    file.close()
```

можно переписать с использованием оператора `with` в виде:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    file.write('Python generation!')
```

Как мы видим, явные вызовы метода `close()` пропали, однако при этом файл закрывается надёжно и вовремя. Помимо надежного и своевременного закрытия файла, код с использованием `with` выглядит понятнее и короче, а также не содержит ненужный шаблонный код.

Оператор `with` является своего рода [синтаксическим сахаром](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80#:~:text=%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9%20%D1%81%D0%B0%D1%85%D0%B0%D1%80%20(%D0%B0%D0%BD%D0%B3%D0%BB.,%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%20%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5%20%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D1%8B%D0%BC%20%D0%B4%D0%BB%D1%8F%20%D1%87%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA%D0%B0.), и за кулисами разворачивается практически тот же самый блок `try-finally`.

Объект, которым управляет оператор `with`, не обязательно должен создаваться в нем. Приведенный выше код можно переписать в виде:

```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    file.write('Python generation!')
```

Оператор `with` также может управлять сразу несколькими объектами.

Приведенный ниже код:

```python
with open('file.txt', encoding='utf-8') as file, open('output.txt', mode='w', encoding='utf-8') as output:
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```

нумерует строки файла `file.txt` и записывает их в файл `output.txt`.

При наличии нескольких объектов в операторе `with` они обрабатываются так, как если бы несколько операторов `with` были вложенными.

Приведенный выше код равнозначен коду:

```python
with open('file.txt', encoding='utf-8') as file:
    with open('output.txt', mode='w', encoding='utf-8') as output:
        for index, line in enumerate(file, 1):
            output.write(f'{index}. {line}')
```

### Примечания

**Примечание 1.** Общий шаблон использования оператора `with` выглядит следующим образом:

```python
with EXPRESSION as TARGET:
    # это тело with блока
    # здесь нам доступен ресурс TARGET

# здесь ресурс TARGET уже освобождён, даже если в теле with блока было возбуждено исключение
```

Весь код в теле `with` блока работает как бы в одном контексте. Чаще всего контекст подразумевает выделение некоторого ресурса, например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока было возбуждено исключение. Обратите внимание на то, что использовать ключевое слово `as` при работе с оператором `with` **необязательно**.

**Примечание 2.** Оператор `with` работает не со всеми объектами. Для того, чтобы иметь возможность использовать некоторый объект в операторе `with`, этот объект должен удовлетворять **протоколу контекстного менеджера**, о котором подробно будет рассказано в следующем уроке.

**Примечание 3.** Несмотря на то, что оператор `with` короче использования конструкции `try-finally`, он все же менее универсален. Мы можем использовать оператор `with` только с объектами, поддерживающими протокол контекстного менеджера, в то время как конструкция `try-finally` позволяет выполнять действия по очистке произвольных объектов без необходимости поддержки какого-либо протокола.

**Примечание 4.** Встроенная функция `open()` возвращает специальный файловый объект (тип `TextIOWrapper`), который напрямую взаимодействует с операционной системой. Количество таких объектов в каждой операционной системе ограничено, поэтому очень важно их своевременно освобождать.

Приведенный ниже код:

```python
files = []

for _ in range(100_000):
    files.append(open('output.txt', mode='w', encoding='utf-8'))
```

на операционной системе Windows приводит к возбуждению исключения:

```no-highlight
OSError: [Errno 24] Too many open files: 'output.txt'
```

**Примечание 5.** Атрибут `closed` экземпляров типа `TextIOWrapper` позволяет проверить состояние закрытости файла.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    print(file.closed)

print(file.closed)
```

выводит:

```no-highlight
False
True
```

**Примечание 6.** С помощью методов `readable()` и `writable()` мы можем определить возможность чтения и записи из файла.

Приведенный ниже код:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    print(file.readable(), file.writable())
    
with open('output.txt', mode='r', encoding='utf-8') as file:
    print(file.readable(), file.writable())
```

выводит:

```no-highlight
False True
True False
```

**Примечание 7.** Мы можем использовать оператор `with` вместе с конструкцией `try-except-finally` при необходимости. Это может быть полезным при обработке исключений, связанных с открытием несуществующих файлов:

```python
try:
    with open('file.txt', encoding='utf-8') as file:
        print(file.read())
except Exception as error:
    print(f'Произошла ошибка {error}')
```

В данном примере, в случае, если файла `file.txt` не существует, будет возбуждено исключение, которое будет перехвачено в блоке `except`.

**Примечание 8.** Начиная с версии Python 3.10 мы можем использовать круглые скобки при использовании оператора `with`, который управляет сразу несколькими объектами. Это позволяет форматировать длинную коллекцию диспетчеров контекста в несколько строк.

Приведенный ниже код:

```python
with open('file.txt', encoding='utf-8') as file, open('output.txt', mode='w', encoding='utf-8') as output:
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```

можно переписать в виде:

```python
with (
    open('file.txt', encoding='utf-8') as file, 
    open('output.txt', mode='w', encoding='utf-8') as output
):
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```

**Примечание 9.** Подробнее прочитать про оператор `with` можно в официальной документации по [ссылке](https://peps.python.org/pep-0343/).

## 6.4 Протокол контекстных менеджеров. Часть 1
### Тема урока: протокол контекстных менеджеров

1. Протокол контекстных менеджеров
2. Магические методы `__enter__()` и `__exit__()`
3. Обработка исключений внутри блока `with`
4. Примеры использования встроенных контекстных менеджеров
5. Примеры создания пользовательских контекстных менеджеров

**Аннотация.** Урок посвящен протоколу контекстных менеджеров.

### Протокол контекстных менеджеров

В прошлом уроке мы сказали, что оператор `with` может работать только с объектами, которые реализуют протокол контекстного менеджера.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name


with Cat('Кемаль') as cat:
    print(cat)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: __enter__
```

поскольку класс `Cat` не реализует протокол контекстного менеджера.

В Python 3.11 возбуждается исключение `TypeError: 'Cat' object does not support the context manager protocol`.

Контекстный менеджер — это объект, определяющий контекст выполнения в операторе `with`.

Протокол контекстных менеджеров состоит всего из двух методов:

- `__enter__()` – вводит контекст и при необходимости возвращает некоторый объект. Значение, возвращаемое этим методом, привязывается к переменной в предложении `as` оператора `with`
- `__exit__()` – предоставляет выход из контекста и возвращает логический флаг (тип `bool`), указывающий на то, следует ли подавлять возбужденное исключение. При возбуждении исключения во время выполнения тела блока `with`, аргументы содержат тип исключения `exc_type`, объект исключения `exc_val` и информацию о трассировке `traceback`. В противном случае все три аргумента равны `None`

Создадим простой контекстный менеджер `CustomContextManager`, который просто выводит текст в методах `__enter__()` и `__exit__()`:

```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        print(exc_type, exc_value, traceback, sep='\n')
```

Приведенный ниже код:

```python
with CustomContextManager() as manager:
    print(manager)
```

выводит:

```no-highlight
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
None
None
None
```

При выполнении оператора `with` сначала создается экземпляр класса `CustomContextManager`, а затем вызывается его метод `__enter__()`, который печатает текст `Вход в контекстный менеджер...` и возвращает строку `Python generation!`, которая присваивается переменной `manager`. Далее исполняется тело оператора `with`, после чего вызывается метод `__exit__()`. Поскольку во время выполнения тела оператора `with` не было возбуждено никакое исключение, то все три аргумента `exc_type, exc_value` и `traceback` метода `__exit__()` равны `None`.

Рассмотрим ситуацию, в которой в теле оператора `with` возбуждается исключение.

Приведенный ниже код:

```python
with CustomContextManager() as manager:
    print(manager)
    print(manager[100])                                 # обращаемся по несуществующему индексу
```

выводит (адрес может отличаться):

```no-highlight
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
<class 'IndexError'>
string index out of range
<traceback object at 0x000001E5CBB57500>
```

после чего возбуждается исключение:

```no-highlight
IndexError: string index out of range
```

Как мы видим, аргументы метода `__exit__()` содержат информацию о возбужденном исключении:

- `exc_type` – тип исключения, в данном случае `IndexError`
- `exc_value` – объект самого исключения
- `traceback` – информация о трассировке (подробнее о трассировке можно почитать по [ссылке](https://docs.python.org/3/library/traceback.html))

В атрибуте `exc_value.args` можно найти параметры, переданные конструктору исключения, например, сообщение об  
ошибке.

### Обработка исключений внутри блока with

Для обработки исключений внутри блока `with` нужно добавить дополнительный код в метод `__exit__()`. Как уже было сказано выше, метод `__exit__()` возвращает логический флаг (тип `bool`), указывающий на то, следует ли подавлять возбужденное исключение или нет.

Модифицируем наш контекстный менеджер `CustomContextManager` следующим образом:

```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        if isinstance(exc_value, IndexError):
            print(f'Тип возникшего исключения: {exc_type}')
            print(f'Текст исключения: {exc_value}')
            return True                                 # подавляем возбужденное исключение IndexError
```

Приведенный ниже код:

```python
with CustomContextManager() as manager:
    print(manager)
    print(manager[100])                                 # обращаемся по несуществующему индексу
```

выводит:

```no-highlight
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
Тип возникшего исключения: <class 'IndexError'>
Текст исключения: string index out of range
```

и больше не приводит к возбуждению исключения `IndexError`, поскольку мы обработали этот тип исключения в методе `__exit__()`. Возврат значения `True` позволяет поглотить возбужденное в теле оператора `with` исключение и продолжить выполнение с оператора, **непосредственно следующего** за оператором `with`.

Если при выполнении тела оператора `with` не возбуждается исключение `IndexError`, то метод возвращает значение `None`, которое приводится к логическому `False`. Для придания наглядности рекомендуется явно возвращать значение `False` из метода `__exit__()`:

```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        if isinstance(exc_value, IndexError):
            print(f'Тип возникшего исключения: {exc_type}')
            print(f'Текст исключения: {exc_value}')
            return True                                 # подавляем возбужденное исключение IndexError
        return False                                    # все остальные типы исключений не подавляются
```

Передаваемое исключение `exc_value` не следует никогда повторно возбуждать в методе `__exit__()`, вместо этого метод `__exit__()` должен возвращать значение `False`, чтобы указать, что метод завершился успешно и не хочет подавлять возбужденное исключение. Это позволяет коду управления контекстом легко определять, действительно ли метод `__exit__()` потерпел неудачу.

 Исключения, возникающие во время выполнения метода `__exit__()`, заменяют все исключения, возникшие в теле оператора `with`.

### Примеры использования встроенных контекстных менеджеров

**Пример 1.** Самым простым вариантом использования встроенного контекстного менеджера является файловый объект, который возвращает функция `open()`. Этот объект реализует протокол контекстного менеджера, в чем несложно убедиться.

Приведенный ниже код:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    print('__enter__' in dir(file))                      # наличие метода __enter__()
    print('__exit__' in dir(file))                       # наличие метода __exit__()
    file.write('Python generation!')
```

создает текстовый файл с именем `output.txt` с содержимым `Python generation!` и выводит:

```no-highlight
True
True
```

**Пример 2.** Мы можем использовать контекстный менеджер для настройки объектов типа `Decimal`, который обеспечивает точные вычисления с вещественными числами (в отличие от типа `float`). Функция `localcontext()` модуля `decimal` позволяет настраивать активный контекст для арифметических операций. С помощью данного контекста мы можем устанавливать точность, правила округления и т.д.

Приведенный ниже код:

```python
from decimal import Decimal, localcontext

num1 = Decimal('1')
num2 = Decimal('9')

print(num1 / num2)                   # по умолчанию 28 знаков после запятой

with localcontext() as ctx:
    ctx.prec = 5                     # устанавливаем 5 знаков после запятой
    print(num1 / num2)

with localcontext() as ctx:
    ctx.prec = 10                    # устанавливаем 10 знаков после запятой
    print(num1 / num2)
```

выводит:

```no-highlight
0.1111111111111111111111111111
0.11111
0.1111111111
```

Почитать подробнее о типе `Decimal` модуля `decimal` можно в курсе для продвинутых по [ссылке](https://stepik.org/lesson/360941/step/1?unit=345464).

**Пример 3.** Встроенный модуль `os` содержит функцию `scandir()`, которая возвращает итератор типа `ScandirIterator`, поддерживающий протокол контекстного менеджера. Эта функция специально разработана для обеспечения оптимальной производительности при перемещении по структуре папок.

Приведенный ниже код:

```python
import os

with os.scandir('.') as entries:
    for entry in entries:
        print(entry.name, '--->', entry.stat().st_size, 'bytes')
```

выводит информацию о файлах, которые находятся в папке с исполняющимся файлом (вывод может отличаться):

```no-highlight
18+.png ---> 60 bytes
ducks.zip ---> 641592 bytes
logo.bmp ---> 32160 bytes
with.py ---> 138 bytes
Любимая уточка Бэтмен.txt ---> 97 bytes
Математика для программиста.doc ---> 759780 bytes
Мемуары Поколения.txt ---> 5909400 bytes
План для курса алгоритмы и структуры данных.txt ---> 590940 bytes
```

Подробнее о функции `scandir()` можно почитать по [ссылке](https://docs-python.ru/standart-library/modul-os-python/funktsija-scandir-modulja-os/).

**Пример 4.** Встроенный модуль `tempfile` (подробнее по [ссылке](https://docs.python.org/3/library/tempfile.html)) содержит контекстный менеджер `TemporaryFile`, который позволяет создавать и удалять временные файлы автоматически.

Приведенный ниже код:

```python
from tempfile import TemporaryFile

with TemporaryFile(mode='r+') as file:
    file.write('Python generation!')
    file.seek(0)
    content = file.read()
    print(content)
```

выводит:

```no-highlight
Python generation!
```

В этом примере временный файл создается при входе в тело блока контекста и удаляется при выходе. Такой подход позволяет избежать утечек памяти и ошибок, связанных с неправильным удалением временных файлов.

Для того чтобы иметь возможность писать в файл и читать из файла, мы используем режим доступа `r+`. Подробнее о всех режимах можно почитать по [ссылке](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files).

**Пример 5.** Встроенный модуль `threading` содержит контекстный менеджер `Lock`, который обеспечивает примитивную блокировку для предотвращения одновременного изменения общего ресурса несколькими потоками в многопоточном приложении.

Приведенный ниже код:

```python
from threading import Lock


with Lock() as lock:
    # защищенная область
    # смело выполняем любые действия, не думая о гонке потоков
```

создает защищенную область ([критическая секция](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B5%D0%BA%D1%86%D0%B8%D1%8F)), которая предотвращает одновременный доступ из разных потоков к общим ресурсам.

Подробнее о многопоточном коде вы узнаете в нашем курсе о [многопоточности](https://stepik.org/media/attachments/lesson/897941/%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C.jpg).

### Примечания

**Примечание 1.** Приведенный ниже код: 

```python
with EXPRESSION as TARGET:
    SUITE
```

равнозначен коду:

```python
manager = (EXPRESSION)
enter = type(manager).__enter__
exit = type(manager).__exit__
value = enter(manager)
hit_except = False

try:
    TARGET = value
    SUITE
except:
    hit_except = True
    if not exit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        exit(manager, None, None, None)
```

## 6.5 Протокол контекстных менеджеров. Часть 2
### Тема урока: протокол контекстных менеджеров

1. Примеры создания контекстных менеджеров
2. Одноразовые, многоразовые и реентерабельные контекстные менеджеры

**Аннотация.** Урок посвящен протоколу контекстных менеджеров.

### Примеры создания контекстных менеджеров

С помощью контекстных менеджеров мы можем не только грамотно управлять ресурсами, но и выполнять любую пару операций, которую необходимо выполнить до и после каких-то действий. Например:

- открытие и закрытие
- создание и удаление
- изменение данных и возврат к начальным данным
- блокировка и освобождение
- вход и выход
- старт и стоп
- и т.д.

Приведем несколько примеров реализации контекстных менеджеров.

**Пример 1.** Контекстный менеджер `Trace` выводит информацию перед входом в блок `with` и после выхода из блока `with`, включая информацию об исключении, если оно было возбуждено во время выполнения блока `with`.

```python
class Trace:
    def __enter__(self):
        print('Начало выполнения блока with')

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_value:
            print(f'Во время выполнения блока with было возбуждено исключение {exc_value}')
        print('Конец выполнения блока with')
        return True                           # обрабатываем все типы исключений
```

Приведенный ниже код:

```python
with Trace():
    print('Python generation!')
```

выводит:

```no-highlight
Начало выполнения блока with
Python generation!
Конец выполнения блока with
```

Приведенный ниже код:

```python
with Trace():
    print('Python generation!')
    print(1 / 0)
```

выводит: 

```no-highlight
Начало выполнения блока with
Python generation!
Во время выполнения блока with было возбуждено исключение division by zero
Конец выполнения блока with
```

Обратите внимание, что метод `__exit__()` возвращает значение `True`, таким образом любое возбужденное в блоке `with` исключение будет обработано.

**Пример 2.** Контекстный менеджер `WritableTextFile` позволяет работать с открытыми для записи текстовыми файлами в кодировке `UTF-8`:

```python
class WritableTextFile:
    def __init__(self, path):
        self.path = path

    def __enter__(self):
        self.file = open(self.path, mode='w', encoding='utf-8')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()
```

Приведенный ниже код:

```python
with WritableTextFile('output.txt') as file:
    file.write('Python generation!')
```

создает текстовый файл `output.txt` в кодировке `UTF-8` с содержимым `Python generation!`.

Обратите внимание, что метод `__enter__()` возвращает файловый объект, в который производится запись данных. Иногда при написании контекстных менеджеров у нас не бывает подходящего объекта, который можно вернуть из метода `__enter__()`. В этих случаях мы можем вернуть `None` явно или просто положиться на неявное возвращаемое значение, которое также равно `None`.

**Пример 3.** Контекстный менеджер `RedirectedStdout` **временно** перенаправляет стандартный вывод `sys.stdout` на некоторый файл на диске:

```python
import sys

class RedirectedStdout:
    def __init__(self, new_output):
        self.new_output = new_output

    def __enter__(self):
        self.standard_output = sys.stdout
        sys.stdout = self.new_output

    def __exit__(self, exc_type, exc_value, traceback):
        sys.stdout = self.standard_output 
```

Приведенный ниже код:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    with RedirectedStdout(file):
        print('Python generation!')
    print('Возврат к стандартному потоку вывода')
```

создает текстовый файл `output.txt` в кодировке `UTF-8` с содержимым `Python generation!`, а также выводит текст `Возврат к стандартному потоку вывода`.

Класс `RedirectedStdout` — это хороший пример контекстного менеджера, у которого нет полезного значения для возврата из метода `__enter__()`.

**Пример 4.** Контекстный менеджер `Timer` позволяет измерять время выполнения блока кода:

```python
from time import perf_counter

class Timer:
    def __enter__(self):
        self.start = perf_counter()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.elapsed = perf_counter() - self.start
```

Приведенный ниже код:

```python
from time import sleep

with Timer() as timer:
    sleep(0.7)
    sleep(1.5)
print('Затраченное время:', timer.elapsed)
```

выводит (время может отличаться):

```no-highlight
Затраченное время: 2.208050799788907
```

Мы можем немного модифицировать контекстный менеджер `Timer`, чтобы метод `__enter__()` возвращал не `self`, а функцию, которая возвращает вычисленное значение.

```python
from time import perf_counter

class Timer:
    def __enter__(self):
        self.start = perf_counter()
        self.end = 0.0
        return lambda: self.end - self.start

    def __exit__(self, exc_type, exc_value, traceback):
        self.end = perf_counter()
```

Приведенный ниже код:

```python
from time import sleep

with Timer() as timer:
    sleep(0.7)
    sleep(1.5)
print('Затраченное время:', timer())
```

выводит (время может отличаться):

```no-highlight
Затраченное время: 2.206870499998331
```

### Примечания

**Примечание 1.** Если мы забыли названия и количество аргументов, которые передаются в метод  `__exit__()` и при этом мы их не используем, то следует использовать следующую сигнатуру метода `__exit__()`:

```python
def __exit__(self, *args, **kwargs):
    ...
```

### Одноразовые, многоразовые и реентерабельные контекстные менеджеры

Контекстные менеджеры обычно делят на три категории:

- одноразовые
- многоразовые
- реентерабельные

#### Одноразовые контекстные менеджеры

Большинство контекстных менеджеров написаны таким образом, что они могут эффективно использоваться в операторе `with` только один раз. Такие менеджеры называют **одноразовыми**, и они должны создаваться заново каждый раз перед использованием. Когда они уже используются или использовались в операторе `with` – попытка использовать их во второй раз может привести к возбуждению исключения или приведет к неправильной их работе.

Классическим примером одноразового контекстного менеджера является объект, возвращаемый встроенной функцией `open()`.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    file.write('Python generation!')
    
with file:
    file.write('Python generation!')
```

приводит к возбуждению исключения:

```no-highlight
ValueError: I/O operation on closed file.
```

поскольку первый оператор `with` закрывает файл, предотвращая любые дальнейшие операции ввода-вывода с использованием этого файлового объекта.

#### Многоразовые контекстные менеджеры

**Многоразовый** контекстный менеджер – это менеджер, который можно повторно использовать в рамках **невложенных** операторов `with`. Примером многоразового контекстного менеджера может служить `Timer`, позволяющий измерять время выполнения блока кода:

```python
from time import perf_counter

class Timer:
    def __enter__(self):
        self.start = perf_counter()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.elapsed = perf_counter() - self.start
```

Приведенный ниже код:

```python
from time import sleep

timer = Timer()

with timer:
    sleep(1.5)
print('Затраченное время:', timer.elapsed)

with timer:
    sleep(0.7)
print('Затраченное время:', timer.elapsed)

with timer:
    sleep(1)
print('Затраченное время:', timer.elapsed)
```

выводит (время может отличаться):

```no-highlight
Затраченное время: 1.504402399994433
Затраченное время: 0.71097999997437
Затраченное время: 1.0067103998735547
```

#### Реентерабельные контекстные менеджеры

**Реентерабельный** контекстный менеджер – это менеджер, который можно повторно использовать в рамках **вложенных** операторов `with`. Примером реентерабельного контекстного менеджера может служить `Indenter`, который позволяет печатать текст на разных уровнях отступа:

```python
class Indenter:
    def __init__(self):
        self.level = -1

    def __enter__(self):
        self.level += 1
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.level -= 1

    def print(self, text):
        print('    ' * self.level + text)
```

Как мы видим, метод `__enter__()` увеличивает значение атрибута `level` на `1` каждый раз, когда поток выполнения входит в контекст. Метод `__exit__()` уменьшает значение атрибута `level` на `1`, чтобы печатаемый текст возвращался на один уровень отступа каждый раз, когда мы выходим из контекста. Ключевым моментом в этом примере является то, что метод `__enter__()` возвращает значение текущего экземпляра `self`, что позволяет нам повторно использовать один и тот же контекстный менеджер в нескольких вложенных операторах `with`.

Приведенный ниже код:

```python
with Indenter() as indent:
    indent.print('python')
    with indent:
        indent.print('beegeek')
        with indent:
            indent.print('stepik')
        indent.print('pygen')
    indent.print('bye-bye')
```

выводит:

```no-highlight
python
    beegeek
        stepik
    pygen
bye-bye
```

## 6.6 Декоратор @contextmanager
### Тема урока: декоратор @contextmanager

1. Декоратор `@contextmanager`
2. Обработка исключений при использовании декоратора `@contextmanager`
3. Примеры создания контекстных менеджеров с помощью декоратора `@contextmanager`

**Аннотация.** Урок посвящен созданию контекстных менеджеров с помощью декоратора `@contextmanager`.

### Декоратор @contextmanager

В прошлом уроке мы реализовывали собственные контекстные менеджеры путем создания классов, содержащих два магических метода `__enter__()` и `__exit__()` для поддержания протокола контекстного менеджера. Делать это было несложно, однако достаточно долго и не всегда удобно.

В Python создавать контекстные менеджеры можно намного проще с помощью декоратора `@contextmanager` из модуля `contextlib`. Декоратор `@contextmanager` позволяет создать контекстный менеджер на основе функции, автоматически предоставляя оба требуемых метода `__enter__()` и `__exit__()`.

Контекстный менеджер `CustomContextManager`, который просто выводит текст в методах `__enter__()` и `__exit__()`:

```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
```

с использованием декоратора `@contextmanager` можно переписать в виде:

```python
from contextlib import contextmanager

@contextmanager
def custom_context_manager():
    print('Вход в контекстный менеджер...')
    yield 'Python generation!'
    print('Выход из контекстного менеджера...')
```

Приведенный ниже код:

```python
with custom_context_manager() as manager:
    print(manager)
```

выводит:

```no-highlight
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
```

Как мы видим, код до оператора `yield` выполняется, когда поток выполнения входит в контекст и соответствует методу `__enter__()`. Значение, которое возвращает оператор `yield` является возвращаемым значением метода `__enter__()`. Наконец, код после оператора `yield` выполняется, когда поток выполнения выходит из контекста, что соответствует методу `__exit__()`.

### Обработка исключений внутри блока with

Важным моментом при написании контекстных менеджеров является обработка исключений, которые возбуждаются внутри блока `with`. Для обработки исключений при использовании контекстных менеджеров на основе классов, мы использовали метод `__exit__()`, который возвращает логический флаг (тип `bool`), указывающий на то, следует ли подавить возбужденное исключение.

Для обработки исключений в контекстных менеджерах на основе функций мы должны использовать конструкцию `try-except-finally`.

Контекстный менеджер `CustomContextManager`, который просто выводит текст в методах `__enter__()` и `__exit__()` и обрабатывает исключения типа `IndexError`:

```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        if isinstance(exc_value, IndexError):
            print(f'Тип возникшего исключения: {exc_type}')
            print(f'Текст исключения: {exc_value}')
            return True                                 # подавляем возбужденное исключение IndexError
        return False
```

с использованием декоратора `@contextmanager` можно переписать в виде:

```python
from contextlib import contextmanager

@contextmanager
def custom_context_manager():
    print('Вход в контекстный менеджер...')
    try:
        yield 'Python generation!'
    except IndexError as error:
        print(f'Тип возбужденного исключения: {type(error)}')
        print(f'Текст исключения: {error}')
    except:
        raise           # если исключение не планируется подавлять, оно должно быть возбуждено повторно
    finally:
        print('Выход из контекстного менеджера...')
```

Приведенный ниже код:

```python
with custom_context_manager() as manager:
    print(manager)
    print(manager[100])                                 # обращаемся по несуществующему индексу
```

выводит:

```no-highlight
Вход в контекстный менеджер...
Python generation!
Тип возбужденного исключения: <class 'IndexError'>
Текст исключения: string index out of range
Выход из контекстного менеджера...
```

Как мы видим, для обработки определенного типа исключения внутри блока `with` нужно добавить соответствующий блок `except <тип исключения>`, в котором нужным образом обработать возбужденное исключение, что соответствует инструкции `return True` метода `__exit__()`. В случае если возникшее исключение не требуется обрабатывать, оно должно быть возбуждено заново с помощью оператора `raise`, что соответствует инструкции `return False` метода `__exit__()`.

Прочитать о повторном возбуждении исключений с помощью оператора `raise` можно по [ссылке](https://stepik.org/lesson/640051/step/10?unit=636571).

### Примеры создания контекстных менеджеров

Перепишем созданные в прошлом уроке контекстные менеджеры с помощью декоратора `@contextmanager`.

**Пример 1.** Контекстный менеджер `Trace` выводит информацию перед входом в блок `with` и после выхода из блока `with`, включая информацию об исключении, если оно было возбуждено во время выполнения блока `with`.

```python
class Trace:
    def __enter__(self):
        print('Начало выполнения блока with')

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_value:
            print(f'Во время выполнения блока with возникло исключение {exc_value}')
        print('Конец выполнения блока with')
        return True                           # обрабатываем все типы исключений
```

С помощью декоратора `@contextmanager` контекстный менеджер `Trace` выглядит так:

```python
from contextlib import contextmanager

@contextmanager
def trace():
    print('Начало выполнения блока with')
    try:
        yield
    except Exception as error:
        print(f'Во время выполнения блока with возникло исключение {error}')
    finally:
        print('Конец выполнения блока with')
```

Приведенный ниже код:

```python
with trace():
    print('Python generation!')

print()

with trace():
    print('Python generation!')
    print(1 / 0)
```

выводит:

```no-highlight
Начало выполнения блока with
Python generation!
Конец выполнения блока with

Начало выполнения блока with
Python generation!
Во время выполнения блока with возникло исключение division by zero
Конец выполнения блока with
```

**Пример 2.** Контекстный менеджер `WritableTextFile` позволяет работать с открытыми для записи текстовыми файлами в кодировке `UTF-8`:

```python
class WritableTextFile:
    def __init__(self, path):
        self.path = path

    def __enter__(self):
        self.file = open(self.path, mode='w', encoding='utf-8')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()
```

С помощью декоратора `@contextmanager` контекстный менеджер `WritableTextFile` выглядит так:

```python
from contextlib import contextmanager

@contextmanager
def writable_text_file(path):
    file = open(path, mode='w', encoding='utf-8')
    yield file
    file.close()
```

Приведенный ниже код:

```python
with writable_text_file('output.txt') as file:
    file.write('Python generation!')
```

создает текстовый файл `output.txt` в кодировке `UTF-8` с содержимым `Python generation!`.

**Пример 3.** Контекстный менеджер `RedirectedStdout` **временно** перенаправляет стандартный вывод `sys.stdout` на некоторый файл на диске:

```python
import sys

class RedirectedStdout:
    def __init__(self, new_output):
        self.new_output = new_output

    def __enter__(self):
        self.standart_output = sys.stdout
        sys.stdout = self.new_output

    def __exit__(self, exc_type, exc_value, traceback):
        sys.stdout = self.standart_output 
```

С помощью декоратора `@contextmanager` контекстный менеджер `RedirectedStdout` выглядит так:

```python
import sys
from contextlib import contextmanager

@contextmanager
def redirected_stdout(new_output):
    standart_output = sys.stdout
    sys.stdout = new_output
    yield
    sys.stdout = standart_output
```

Приведенный ниже код:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    with redirected_stdout(file):
        print('Python generation!')
    print('Возврат к стандартному потоку вывода')
```

создает текстовый файл `output.txt` в кодировке `UTF-8` с содержимым `Python generation!`, а также выводит текст `Возврат к стандартному потоку вывода`.

**Пример 4.** Контекстный менеджер `Timer` позволяет измерять время выполнения блока кода:

```python
from time import perf_counter

class Timer:
    def __enter__(self):
        self.start = perf_counter()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.elapsed = perf_counter() - self.start
```

С помощью декоратора `@contextmanager` контекстный менеджер `Timer` выглядит так:

```python
from time import perf_counter
from contextlib import contextmanager

@contextmanager
def timer():
    start = perf_counter()
    yield
    end = perf_counter()
    elapsed = end - start
    print('Затраченное время:', elapsed)
```

Приведенный ниже код:

```python
from time import sleep

with timer():
    sleep(0.7)
    sleep(1.5)
```

выводит (время может отличаться):

```no-highlight
Затраченное время: 2.208050799788907
```

### Примечания

**Примечание 1.** Декоратор `@contextmanager` – элегантный и практически полезный инструмент, который сводит воедино три совершенно разных механизма Python: декоратор функции, генератор и оператор `with`.

**Примечание 2.** Обычно с помощью декоратора `@contextmanager` создают **относительно несложные** контекстные менеджеры.

**Примечание 3.** Функция, к которой применяется декоратор `@contextmanager`, обязательно должна иметь инструкцию `yield`, в противном случае при попытке воспользоваться реализованной функцией как контекстным менеджером будет возбуждено исключение.

Приведенный ниже код:

```python
from contextlib import contextmanager

@contextmanager
def greeter(name):
    print('Привет,', name)
    return name
    print('Пока,', name)
    
with greeter('Гвидо') as manager:
    print(manager)
```

выводит:

```no-highlight
Привет, Гвидо
```

а затем приводит к возбуждению исключения:

```no-highlight
TypeError: 'str' object is not an iterator
```

Аналогично приведенный ниже код:

```python
from contextlib import contextmanager

@contextmanager
def greeter(name):
    print('Привет,', name)
    print('Пока,', name)
    
with greeter('Гвидо') as manager:
    print(manager)
```

выводит:

```no-highlight
Привет, Гвидо
Пока, Гвидо
```

а затем приводит к возбуждению исключения:

```no-highlight
TypeError: 'NoneType' object is not an iterator
```

**Примечание 4.** Контекстные менеджеры созданные с помощью декоратора `@contextmanager` являются **одноразовыми**, их нужно создавать заново каждый раз, когда мы хотим их использовать. Попытка повторного использования такого контекстного менеджера приводит к возбуждению исключения `AttributeError`.

**Примечание 5.** Процесс создания контекстных менеджеров на основе функций похож на процесс создания итераторов с помощью генераторных функций. Подробнее о генераторных функциях можно почитать по [ссылке](https://stepik.org/lesson/640048/step/1?unit=636568).

**Примечание 6.** При использовании контекстных менеджеров на основе классов мы могли достаточно легко передавать значения из метода `__enter__()` в тело блока `with`. Для этого нужно было использовать атрибуты объекта, возвращаемого методом `__enter__()`. При использовании контекстных менеджеров на основе функций мы можем добиться аналогичного поведения, если будем возвращать лямбда-функцию (см. [замыкания](https://stepik.org/lesson/651459/step/1?unit=648165)).

Приведенный ниже код:

```python
from time import perf_counter, sleep
from contextlib import contextmanager

@contextmanager
def timer():
    start = perf_counter()
    end = 0
    yield lambda : (start, end)
    end = perf_counter()

with timer() as manager:
    sleep(1.4)
    print(manager())            # вызов внутри блока with

print(manager())                # вызов после блока with
start, end = manager()
print('Затраченное время:', end - start)
```

выводит (время может отличаться):

```no-highlight
(2127754.9660813, 0)
(2127754.9660813, 2127756.3803388)
Затраченное время: 1.414257500320673
```

**Примечание 7.** Внутри одного блока `with` могут использоваться несколько контекстных менеджеров.

Приведенный ниже код:

```python
from contextlib import contextmanager

@contextmanager
def greeter(name):
    print('Привет,', name)
    yield name
    print('Пока,', name)
    
with greeter('Илон') as manager1, greeter('Гвидо') as manager2, greeter('Хидео') as manager3:
    print(manager1, manager2, manager3)
```

выводит:

```no-highlight
Привет, Илон
Привет, Гвидо
Привет, Хидео
Илон Гвидо Хидео
Пока, Хидео
Пока, Гвидо
Пока, Илон
```

Обратите внимание, на порядок, в котором закрываются контекстные менеджеры: сперва закрывается третий, затем второй, и только потом первый. Если внутри блока `with` будет возбуждено исключение, этот порядок может быть важен, поскольку любой контекстный менеджер может подавить возбужденное исключение, и тогда остальные менеджеры даже не получат информацию об этом.

## 6.7 Контекстные менеджеры модуля contextlib
### Тема урока: контекстные менеджеры модуля contextlib

1. Контекстный менеджер `closing`
2. Контекстный менеджер `suppress`
3. Контекстный менеджер `nullcontext`
4. Контекстный менеджер `redirect_stdout`
5. Контекстный менеджер `ExitStack`

**Аннотация.** Урок посвящен контекстным менеджерам модуля `contextlib`.

### Контекстный менеджер closing

Функция `closing()` используется для построения контекстных менеджеров из объектов, которые предоставляют метод `close()`, но не реализуют протокол контекстного менеджера (отсутствуют методы `__enter__()` и `__exit__()`).

Примерный код функции `closing()`:

```python
from contextlib import contextmanager

@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()
```

Приведенный ниже код:

```python
from contextlib import closing

class Cat:
    def __init__(self, name):
        self.name = name
        
    def __str__(self):
        return self.name

    def close(self):
        print('Пока,', self.name)
    

with closing(Cat('Кемаль')) as cat:
    print('Привет,', cat)
```

выводит:

```no-highlight
Привет, Кемаль
Пока, Кемаль
```

Метод `close()` объекта `cat` будет вызываться всегда, даже если в блоке `with` возникает ошибка.

В случае отсутствия метода `close()` у объекта возбуждается исключение `AttributeError`.

### Контекстный менеджер suppress

Функция `suppress()` используется для построения контекстных менеджеров, которые игнорируют заданные типы исключений.

Примерный код функции `suppress()`:

```python
from contextlib import contextmanager

@contextmanager
def suppress(*exceptions):
    try:
        yield
    except Exception as error:
        if type(error) not in exceptions:
            raise
```

Приведенный ниже код:

```python
from contextlib import suppress

with suppress(ValueError):
    num = int('python')

print('beegeek')

with suppress(TypeError, ZeroDivisionError):
    num = 1 / 0

print('pygen')
```

выводит:

```no-highlight
beegeek
pygen
```

Как и с любым другим механизмом, который полностью подавляет исключения, этот контекстный менеджер следует использовать только для покрытия специфических ошибок, когда точно известно, что продолжение работы программы без вывода сообщений будет корректным.

Контекстный менеджер, возвращаемый функцией `suppress()`, является реентерабельным.

### Контекстный менеджер nullcontext

Функция `nullcontext()` используется для построения пустых контекстных менеджеров, которые ничего не делают.

Примерный код функции `nullcontext()`:

```python
from contextlib import contextmanager

@contextmanager
def nullcontext(enter_result=None):
    yield enter_result
```

Приведенный ниже код:

```python
from contextlib import nullcontext

with nullcontext(2077) as manager:
    print(manager)

with nullcontext('pygen') as manager:
    print(manager)
```

выводит:

```no-highlight
2077
pygen
```

Функцию `nullcontext()` удобно использовать для создания необязательного контекстного менеджера, например:

```python
from contextlib import suppress, nullcontext

def my_function(ignore_exceptions=False):
    if ignore_exceptions:
        manager = suppress(Exception)           # игнорируем исключения
    else:
        manager = nullcontext()                 # не игнорируем исключения
    
    with manager:
        # код
```

### Контекстный менеджер redirect_stdout

Функция `redirect_stdout()` используется для построения контекстных менеджеров, которые временно перенаправляют поток `sys.stdout` в указанный файлоподобный объект.

Приведенный ниже код:

```python
from contextlib import redirect_stdout

with open('output.txt', mode='w', encoding='utf-8') as file:
    with redirect_stdout(file):
        print('Python generation!')
        help(len)
```

создает файл `output.txt` с содержимым:

```no-highlight
Python generation!
Help on built-in function len in module builtins:

len(obj, /)
    Return the number of items in a container.
```

### Примечания

**Примечание 1.** Официальная документация модуля `contextlib` доступна по [ссылке](https://docs.python.org/3/library/contextlib.html).
### Контекстный менеджер ExitStack

Контекстный менеджер `ExitStack` предназначен для объединения переменного числа контекстных менеджеров. Он удобен, когда заранее неизвестно, какое количество менеджеров контекста нужно обработать, например, в случае, когда одновременно открывается большое количество файлов из некоторого списка.

Сам менеджер `ExitStack` представляет собой так называемую последовательность обратных вызовов. При входе в очередной контекстный менеджер его метод `__exit__()` добавляется в конец последовательности, но не вызывается. После завершения блока `with` менеджер `ExitStack` вызывает с конца все добавленные в последовательность методы `__exit__()`, то есть сперва вызывается последний добавленный метод, затем предпоследний, и так далее.

#### Метод enter_context()

Метод `enter_context()` менеджера `ExitStack` принимает в качестве аргумента контекстный менеджер, входит в него и добавляет его метод `__exit__()` в конец последовательности обратных вызовов, но не вызывает.

Приведенный ниже код:

```python
from contextlib import ExitStack

class Greeter:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print('Привет,', self.name)
        return self.name
    
    def __exit__(self, *args, **kwargs):
        print('Пока,', self.name)


with ExitStack() as stack:
    stack.enter_context(Greeter('Гвидо'))
    stack.enter_context(Greeter('Трей'))
    print('Завершение блока with')
```

выводит:

```no-highlight
Привет, Гвидо
Привет, Трей
Завершение блока with
Пока, Трей
Пока, Гвидо
```

Возвращаемым значением метода `enter_context()` является возвращаемое значение метода `__enter__()` переданного контекстного менеджера.

Приведенный ниже код:

```python
from contextlib import ExitStack

class Greeter:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print('Привет,', self.name)
        return self.name
    
    def __exit__(self, *args, **kwargs):
        print('Пока,', self.name)


with ExitStack() as stack:
    name1 = stack.enter_context(Greeter('Гвидо'))
    name2 = stack.enter_context(Greeter('Трей'))
    print(name1, name2)
```

выводит:

```no-highlight
Привет, Гвидо
Привет, Трей
Гвидо Трей
Пока, Трей
Пока, Гвидо
```

#### Метод push()

Метод `push()` менеджера `ExitStack` принимает в качестве аргумента контекстный менеджер и добавляет его метод `__exit__()` в конец последовательности обратных вызовов, но не вызывает.

Приведенный ниже код:

```python
from contextlib import ExitStack

class Greeter:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print('Привет,', self.name)
        return self.name
    
    def __exit__(self, *args, **kwargs):
        print('Пока,', self.name)


with ExitStack() as stack:
    stack.push(Greeter('Гвидо'))
    stack.push(Greeter('Трей'))
    print('Завершение блока with')
```

выводит:

```no-highlight
Завершение блока with
Пока, Трей
Пока, Гвидо
```

Обратите внимание, что метод `push()` не выполняет вход в переданный контекстный менеджер.

#### Метод callback()

В последовательность обратных вызовов можно добавлять не только методы `__exit__()` контекстных менеджеров, но и обыкновенные функции. Аналогично методам `__exit__()` эти функции будут вызваны после завершения блока `with`.

Метод `callback()` менеджера `ExitStack` принимает в качестве аргумента функцию, любой набор из позиционных или именованных аргументов для этой функции, и добавляет эту функцию в конец последовательности обратных вызовов, но не вызывает.

Приведенный ниже код:

```python
from contextlib import ExitStack

def goodbye(name):
    print('Пока,', name)

with ExitStack() as stack:
    stack.callback(goodbye, 'Гвидо')
    stack.callback(goodbye, name='Трей')
    print('Завершение блока with')
```

выводит:

```no-highlight
Завершение блока with
Пока, Трей
Пока, Гвидо
```

#### Метод close()

Метод `close()` менеджера `ExitStack` немедленно опустошает последовательность обратных вызовов, вызывая с конца все имеющиеся в нем методы `__exit__()` и функции.

Приведенный ниже код:

```python
from contextlib import ExitStack

class Greeter:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print('Привет,', self.name)
        return self.name
    
    def __exit__(self, *args, **kwargs):
        print('Пока,', self.name)


def goodbye(name):
    print('Пока,', name)

with ExitStack() as stack:
    stack.enter_context(Greeter('Гвидо'))
    stack.push(Greeter('Трей'))
    stack.callback(goodbye, 'Алан')
    stack.close()
    print('Завершение блока with')
```

выводит:

```no-highlight
Привет, Гвидо
Пока, Алан
Пока, Трей
Пока, Гвидо
Завершение блока with
```

#### Метод pop_all()

Метод `pop_all()` переносит последовательность обратных вызовов в новый контекстный менеджер `ExitStack` и возвращает его. 

Приведенный ниже код:

```python
from contextlib import ExitStack

class Greeter:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print('Привет,', self.name)
        return self.name
    
    def __exit__(self, *args, **kwargs):
        print('Пока,', self.name)


with ExitStack() as stack:
    stack.enter_context(Greeter('Гвидо'))
    stack.enter_context(Greeter('Трей'))
    stack.enter_context(Greeter('Алан'))
    new_stack = stack.pop_all()
    print('Завершение блока with')
```

выводит:

```no-highlight
Привет, Гвидо
Привет, Трей
Привет, Алан
Завершение блока with
```

Обратите внимание, что исходная последовательность обратных вызовов становится пустой, поэтому после завершения блока `with` не выполняется ни одного вызова метода `__exit__()`. Теперь все они находятся в новом контекстном менеджере, и для их вызова необходимо воспользоваться именно им.

 Приведенный ниже код:

```python
from contextlib import ExitStack

class Greeter:
    def __init__(self, name):
        self.name = name
        
    def __enter__(self):
        print('Привет,', self.name)
        return self.name
    
    def __exit__(self, *args, **kwargs):
        print('Пока,', self.name)


with ExitStack() as stack:
    stack.enter_context(Greeter('Гвидо'))
    stack.enter_context(Greeter('Трей'))
    stack.enter_context(Greeter('Алан'))
    new_stack = stack.pop_all()
    print('Завершение блока with')
    
new_stack.close()
```

выводит:

```no-highlight
Привет, Гвидо
Привет, Трей
Привет, Алан
Завершение блока with
Пока, Алан
Пока, Трей
Пока, Гвидо
```

## 6.8 Протокол дескрипторов
### Тема урока: протокол дескрипторов

1. Дескрипторы
2. Протокол дескрипторов
3. Магические методы `__get__(), __set__()` и `__delete__()`
4. Магический метод `__set_name__()`
5. Цепочка поиска атрибутов

**Аннотация.** Урок посвящен протоколу дескрипторов.

### Дескрипторы

В Python существует три варианта доступа к атрибуту:

- получение значения атрибута
- изменение значения атрибута
- удаление атрибута

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)                            # получаем значение атрибута name

cat.name = 'Роджер'                        # изменяем значение атрибута name
print(cat.name)

del cat.name                               # удаляем атрибут name
print(hasattr(cat, 'name'))
```

выводит:

```no-highlight
Кемаль
Роджер
False
```

Python позволяет перехватить вышеупомянутые попытки доступа к атрибуту и переопределить связанное с этим доступом поведение. Мы уже сталкивались с подобным, когда говорили о свойствах — объектах типа `property` — при доступе к которым происходит вызов соответствующего метода. Свойства были полезны тем, что внутри методов, вызываемых при доступе к ним, мы могли добавлять дополнительную логику, например, проверку на корректность устанавливаемого значения.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Получение значения свойства name')
        return self._name

    @name.setter
    def name(self, value):
        print('Изменение значения свойства name')
        if isinstance(value, str) and len(value) > 0:
            self._name = value
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):
        print('Удаление свойства name')
        del self._name 


cat = Cat('Кемаль')

cat.name                                   # получаем значение свойства name
cat.name = 'Роджер'                        # изменяем значение свойства name
del cat.name                               # удаляем свойство name
```

выводит:

```no-highlight
Получение значения свойства name
Изменение значения свойства name
Удаление свойства name
```

Стандартное поведение при доступе к атрибуту — это получение, установка и удаление атрибута из словаря объекта `__dict__`. Однако при аналогичном доступе к свойству происходит вызов одного из методов. Это реализуется через протокол дескрипторов. **Дескриптором** же называют объект со связанным поведением, то есть такой объект, чьё поведение при доступе к нему как к атрибуту переопределяется методами протокола дескрипторов: `__get__(), __set__()` и `__delete__()`. Если хотя бы один из этих методов определён для объекта, то он считается дескриптором.

Благодаря тому, что для свойств определены методы протокола дескрипторов, их поведение гораздо более функционально, нежели поведение обычных атрибутов. Сами же свойства, по сути, являются обычными дескрипторами. 

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Получение значения атрибута name')
        return self._name

    @name.setter
    def name(self, value):
        print('Изменение значения атрибута name')
        if isinstance(value, str) and len(value) > 0:
            self._name = value
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):
        print('Удаление атрибута name')
        del self._name 


name_property = Cat.name

print(hasattr(name_property, '__get__'))
print(hasattr(name_property, '__set__'))
print(hasattr(name_property, '__delete__'))   
```

выводит:

```no-highlight
True
True
True
```

Методы `__get__(), __set__()` и `__delete__()` можно вызывать и напрямую через сами дескрипторы, в нашем случае через свойство.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Получение значения атрибута name')
        return self._name

    @name.setter
    def name(self, value):
        print('Изменение значения атрибута name')
        if isinstance(value, str) and len(value) > 0:
            self._name = value
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):
        print('Удаление атрибута name')
        del self._name 


cat = Cat('Кемаль')
name_property = Cat.name                   # свойство name, он же объект типа property, он же дескриптор

name_property.__get__(cat, Cat)            # равнозначно cat.name
name_property.__set__(cat, 'Роджер')       # равнозначно cat.name = 'Роджер'
name_property.__delete__(cat)              # равнозначно del cat.name
```

выводит:

```no-highlight
Получение значения атрибута name
Изменение значения атрибута name
Удаление атрибута name
```

Обратите внимание на аргументы, принимаемые методами протокола дескрипторов:

- метод `__get__()` принимает экземпляр класса и его класс
- метод `__set__()` принимает экземпляр класса и устанавливаемое значение
- метод `__delete__()` принимает лишь экземпляр класса

### Протокол дескрипторов

Дескриптор — это объект, для которого определены методы протокола дескриптора `__get__(), __set__()` и `__delete__()`, реализующие поведение при доступе к объекту как к атрибуту. При получении значения дескриптора вызывается метод `__get__()`, при изменении значения вызывается метод `__set__()`, а при удалении вызывается метод `__delete__()`. Определяя в классе данные методы, мы можем создавать собственные дескрипторы.

Вернемся к классу `Cat`, описывающему кошку, экземпляры которого имеют атрибут `name`, содержащий имя:

```python
class Cat:
    def __init__(self, name):
        self.name = name
```

Под корректным именем мы понимаем любую непустую строку, поэтому хотим, чтобы при его установке или изменении присутствовала проверка на корректность. Мы можем решить данную проблему с помощью функции `property()`, однако теперь попробуем сделать это с помощью собственного дескриптора `NonEmptyString`:

```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибут не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]
```

Рассмотрим методы дескриптора. Метод `__init__()` имеет параметр `attr`, целью которого является получение имени, за которым будет закреплен дескриптор. Метод `__get__()` возвращает из словаря`__dict__` объекта `obj` значение атрибута `attr`, если он там есть. То есть при обращении к дескриптору как к атрибуту мы будем получать значение необходимого атрибута объекта. Метод `__set__()` изменяет значение атрибута `attr` в словаре`__dict__` объекта `obj`, предварительно проверяя устанавливаемое значение на корректность. То есть при изменении значения дескриптора с помощью оператора присваивания `=` мы будем изменять значение атрибута объекта. Метод `__delete__()` удаляет из словаря объекта атрибут `attr`.

В методах протокола дескрипторов необходимо напрямую обращаться к словарю объекта `__dict__`, чтобы избежать исключения `RecursionError`, так как иные обращения к атрибуту будут перехватываться протоколом дескрипторов.

Приведенный ниже код:

```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString('name')

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)

del cat.name
print(hasattr(cat, 'name'))
```

выводит:

```no-highlight
Кемаль
Роджер
False
```

Для большей наглядности мы можем добавить в методы протокола дескриптора вывод некоторого сообщения, чтобы проследить за тем, когда эти методы вызываются.

Приведенный ниже код:

```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        print('Вызов метода __get__()')
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        print('Вызов метода __set__()')
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        print('Вызов метода __delete__()')
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString('name')

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

cat.name
cat.name = 'Роджер'
del cat.name
```

выводит:

```no-highlight
Вызов метода __set__()
Вызов метода __get__()
Вызов метода __set__()
Вызов метода __delete__()
```

Обратите внимание на первый вызов метода `__set__()`, он происходит внутри метода `__init__()` при инициализации экземпляра класса. В строке `self.name = name` выполняется обращение к дескриптору `name`, что влечет за собой вызов метода `__set__()`, уже внутри которого объекту устанавливается атрибут `name` со значением `Кемаль`. Важно понимать, что в строке `self.name = name` мы обращаемся именно к дескриптору и вызываем его методы, а не просто устанавливаем объекту новый атрибут.

Также следует отметить, что дескрипторы являются атрибутами класса и создаются единожды при определении класса. Это значит, что все экземпляры класса используют один и тот же дескриптор. Поэтому дескрипторы внутренне не хранят значения атрибутов, но они хранят имена атрибутов, с помощью которых могут получить доступ к значениям этих атрибутов.

Свойства, как и другие дескрипторы, являются атрибутами класса.

### Магический метод __set_name__()

Мы рассмотрели способ создания собственного дескриптора. Инициализатор нашего дескриптора принимал один обязательный аргумент — имя атрибута, за которым будет закреплен дескриптор. Однако практически всегда такое имя атрибута совпадает с именем переменной, которой присваивается дескриптор. Магический метод `__set_name__()`, который появился в Python 3.6, позволяет неявно использовать имя переменной в качестве имени атрибута, за которым будет закреплен дескриптор.

Приведенный ниже код:

```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString()                # строка 'name' автоматически передается в метод __set_name__()

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)

del cat.name
print(hasattr(cat, 'name'))
```

выводит:

```no-highlight
Кемаль
Роджер
False
```

Обратите внимание на аргументы, передаваемые в метод `__set_name__()`, ими являются класс, в котором создается дескриптор, и имя переменной, которой присваивается дескриптор.

Приведенный ниже код:

```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        print(cls)
        print(attr)
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString()

    def __init__(self, name):
        self.name = name
```

выводит:

```no-highlight
<class '__main__.Cat'>
name
```

### Цепочка поиска атрибутов

Дескрипторы можно дополнительно разделить на **дескрипторы данных** (data descriptor) и **дескрипторы не-данных** (non-data descriptor). Если для дескриптора определен лишь метод `__get__()`, то это дескриптор не-данных. Такой дескриптор доступен только для чтения. Если для дескриптора дополнительно определен хотя бы один из методов `__set__()` и `__delete__()`, то это дескриптор данных. Различие между дескрипторами данных и не-данных не только в количестве определенных методов, но и в приоритете их поиска при доступе.

По умолчанию при обращении к атрибуту экземпляра класса происходит его поиск сначала в словаре `__dict__` самого экземпляра, а затем в словаре его класса. Однако мы могли заметить, что используя одно и то же имя для атрибута экземпляра класса и для дескриптора, являющегося атрибутом класса, при обращении по этому имени происходит обращение именно к дескриптору.

Приведенный ниже код:

```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        print('Вызов метода __get__()')
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')

class Cat:
    name = NonEmptyString()

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)
print(cat.__dict__)
print(Cat.__dict__)
```

выводит:

```no-highlight
Вызов метода __get__()
Кемаль
{'name': 'Кемаль'}
{'__module__': '__main__', 'name': <__main__.NonEmptyString object at 0x000001CF9B207BB0>, '__init__': <function Cat.__init__ at 0x000001CF9B22EF80>, '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>, '__doc__': None}
```

Дело в том, что при доступе к атрибуту цепочка его поиска несколько сложнее. Рассмотрим пошагово, как Python ищет необходимый атрибут, когда происходит попытка обратиться к нему:

- сперва Python пробует вернуть возвращаемое значение метода `__get__()` дескриптора данных, имеющего то же имя, что и искомый атрибут
- если это не удается, Python пробует вернуть значение по ключу, имеющему то же имя, что и искомый атрибут, из словаря `__dict__` экземпляра класса
- если это не удается, Python пробует вернуть возвращаемое значение метода `__get__()` дескриптора не-данных, имеющего то же имя, что и искомый атрибут
- если это не удается, Python пробует вернуть значение по ключу, имеющему то же имя, что и искомый атрибут, из словаря `__dict__` класса
- если это не удается, то предыдущие шаги повторяются для всех родительских классов
- если это не удается, Python возбуждает исключение `AttributeError`

При создании дескриптора, доступного только для чтения, рекомендуется явно определять метод `__set__()`, при вызове которого возбуждается исключение с сообщением о том, что значение дескриптора изменить нельзя. Это необходимо для того, чтобы дескриптор имел необходимый приоритет при доступе к нему.

### Примечания

**Примечание 1.** Обращение к дескриптору через класс приводит к вызову метода `__get__()` с автоматической передачей в качестве экземпляра класса значения `None`.

Приведенный ниже код:

```python
class Descriptor:
    def __get__(self, obj, cls):
        print('Вызова метода __get__()')
        print(obj, cls)

class Cat:
    name = Descriptor()


Cat.name
```

выводит:

```no-highlight
Вызова метода __get__()
None <class '__main__.Cat'>
```

Для корректной работы дескриптора рекомендуется всегда проверять, какое обращение происходит к дескриптору — через класс или через экземпляр класса. Если обращение происходит через экземпляр класса, нужно вернуть значение необходимого атрибута, если же обращение происходит через класс, нужно вернуть сам дескриптор.

Приведенный ниже код:

```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        self.attr = attr

    def __get__(self, obj, cls):
        if obj is None:                    # проверка на то, как осуществляется обращение
            return self
        if self.attr in obj.__dict__:
            return obj.__dict__[self.attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self.attr] = value
        else:
            raise ValueError('Некорректное значение')

class Cat:
    name = NonEmptyString()

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)
print(Cat.name)
```

выводит (адрес может отличаться):

```no-highlight
Кемаль
<__main__.NonEmptyString object at 0x000001B0F5A134C0>
```

В то время как приведенный ниже код:

```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        self.attr = attr

    def __get__(self, obj, cls):
        if self.attr in obj.__dict__:
            return obj.__dict__[self.attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self.attr] = value
        else:
            raise ValueError('Некорректное значение')

class Cat:
    name = NonEmptyString()

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)
print(Cat.name)
```

приводит к возбуждению исключения, так как при обращении к дескриптору через класс в метод `__get__()` в качестве значения параметра `obj` передается значение `None`, которое никак не обрабатывается, что приводит к попытке получить значение атрибута `__dict__` у этого значения `None`:

```no-highlight
AttributeError: 'NoneType' object has no attribute '__dict__'
```

**Примечание 2.** Исходный код функции `property()` доступен по [ссылке](https://docs.python.org/3/howto/descriptor.html#properties).

**Примечание 3.** Хорошие статьи про дескрипторы доступны по [ссылке](https://realpython.com/python-descriptors/) и [ссылке](https://habr.com/ru/post/122082/).

# 7. Наследование и полиморфизм
## 7.1 Наследование. Часть 1
### Тема урока: наследование

1. Введение в наследование
2. Наследование в Python
3. Определение и переопределение атрибутов и методов
4. Неявное наследование, класс `object`
5. Многоуровневое наследование

**Аннотация.** Урок посвящен наследованию в Python.

### Введение в наследование

Одной из базовых концепций объектно-ориентированного программирования является наследование. Наследование — это механизм получения новых классов из уже существующих. Класс, созданный путем наследования, приобретает все свойства (атрибуты) и поведение (методы) того класса, от которого был наследован.

Класс, от которого наследуется класс, называется **родительским** или **базовым классом**. Класс, который наследуется от родительского (базового) класса, называется **дочерним классом** или **наследником**.

Дочерние классы также называют **подклассами**, а родительские классы — **суперклассами**.

Мы можем рассмотреть наследование с точки зрения биологии, например, представив ребенка, наследующего определенные черты от своего родителя. Ребенок может унаследовать рост и цвет глаз родителя, также дети могут носить одну и ту же фамилию со своими родителями.

### Наследование в Python

Родительские классы выступают в качестве шаблонов для дочерних классов. Родительские классы позволяют создавать дочерние классы посредством наследования без необходимости каждый раз писать один и тот же код заново. Другими словами, каждый дочерний класс может использовать методы и атрибуты родительского класса.

Например, мы можем иметь родительский класс, описывающий банковский счет, и дочерние классы, описывающие личный счет и бизнес счет. Многие методы между личными и бизнес счетами будут похожи, например, методы снятия и внесения денег, поэтому они могут принадлежать родительскому классу. Подклассы же могут дополнительно иметь собственные специфические методы.

Синтаксис наследования в Python достаточно прост. Для того чтобы создать дочерний класс, нам необходимо при его определении в скобках указать родительский класс:

```python
class ParentClass:                         # родительский класс
    pass

class ChildClass(ParentClass):             # дочерний класс
    pass
```

В качестве дальнейших примеров рассмотрим родительский класс `Animal`, описывающий животное, и дочерний класс `Cat`, описывающий кошку:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name                   # имя животного
        self.age = age                     # возраст животного

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    pass
```

В классе `Animal` определены методы `__init__()` и `sleep()`, в то время как класс `Cat` является пустым. Но поскольку класс `Cat` является подклассом класса `Animal`, он наследует как метод `__init__()`, так и метод `sleep()`. Это означает, что экземпляры класса `Cat` могут свободно использовать данные методы.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    pass

animal = Animal('Роджер', 2)
cat = Cat('Кемаль', 1)

print(animal.name, animal.age)
print(animal.sleep())
print(cat.name, cat.age)
print(cat.sleep())
```

выводит:

```no-highlight
Роджер 2
Роджер спит zZ
Кемаль 1
Кемаль спит zZ
```

Так как класс `Cat` использует метод `__init__()` класса `Animal`, то процесс создания экземпляров класса `Cat` совпадает с процессом создания экземпляров класса `Animal`. По этой же причине экземпляры дочернего класса, как и экземпляры родительского класса, имеют атрибуты `name` и `age`.

### Определение и переопределение методов

Конечно, на практике дочерние классы не бывают пустыми, в них могут быть определены как собственные новые методы, так и переопределены методы родительского класса. Под переопределением метода родительского класса подразумевается определение метода в дочернем классе, имеющего то же имя, что и метод родительского класса. Например, определив в классе `Cat` метод `sleep()`, мы переопределим одноименный родительский метод.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def sleep(self):
        return f'{self.name} очень крепко спит zZ'


animal = Animal('Роджер', 2)
cat = Cat('Кемаль', 1)

print(animal.sleep())
print(cat.sleep())
```

выводит:

```python
Роджер спит zZ
Кемаль очень крепко спит zZ
```

Как мы видим, для экземпляров класса `Cat` используется метод `sleep()`, определенный в дочернем классе, а не в родительском. Аналогичным образом мы можем переопределить метод `__init__()`, например, если при создании экземпляров класса хотим указать дополнительные данные.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def __init__(self, name, age, eyecolor):
        self.name = name
        self.age = age
        self.eyecolor = eyecolor

    def sleep(self):
        return f'{self.name} очень крепко спит zZ'


cat = Cat('Кемаль', 1, 'желтый')

print(cat.name)
print(cat.age)
print(cat.eyecolor)
```

выводит:

```no-highlight
Кемаль
1
желтый
```

В примере выше в инициализаторе класса `Cat` мы дублируем строки с добавлением атрибутов `name` и `age`, которые аналогичным образом добавляются в инициализаторе класса `Animal`. Во избежание дублирования кода лучшим решением будет воспользоваться инициализатором родительского класса в инициализаторе дочернего класса.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def __init__(self, name, age, eyecolor):
        Animal.__init__(self, name, age)                   # вызываем инициализатор родительского класса
        self.eyecolor = eyecolor

    def sleep(self):
        return f'{self.name} очень крепко спит zZ'


cat = Cat('Кемаль', 1, 'желтый')

print(cat.name)
print(cat.age)
print(cat.eyecolor)
```

выводит:

```no-highlight
Кемаль
1
желтый
```

Помимо переопределения какого-либо родительского метода, мы также можем определить в дочернем классе дополнительный метод.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def __init__(self, name, age, eyecolor):
        Animal.__init__(self, name, age)                   # вызываем инициализатор родительского класса
        self.eyecolor = eyecolor

    def sleep(self):
        return f'{self.name} очень крепко спит zZ'

    def jump(self):
        return f'{self.name} прыгает!'


cat = Cat('Кемаль', 1, 'желтый')

print(cat.jump())
```

выводит:

```no-highlight
Кемаль прыгает!
```

Обратите внимание, что метод, определенный в дочернем классе, не доступен в родительском классе.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def __init__(self, name, age, eyecolor):
        Animal.__init__(self, name, age)                   # вызываем инициализатор родительского класса
        self.eyecolor = eyecolor

    def sleep(self):
        return f'{self.name} очень крепко спит zZ'

    def jump(self):
        return f'{self.name} прыгает!'


animal = Animal('Роджер', 1)

print(animal.jump())
```

выводит:

```no-highlight
AttributeError: 'Animal' object has no attribute 'jump'
```

На рассмотренных выше примерах с переопределением методов и созданием дополнительных мы можем заметить, как происходит поиск метода при обращении к нему: сперва он ищется в исходном классе, а затем, если не находится, в родительском.

### Наследование атрибутов

В определении наследования, данном ранее, было сказано, что дочерний класс приобретает все атрибуты и методы родительского класса. До этого момента мы рассматривали только наследование методов, однако аналогичным образом ведут себя и атрибуты. Дочерний класс может их как унаследовать, так и переопределить.

Приведенный ниже код:

```python
class Animal:
    en_name = 'animal'
    ru_name = 'животное'

class Cat(Animal):                         # наследует атрибуты родительского класса
    pass

class Dog(Animal):                         # переопределяет атрибуты родительского класса
    en_name = 'dog'
    ru_name = 'собака'


print(Cat.en_name)
print(Cat.ru_name)
print(Dog.en_name)
print(Dog.ru_name)
```

выводит:

```python
animal
животное
dog
собака
```

В примере выше класс `Cat` наследует атрибуты `en_name` и `ru_name` родительского класса `Animal`, в то время как класс `Dog` их переопределяет. Важно понимать, что класс `Cat` использует именно атрибуты класса `Animal`, а не создает их копии. То есть если в классе `Animal` их значения изменятся, это отразится и на классе `Cat`. Класс `Dog`, в свою очередь, переопределяет эти атрибуты и не зависит от изменений их значений в родительском классе.

Приведенный ниже код:

```python
class Animal:
    en_name = 'animal'
    ru_name = 'животное'

class Cat(Animal):
    pass

class Dog(Animal):
    en_name = 'dog'
    ru_name = 'собака'


Animal.en_name = 'Animal'
Animal.ru_name = 'Животное'

print(Cat.en_name)
print(Cat.ru_name)
print(Dog.en_name)
print(Dog.ru_name)
```

выводит:

```no-highlight
Animal
Животное
dog
собака
```

### Неявное наследование, класс object

Когда мы только начинали знакомство с классами, мы могли обратить внимание, что создаваемые нами пустые классы на самом деле не полностью пусты и по умолчанию обладают определенным функционалом. Дело в том, что все классы в Python являются наследниками класса `object`.

Приведенный ниже код:

```python
class MyClass:
   pass


print(dir(MyClass()))
print(dir(object()))
```

выводит:

```no-highlight
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
```

Как мы видим, списки атрибутов и методов экземпляров нашего пустого класса и класса `object` практически одинаковы, лишь с тем различием, что экземпляр класса `MyClass` имеет три дополнительных атрибута в виде `__dict__, __module__` и `__weakref__`.

Так как любой класс в Python неявно наследуется от класса `object`, определения классов `class MyClass(object)` и `class MyClass` полностью равнозначны.

### Многоуровневое наследование

Факт неявного наследования каждого класса от класса `object` позволяет сделать вывод, что с помощью наследования мы можем выстраивать иерархии классов, то есть, например, класс `C` может быть наследником класса `B`, который, в свою очередь, является наследником класса `A`: 

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass
```

![](https://ucarecdn.com/83df7aa9-9e84-4f2c-8a23-23ca72be0e36/)

Такое наследование называется **многоуровневым**. В данном случае класс `C` унаследует как атрибуты и методы класса `B`, так и класса `A`.

Приведенный ниже код:

```python
class A:
    def method_A(self):
        print('Метод класса A')

class B(A):
    def method_B(self):
        print('Метод класса B')

class C(B):
    pass


c = C()

c.method_A()
c.method_B()
```

выводит:

```no-highlight
Метод класса A
Метод класса B
```

Однако нужно иметь в виду, что если класс `B` переопределит некоторые методы класса `A`, то классу `C` будет предоставлены именно переопределенные их версии.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')

class B(A):
    def method(self):
        print('Метод класса B')

class C(B):
    pass


c = C()

c.method()
```

выводит:

```no-highlight
Метод класса B
```

Здесь мы уже можем окончательно понять, что при обращении к методу сперва он ищется в исходном классе, а затем во всей иерархии классов снизу вверх. Например, при обращении к методу класса `C` цепочка поиска будет следующей:

```no-highlight
C --> B --> A --> object
```

Не забывайте, что все классы являются наследниками класса `object`, поэтому он обязательно присутствует в любой иерархии.

### Примечания

**Примечание 1.** Атрибут класса `__base__` позволяет получить родительский класс текущего класса.

Приведенный ниже код:

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass


print(A.__base__)
print(B.__base__)
print(C.__base__)
```

выводит:

```no-highlight
<class 'object'>
<class '__main__.A'>
<class '__main__.B'>
```

**Примечание 2.** Функция `issubclass()` позволяет проверить, является ли класс прямым или косвенным наследником другого класса.

Приведенный ниже код:

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass


print(issubclass(A, A))
print(issubclass(A, C))
print(issubclass(B, A))
print(issubclass(B, C))
print(issubclass(C, A))
print(issubclass(C, B))
```

выводит:

```no-highlight
True
False
True
False
True
True
```

Обратите внимание, что любой класс является наследником самого себя.

**Примечание 3.** Функция `isinstance()` позволяет проверить, является ли объект прямым или косвенным экземпляром некоторого класса.

Приведенный ниже код:

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass


obj = C()

print(isinstance(obj, A))
print(isinstance(obj, B))
print(isinstance(obj, C))
```

выводит:

```no-highlight
True
True
True
```

Так как данная функция при проверке учитывает иерархию классов, при проверке на принадлежность классу рекомендуется использовать именно ее.

**Примечание 4.** Интересной особенностью является тот факт, что класс `bool` является наследником класса `int`.

Приведенный ниже код:

```python
print(issubclass(bool, int))
print(issubclass(int, bool))

print(isinstance(True, bool))
print(isinstance(True, int))
```

выводит:

```no-highlight
True
False
True
True
```

Подробнее о типе `bool` можно почитать по [ссылке](https://peps.python.org/pep-0285/).

**Примечание 5.** В Python присутствует строгая иерархия исключений, вершиной которой является тип `BaseException`.

Тип `BaseException` является классом самого верхнего уровня и родительским (базовым) для всех прочих классов исключений.

**Дерево встроенных исключений** выглядит так:

```no-highlight
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
           +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```

По дереву видно, что исключения `IndexError` и `KeyError` являются **потомками (наследниками)** исключения `LookupError`, которое является потомком `Exception`. В то время как исключения `FloatingPointError, OverflowError` и `ZeroDivisionError` являются потомками исключения `ArithmeticError`.

## 7.2 Наследование. Часть 2
### Тема урока: наследование

1. Переопределение методов
2. Расширение методов
3. Функция `super()`
4. Использование методов наследников в базовом классе

**Аннотация.** Урок посвящен наследованию в Python.

### Переопределение методов

В прошлом уроке мы познакомились с концепцией наследования, а также дали определения родительским и дочерним классам. Выяснили, что дочерние классы, наследуя методы родительских классов, могут дополнять их собственными методами, а также переопределять уже имеющиеся.

Рассмотрим класс `Animal`, описывающий животное, и его подкласс `Cat`, описывающий кошку:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name                               # имя животного
        self.age = age                                 # возраст животного

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def sleep(self):
        return f'{self.name} очень крепко спит zZ'

    def sound(self):
        return 'Мяу!'
```

Класс `Cat`, являясь наследником класса `Animal`, наследует метод `__init__()` родительского класса, переопределяет метод `sleep()` родительского класса и дополнительно определяет метод `sound()`.

Переопределять в дочернем классе можно как обычные методы, так и магические.

Переопределяя методы, мы можем менять их сигнатуру, например, добавляя дополнительные параметры или наоборот уменьшая их количество. Важно понимать, что переопределяя метод в дочернем классе, мы полностью его заменяем, а не получаем два разных рабочих метода. Таким образом, для экземпляров дочернего класса вызывается метод, определенный именно в дочернем классе, а метод, определенный в родительском классе, становится недоступен.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name                               
        self.age = age                                 

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def sleep(self, times):
        return f'{self.name} спит {times} часa zZ'


cat = Cat('Кемаль', 1)

print(cat.sleep(2))
```

выводит:

```no-highlight
Кемаль спит 2 часa zZ
```

В то время как приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sleep(self):
        return f'{self.name} спит zZ'

class Cat(Animal):
    def sleep(self, times):
        return f'{self.name} спит {times} часa zZ'


cat = Cat('Кемаль', 1)

print(cat.sleep())
```

приводит к возбуждению исключения, так как метод `sleep()` для экземпляров класса `Cat` должен принимать один обязательный аргумент:

```no-highlight
TypeError: Cat.sleep() missing 1 required positional argument: 'times'
```

### Расширение методов

Часто в дочернем классе мы хотим не полностью заменить метод родительского класса, а лишь расширить его. В таких случаях решением является вызов метода базового класса в теле соответствующего метода наследника и добавление дополнительного кода.

Вернемся к классу `Animal` и его наследнику классу `Cat`. Если мы определим для экземпляров класса `Animal` атрибуты `name, age` и `eyecolor`, а для экземпляров класса `Cat` захотим добавить дополнительный атрибут `breed`, нам будет нужно соответствующим образом переопределить инициализатор в дочернем классе.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age, eyecolor):
        self.name = name                               # имя животного   
        self.age = age                                 # возраст животного
        self.eyecolor = eyecolor                       # цвет глаз животного

class Cat(Animal):
    def __init__(self, name, age, eyecolor, breed):
        self.name = name
        self.age = age
        self.eyecolor = eyecolor
        self.breed = breed                             # порода кошки


animal = Animal('Роджер', 2, 'черный')
cat = Cat('Кемаль', 1, 'синий', 'манчкин')

print(animal.name, animal.age, animal.eyecolor)
print(cat.name, cat.age, cat.eyecolor, cat.breed)
```

выводит:

```no-highlight
Роджер 2 черный
Кемаль 1 синий манчкин
```

Так как часть кода в инициализаторе дочернего класса является копией кода в инициализаторе родительского класса, правильным будет вызов инициализатора базового класса в инициализаторе наследника, а не дублирование кода.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age, eyecolor):
        self.name = name
        self.age = age
        self.eyecolor = eyecolor

class Cat(Animal):
    def __init__(self, name, age, eyecolor, breed):
        Animal.__init__(self, name, age, eyecolor)
        self.breed = breed


animal = Animal('Роджер', 2, 'черный')
cat = Cat('Кемаль', 1, 'синий', 'манчкин')

print(animal.name, animal.age, animal.eyecolor)
print(cat.name, cat.age, cat.eyecolor, cat.breed)
```

выводит:

```no-highlight
Роджер 2 черный
Кемаль 1 синий манчкин
```

Здесь мы напрямую обращаемся к родительскому классу `Animal` и его методу `__init__()`, передавая экземпляр класса `Cat` и значения атрибутов, которые следует установить.

Также расширение метода может быть полезно в том случае, когда экземплярам дочернего класса мы хотим не добавить дополнительный атрибут, а установить значения по умолчанию уже имеющимся, тем самым уменьшить количество передаваемых аргументов при создании экземпляров класса наследника. Наиболее удачным примером в данном случае служат прямоугольник и квадрат. Например, мы имеем класс `Rectangle`, описывающий прямоугольник, и его дочерний класс `Square`, описывающий квадрат:

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length                           # длина прямоугольника
        self.width = width                             # ширина прямоугольника

class Square(Rectangle):
    pass
```

Квадрат является прямоугольником, у которого длина и ширина совпадают, поэтому было бы удобно при создании экземпляров класса `Square` передавать лишь одну сторону, а вторую считать равной переданной. Для этого мы можем определить в классе `Square` метод `__init__()`, принимающий один аргумент — сторону квадрата, а в теле этого метода вызвать метод `__init__()` класса `Rectangle`, передав ему эту сторону в качестве длины и ширины.

Приведенный ниже код:

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

class Square(Rectangle):
    def __init__(self, side):
        Rectangle.__init__(self, side, side)


rectangle = Rectangle(3, 4)
square = Square(2)

print(rectangle.length, rectangle.width)
print(square.length, square.width)
```

выводит:

```no-highlight
3 4
2 2
```

Расширение метода на примере инициализатора наиболее наглядно с практической точки зрения, однако, конечно, расширить можно абсолютно любой метод.

### Функция super()

Расширение методов в том виде, в котором было показано ранее, хоть и рабочее, однако имеет небольшой недостаток, который заключается в том, что мы напрямую обращаемся к родительскому классу и конкретному методу:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Cat(Animal):
    def __init__(self, name, age, breed):
        Animal.__init__(self, name, age)               # явно обращаемся к методу __init__() класса Animal
        self.breed = breed
```

Такой подход может привести к ошибкам, например, если родительский класс изменит свое имя или если у дочернего класса родительским станет другой класс. Во избежание подобных проблем в Python используется встроенная функция `super()`, которая позволяет нам неявно обращаться к родительскому классу. Наиболее распространенным вариантом ее применения является именно вызов метода родительского класса из метода дочернего класса.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Cat(Animal):
    def __init__(self, name, age, breed): 
        super().__init__(name, age)                    # неявно обращаемся к методу __init__() родительского класса
        self.breed = breed

cat = Cat('Кемаль', 1, 'манчкин')

print(cat.name, cat.age, cat.breed)
```

демонстрирует использование функции `super()` и выводит:

```no-highlight
Кемаль 1 манчкин
```

В данном случае выражение `super().__init__(name, age)`  равнозначно `Animal.__init__(self, name, age)` и звучит так: вызови метод `__init__()` у моего родительского класса и передай ему в качестве аргументов текущий экземпляр `self`, а также значения `name` и `age`. То есть объект, возвращаемый функцией `super()`, связывает текущий класс `Cat`, экземпляр класса `Cat`, доступный по имени `self`, и родительский класс `Animal`. Также следует обратить внимание, что при вызове родительского метода с помощью функции `super()`, экземпляр класса в качестве первого аргумента передавать не нужно.

Объект, возвращаемый функцией `super()` часто называют прокси-объектом или объектом-посредником. Его целью является осуществление доступа к родительскому классу текущего класса.

По умолчанию функция `super()` сама определяет текущий класс, его родительский класс и текущий экземпляр текущего класса, и в примере выше мы наблюдали данное поведение. Однако текущий класс и текущий экземпляр этого класса мы можем указывать явно.

Приведенный ниже код: 

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Cat(Animal):
    def __init__(self, name, age, breed): 
        super(Cat, self).__init__(name, age)
        self.breed = breed


cat = Cat('Кемаль', 1, 'манчкин')

print(cat.name, cat.age, cat.breed)
```

выводит:

```no-highlight
Кемаль 1 манчкин
```

В примере выше в качестве первого аргумента мы передаем класс `Cat`, тем самым указывая, что к методу `__init__()` нужно обратиться именно у родительского класса `Cat`. В качестве второго аргумента мы передаем текущий экземпляр класса `Cat` — `self`, тем самым указывая, какой именно объект нужно передать в функцию `__init__()` в качестве первого аргумента.

Функция `super()` так названа в честь названия родительского класса `superclass`.

Отличительной особенностью функции `super()` является то, что она предоставляет доступ, скорее, не к конкретному классу, а ко всей иерархии классов. И если в нашем наследовании участвует три или более классов, то функция `super()` выполняет поиск необходимого метода в каждом из этих классов.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name):
        print('Вызов метода __init__() класса Animal')
        self.name = name

class Cat(Animal):
    pass

class Kitten(Cat):
    def __init__(self, name, breed):
        print('Вызов метода __init__() класса Kitten')
        super().__init__(name)
        self.breed = breed


cat = Kitten('Кемаль', 'манчкин')

print(cat.name, cat.breed)
```

выводит:

```no-highlight
Вызов метода __init__() класса Kitten
Вызов метода __init__() класса Animal
Кемаль манчкин
```

В примере выше функция `super()` сперва проверяет наличие метода `__init__()` в классе `Cat`, а затем в классе `Animal`.

### Использование методов наследников в базовом классе

Рассмотрим класс `Animal` и двух его наследников `Cat` и `Dog`:

```
class Animal:
    def __init__(self, name):
        self.name = name

class Cat(Animal):
    def sound(self):
        return 'мяу'

class Dog(Animal):
    def sound(self):
        return 'гав'
```

Экземпляры дочерних классов имеют атрибут `name` с именем животного и определяют метод `sound()`, возвращающий звук, издаваемый соответствующим животным. Предположим, мы хотим определить метод `info()`, который объединяет данную информацию, а именно имя и звук, и возвращает их в виде одной строки. Первым решением было бы определение данного метода как в классе `Cat`, так и в классе `Dog`.

Приведенный ниже код:

```python
class Animal:
    def __init__(self, name):
        self.name = name

class Cat(Animal):
    def sound(self):
        return 'мяу'

    def info(self):
        return f'Имя: {self.name}, звук: {self.sound()}'

class Dog(Animal):
    def sound(self):
        return 'гав'

    def info(self):
        return f'Имя: {self.name}, звук: {self.sound()}'


cat = Cat('Кемаль')
dog = Dog('Роджер')

print(cat.info())
print(dog.info())
```

выводит:

```no-highlight
Имя: Кемаль, звук: мяу
Имя: Роджер, звук: гав
```

Однако если при наследовании дочерние классы определяют некоторые общие методы, их удобнее и правильнее выносить в родительский класс.

 Приведенный ниже код:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def info(self):
        return f'Имя: {self.name}, звук: {self.sound()}'

class Cat(Animal):
    def sound(self):
        return 'мяу'

class Dog(Animal):
    def sound(self):
        return 'гав'


cat = Cat('Кемаль')
dog = Dog('Роджер')

print(cat.info())
print(dog.info())
```

выводит:

```no-highlight
Имя: Кемаль, звук: мяу
Имя: Роджер, звук: гав
```

Несмотря на то что экземпляры класса `Animal` не имеют метода `sound()`, а метод `info()`, который вызывает в своем теле метод `sound()`, определен именно в классе `Animal`, при работе мы не получаем никаких ошибок. И это достаточно логично, ведь метод `info()` используется для экземпляров классов `Cat` и `Dog`, для которых метод `sound()` определен.

### Примечания

**Примечание 1.** Объект, возвращаемый функцией `super()`, предоставляет доступ к классу-родителю, тем самым мы можем обращаться не только к методам этого класса, но и атрибутам.

Приведенный ниже код:

```python
class ParentClass:
    attr = 1

class ChildClass(ParentClass):
    attr = 2
    
    def super_attr(self):
        return super().attr


obj = ChildClass()

print(obj.attr)
print(obj.super_attr())
```

выводит:

```no-highlight
2
1
```

## 7.3 Наследование. Часть 3
### Тема урока: наследование

1. Процесс создания экземпляров класса
2. Наследование от неизменяемых типов данных (`int, float, str, tuple`)

**Аннотация.** Урок посвящен наследованию от встроенных неизменяемых типов данных в Python.

### Процесс создания экземпляров класса

Напомним, что в Python процесс конструирования экземпляра класса состоит из двух шагов:

1. создание нового пустого экземпляра класса
2. инициализация созданного экземпляра класса

Для выполнения первого шага используется магический метод `__new__()`, который отвечает за создание и возврат нового пустого экземпляра класса. Затем созданный экземпляр передается в метод `__init__()` для инициализации, то есть для добавления ему необходимых атрибутов. 

Все классы в Python имеют магические методы `__new__()` и `__init__()`, так как являются дочерними классами класса `object` и наследуют от него данные методы.

Приведенный ниже код:

```python
class Cat:
    pass


print('__new__' in dir(Cat))
print('__init__' in dir(Cat))
```

выводит:

```no-highlight
True
True
```

При создании практически каждого класса мы переопределяем метод `__init__()`, а метод `__new__()` оставляем исходным, так как у нас нет необходимости вмешиваться в процесс создания экземпляра класса, нам важно лишь получить готовый объект и наделить его нужными атрибутами.

Однако в некоторых задачах без переопределения метода `__new__()` не обойтись. Прежде чем перейти к решению одной из таких задач, сперва переопределим метод `__new__()`, повторим его стандартное поведение и поговорим о том, что происходит в его теле. 

Приведенный ниже код:

```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Вызов метода __new__()')
        print(cls)        
        return super().__new__(cls)

    def __init__(self, name):
        print('2. Вызов метода __init__()')
        self.name = name
        print(self)

    def __repr__(self):
        return f'Cat({repr(self.name)})'


cat = Cat('Кемаль')
```

выводит:

```no-highlight
1. Вызов метода __new__()
<class '__main__.Cat'>
2. Вызов метода __init__()
Cat('Кемаль')
```

Итак, мы имеем класс `Cat`, в котором определены методы `__new__()` и `__init__()`. В обоих методах содержится вывод некоторого текста, и порядок их вывода подтверждает сказанное в начале урока: сперва происходит создание экземпляра — вызов метода `__new__()`, а затем его инициализация — вызов метода `__init__()`.

Метод `__new__()` принимает один обязательный аргумент — класс, экземпляр которого требуется создать. Как можно заметить из вывода, этим аргументом всегда является сам класс, в котором реализован метод, в нашем случае это класс `Cat`. После указывается переменное количество позиционных и именованных аргументов, роль которых будет упомянута позже.

В теле метода `__new__()` нам важна последняя строка, в которой и происходит создание и возврат экземпляра класса. В ней мы с помощью функции `super()` обращаемся к родительскому методу `__new__()`, передавая в качестве аргумента текущий класс. Родительским классом является класс `object`, текущим — класс `Cat`, таким образом, вызов `super().__new__(cls)` равнозначен вызову `object.__new__(Cat)`.

Почему же нам нужно в нашем методе `__new__()` вызывать метод `__new__()` класса `object`? Дело в том, что именно метод `__new__()` класса `object` отвечает за создание всех объектов в Python. Он принимает единственный аргумент — класс, экземпляр которого требуется создать. Именно этим мы и пользуемся: вызываем метод `__new__()` класса `object`, передаем ему в качестве аргумента наш класс `Cat` и получаем экземпляр класса `Cat`.

В Python все является объектом, даже сами классы. Так как за создание всех объектов отвечает метод `__new__()` класса `object`, все классы в Python являются экземплярами класса `object`.

Произвольное количество позиционных и именованных аргументов в методе `__new__()` необходимо для того чтобы не ограничивать сигнатуру метода `__init__()`, так как аргументы, передаваемые классу при создании его экземпляра, попадают как в метод `__new__()`, так и в метод `__init__()`.

 Приведенный ниже код:

```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print(args, kwargs)
        return super().__new__(cls)

    def __init__(self, name, age=1):
        self.name = name
        self.age = age


cat = Cat('Кемаль', age=2)
```

выводит:

```no-highlight
('Кемаль',) {'age': 2}
```

#### Особенности поведения метода __new__()

Основная задача метода `__new__()` заключается в создании и возврате нового пустого экземпляра класса, который после будет передан в инициализатор. Однако метод `__new__()` может возвращать экземпляр класса, отличного от класса, реализующего сам метод. В таком случае метод `__init__()` вызываться не будет.

Приведенный ниже код:

```python
class Animal:
    pass

class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Вызова метода __new__()')
        return Animal()

    def __init__(self, name):
        print('2. Вызова метода __init__()')
        self.name = name


cat = Cat('Кемаль')
```

выводит:

```no-highlight
1. Вызова метода __new__()
```

В примере выше метод `__new__()` класса `Cat` возвращает экземпляр другого класса — класса `Animal`, поэтому вызова метода `__init__()` класса `Cat` не происходит. Обратите внимание, что если методом `__new__()` будет возвращено значение `None`, то вызов метода `__init__()` так же не произойдет.

#### Особенности поведения метода __init__()

Основная задача метода `__init__()` заключается в наделении необходимыми атрибутами только что созданного пустого экземпляра класса. Важным является то, что возвращаемым значением метода всегда должен быть `None`, в противном случае будет возбуждено исключение.

Приведенный ниже код:

```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        return super().__new__(cls)

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name
        return self


cat = Cat('Кемаль')
```

приводит к возбуждению исключения:

```no-highlight
TypeError: __init__() should return None, not 'Cat'
```

### Наследование от неизменяемых типов данных

При создании большинства классов мы не переопределяем метод `__new__()`, так как у нас нет необходимости вмешиваться в процесс создания экземпляра класса. Однако если нашей задачей будет создание класса, являющегося наследником какого-либо встроенного класса, экземпляры которого являются неизменяемыми, переопределение метода `__new__()` может нам очень помочь.

#### Переопределение метода __new__()

Предположим, мы хотим реализовать класс `Distance`, наследника класса `float`, описывающего расстояние на местности, который помимо своего числового значения имеет атрибут `unit`, в котором содержатся единицы измерения этого расстояния.

Если мы опустим переопределение метода `__new__()` и попытаемся решить задачу лишь с помощью метода `__init__()`, то столкнемся с некоторыми трудностями.

Приведенный ниже код:

```python
class Distance(float):
    def __init__(self, value, unit):
        super().__init__()
        self.unit = unit


distance = Distance(1, 'Meters')

print(distance)
print(distance.unit)
```

приводит к возбуждению исключения:

```no-highlight
TypeError: float expected at most 1 argument, got 2
```

Часть ошибки заключается в том, что при наследовании от неизменяемых типов данных их значение определяется при создании, то есть в методе `__new__()`, и менять его в инициализаторе уже поздно. Кроме того, выражение `Distance(1, 'Meters')` сперва вызывает метод `__new__()` класса `float`, который принимает лишь один аргумент — числовое или строковое значение, на основе которого будет создано число, а в нашем случае их передается два, что и приводит к ошибке.

Решить данную проблему можно путем расширения метода `__new__()`.

Приведенный ниже код:

```python
class Distance(float):
    def __new__(cls, value, unit):
        instance = super().__new__(cls, value)
        instance.unit = unit
        return instance


distance = Distance(1, 'Meters')

print(distance)
print(distance.unit)
```

выводит:

```no-highlight
1.0
Meters
```

Сперва стоит обратить внимание на сигнатуру метода `__new__()`, он принимает три аргумента: 

- `cls` — текущий класс, класс `Distance`
- `value` — числовое значение экземпляра класса `Distance`
- `unit` — единицы измерения, значение атрибута `unit` экземпляра класса `Distance`

В теле метода `__new__()` происходит вызов метода `__new__()` класса `float`, с обращением к нему при помощи функции `super()`. Таким образом, вызов `super().__new__(cls, value)` равнозначен вызову `float.__new__(Distance, value)`. Данный вызов возвращает экземпляр класса `Distance`, который имеет весь функционал класса `float`. Затем этому экземпляру добавляется атрибут `unit` с соответствующим значением, и он возвращается.

Важно отметить, что неизменяемой является лишь числовая составляющая экземпляра класса `Distance`, в то время как атрибут `unit` может быть изменен в любой части программы.

Приведенный ниже код:

```python
class Distance(float):
    def __new__(cls, value, unit):
        instance = super().__new__(cls, value)
        instance.unit = unit
        return instance


distance = Distance(1, 'Meters')
print(distance, distance.unit)

distance.unit = 'Kilometers'
print(distance, distance.unit)
```

выводит:

```no-highlight
1.0 Meters
1.0 Kilometers
```

#### Дополнение класса

Более простой является ситуация, когда нас полностью устраивает функционал встроенного класса, однако мы хотим его расширить или изменить его, не затрагивая процесс создания экземпляра класса.

Примером такой ситуации может быть класс `WordCountString`, наследник класса `str`, который определяет дополнительный метод и переопределяет имеющийся. В качестве дополнительного будет метод `words()`, возвращающий количество слов в строке, которое вычисляется путем ее разделения по пробельным символам. В качестве переопределяемого будет метод `__str__()`, в котором помимо самой строки будет содержаться количество слов в ней.

Приведенный ниже код:

```python
class WordCountString(str):
    def __str__(self):
        return f'{super().__str__()}, {self.words()}'
    
    def words(self):
        return len(self.split())


wordcountstring = WordCountString('I Love Beegeek')

print(wordcountstring.words())
print(wordcountstring)
```

выводит:

```no-highlight
3
I Love Beegeek, 3
```

Обратите внимание, что в нашем методе `__str__()` нам необходимо воспользоваться методом `__str__()` класса `str`. Если вместо `super().__str__()` мы укажем просто `self`, то получим бесконечные рекурсивные вызовы.

### Примечания

**Примечание 1.** Наследование от встроенных классов ничем не отличается от наследования от собственных классов, то есть мы так же получаем все методы и атрибуты родительского класса.

Приведенный ниже код:

```python
class Distance(float):
    def __new__(cls, value, unit):
        instance = super().__new__(cls, value)
        instance.unit = unit
        return instance


distance = Distance(1, 'Meters')

print(dir(distance))
```

выводит:

```no-highlight
['__abs__', '__add__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dict__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getformat__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__int__', '__le__', '__lt__', '__mod__', '__module__', '__mul__', '__ne__', '__neg__', '__new__', '__pos__', '__pow__', '__radd__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rmod__', '__rmul__', '__round__', '__rpow__', '__rsub__', '__rtruediv__', '__set_format__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__weakref__', 'as_integer_ratio', 'conjugate', 'fromhex', 'hex', 'imag', 'is_integer', 'real', 'unit']
```

**Примечание 2.** Классы `bool` и `NoneType` не могут быть родительскими, то есть от них нельзя наследоваться, и при попытке сделать это будет возбуждено исключение. Рассуждения создателей языка о необходимости такого поведения можно почитать по [ссылке](https://mail.python.org/pipermail/python-dev/2002-March/020822.html).

### Неизменяемость строкового типа в Python

Редко, когда у программистов возникает вопрос относительно неизменяемости встроенных типов `bool, int, float`. В то время как неизменяемость строкового типа `str` часто вызывает вопросы.

Приведем несколько аргументов в пользу неизменяемости строкового типа данных.

1) Нет необходимости постоянно создавать копии строк при передаче аргументов в функцию (метод). Другими словами, мы можем быть уверены, что переданная в функцию (метод) строка останется неизменной.

Если бы строки были бы изменяемыми, то приведенный ниже код:

```python
class User:
    def __init__(self, name):
        self.name = name

name = 'Tim'
user = User(name)
name[1] = 'o'
print(user.name)
```

вывел бы:

```no-highlight
Tom
```

В Python приведенный выше код приводит к возбуждению исключения:

```no-highlight
TypeError: 'str' object does not support item assignment
```

2) Неизменяемость строкового типа данных позволяет не вводить дополнительный тип (`char`) для одиночного символа. В Python одиночный символ ничем не отличается от строки длины один, поэтому все строковые операторы применяются и к символам. 

3) Неизменяемость строкового типа данных позволяет использовать его в качестве элементов множеств и ключей в словарях.

### Примечания

**Примечание 1.** Наряду с Python, многие современные языки программирования также имеют неизменяемый строковый тип данных. К таким языкам относятся, например, Java и C#. В то же время есть языки программирования, например, Ruby, в которых строки являются изменяемыми.

**Примечание 2.** Неизменяемые типы данных делают программирование проще, особенно при работе с многопоточной средой.

## 7.4 Наследование. Часть 4
### Тема урока: наследование

1. Наследование от типа `dict`
2. Наследование от типа `list`
3. Типы `UserDict` и `UserList` из модуля `collections`

**Аннотация.** Урок посвящен наследованию от типов `dict` и `list`.

В прошлом уроке мы рассмотрели особенности, возникающие при наследовании от неизменяемых типов данных. В этом уроке мы рассмотрим особенности, которые возникают при наследовании от изменяемых типов данных `dict` и `list`.

### Наследование от dict

Создадим класс `UpperCaseDict`, наследника класса `dict`, который автоматически сохраняет все ключи в виде строк, в которых все буквы будут в верхнем регистре.

Для реализации класса `UpperCaseDict` мы переопределим магический метод `__setitem__()` и для удобства `__repr__()`:

```python
class UpperCaseDict(dict):
    def __setitem__(self, key, value):
        key = str(key).upper()
        super().__setitem__(key, value)
    
    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
```

Установка элементов в этом словаре работает так, как мы и ожидаем.

Приведенный ниже код:

```python
numbers = UpperCaseDict()
numbers['one'] = 1
numbers['two'] = 2

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'ONE': 1, 'TWO': 2})
```

Однако если мы вызовем метод `update()`, то получим не совсем ожидаемое поведение.

Приведенный ниже код:

```python
numbers = UpperCaseDict()
numbers['one'] = 1
numbers['two'] = 2

numbers.update({'three': 3})

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'ONE': 1, 'TWO': 2, 'three': 3})
```

Как мы видим, при вызове метода `update()` магический метод `__setitem__()`, который мы переопределили, не вызывается, и в словарь `UpperCaseDict` добавляется пара `'three': 3`, имеющая ключ в нижнем регистре.

Мы можем исправить это поведение с помощью переопределения метода `update()`:

```python
class UpperCaseDict(dict):
    def update(self, items):
        if isinstance(items, dict):
            items = items.items()
        for key, value in items:
            self[key] = value

    def __setitem__(self, key, value):
        key = str(key).upper()
        super().__setitem__(key, value)
    
    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
```

Теперь приведенный ниже код:

```python
numbers = UpperCaseDict()
numbers['one'] = 1
numbers['two'] = 2

numbers.update({'three': 3})

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'ONE': 1, 'TWO': 2, 'THREE': 3})
```

Не совсем ожидаемое поведение мы получим и при создании словаря с некоторыми начальными значениями.

Приведенный ниже код:

```python
numbers = UpperCaseDict(one=1, two=2, three=3)

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'one': 1, 'two': 2, 'three': 3})
```

Как мы видим, в словарь `UpperCaseDict` добавляются три пары `'one': 1, 'two': 2` и `'three': 3`, имеющие ключи в нижнем регистре.

Мы можем исправить это поведение с помощью переопределения метода  `__init__()`:

```python
class UpperCaseDict(dict):
    def __init__(self, items=(), **kwargs):
        self.update(items)
        self.update(kwargs)

    def update(self, items):
        if isinstance(items, dict):
            items = items.items()
        for key, value in items:
            self[key] = value

    def __setitem__(self, key, value):
        key = str(key).upper()
        super().__setitem__(key, value)
    
    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
```

Теперь приведенный ниже код:

```python
numbers = UpperCaseDict(one=1, two=2, three=3)

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'ONE': 1, 'TWO': 2, 'THREE': 3})
```

Не совсем ожидаемое поведение мы получим и при использовании метода `setdefault()`, поскольку данный метод также не вызывает магический метод `__setitem__()`.

Приведенный ниже код:

```python
numbers = UpperCaseDict()

numbers.setdefault('one', 1)

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'one': 1})
```

Мы можем исправить это поведение с помощью переопределения метода `setdefault()`:

```python
class UpperCaseDict(dict):
    def __init__(self, items=(), **kwargs):
        self.update(items)
        self.update(kwargs)

    def update(self, items):
        if isinstance(items, dict):
            items = items.items()
        for key, value in items:
            self[key] = value

    def setdefault(self, key, value):
        if str(key).upper() not in self:
            self[key] = value

    def __setitem__(self, key, value):
        key = str(key).upper()
        super().__setitem__(key, value)
    
    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
```

Как мы видим, для правильной работы класса `UpperCaseDict` необходимо переопределить много методов базового типа `dict`. При наследовании от `dict` мы ожидаем, что методы `update(), __init__(), setdefault()` вызовут метод `__setitem__()`, однако этого не происходит.

### Наследование от list

Аналогичные проблемы мы получаем при наследовании от типа `list`. Создадим класс `StringList`, наследника класса `list`, который автоматически сохраняет все свои элементы в виде строк.

Для реализации класса `StringList` мы переопределим магические методы `__init__(), __setitem__()` и для удобства `__repr__()`:

```python
class StringList(list):
    def __init__(self, iterable):
        super().__init__(str(item) for item in iterable)

    def __setitem__(self, index, item):
        super().__setitem__(index, str(item))

    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
```

Приведенный ниже код:

```python
li = StringList([1, 2, 3])
li[2] = 4

print(li)
```

выводит:

```no-highlight
StringList(['1', '2', '4'])
```

Как мы видим, инициализация и установка элементов работает так, как мы и ожидаем.

Однако если мы попытаемся добавить в список новый элемент с помощью методов `append(), insert()` или `extend()`, то получим не совсем ожидаемое поведение.

Приведенный ниже код:

```python
li = StringList([1, 2, 3])
li.append(4)
li.insert(0, 5)
li.extend([6, 7, 8])

print(li)
```

выводит:

```no-highlight
StringList([5, '1', '2', '3', 4, 6, 7, 8])
```

Мы можем исправить это поведение с помощью переопределения методов  `append(), insert()` и `extend()`:

```python
class StringList(list):
    def __init__(self, iterable):
        super().__init__(str(item) for item in iterable)

    def __setitem__(self, index, item):
        super().__setitem__(index, str(item))

    def insert(self, index, item):
        super().insert(index, str(item))

    def append(self, item):
        super().append(str(item))

    def extend(self, other):
        if isinstance(other, type(self)):
            super().extend(other)
        else:
            super().extend(str(item) for item in other)

    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
```

Приведенный ниже код:

```python
li = StringList([1, 2, 3])
li.append(4)
li.insert(0, 5)
li.extend([6, 7, 8])

print(li)
```

выводит:

```no-highlight
StringList(['5', '1', '2', '3', '4', '6', '7', '8'])
```

И опять, как мы видим, для правильной работы класса `StringList` необходимо переопределить много методов базового типа `list`.

Методы `remove()` и `pop()` типа `list` не вызывают магический метод `__delitem__()`. Метод `__ne__()` не вызывает метод `__eq__()`.

**Подводя итог**: каждый раз, когда мы настраиваем функционал в наследниках классов `dict` или `list`, нам нужно убедиться, что мы переопределяем все методы, затрагивающие этот функционал.

**Вопрос**: почему разработчики Python спроектировали встроенные типы `list` и `dict` таким образом?

**Ответ**: все дело в том, что встроенные типы `list` и `dict` были спроектированы с учетом принципа [открытости/закрытости](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8/%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8): они открыты для расширения, но закрыты для модификации. Разрешение модификаций основных функций этих классов потенциально может нарушить их инварианты. Поэтому разработчики Python решили защитить их от модификаций. Такая реализация классов также позволяет немного ускорить их работу.

### Типы UserDict и UserList

Для решения указанных выше проблем, связанных с наследованием от типов `dict` и `list`, можно использовать типы `UserDict` и `UserList` из модуля `collections`.

#### Наследование от UserDict

Класс `UserDict` – это удобная обертка для обычного объекта `dict`. Этот класс обеспечивает то же поведение, что и `dict`, с дополнительной возможностью предоставления доступа к базовому словарю через атрибут экземпляра `data`.

Перепишем наш класс `UpperCaseDict`, который автоматически сохраняет все ключи в виде строк, в которых все буквы будут в верхнем регистре, так, чтобы он наследовался от `UserDict`:

```python
from collections import UserDict

class UpperCaseDict(UserDict):
    def __setitem__(self, key, value):
        key = str(key).upper()
        self.data.__setitem__(key, value)

    def __repr__(self):
        return f'{type(self).__name__}({self.data.__repr__()})'
```

Приведенный ниже код:

```python
numbers = UpperCaseDict({'one': 1, 'two': 2})

numbers['three'] = 3
numbers.update({'four': 4})
numbers.setdefault('five', 5)

print(numbers)
```

выводит:

```no-highlight
UpperCaseDict({'ONE': 1, 'TWO': 2, 'THREE': 3, 'FOUR': 4, 'FIVE': 5})
```

Как мы видим, теперь все методы класса `UpperCaseDict` работают корректно. Нет необходимости предоставлять собственные реализации методов `__init__(), update()` и `setdefault()`. Это связано с тем, что в `UserDict` все методы, обновляющие существующие ключи или добавляющие новые, полагаются на пользовательскую версию метода `__setitem__()`.

Наиболее заметным отличием между `UserDict` и `dict` является атрибут `data`, который содержит обернутый словарь. Использование атрибута `data` напрямую может сделать код более простым, так как не нужно постоянно вызывать функцию `super()` для обеспечения нужной функциональности базового класса.

#### Наследование от UserList

Класс `UserList` – это удобная обертка для обычного объекта `list`. Этот класс обеспечивает то же поведение, что `list`, с дополнительной возможностью предоставления доступа к базовому списку через атрибут экземпляра `data`.

Наследники класса `UserList` должны предоставить инициализатор, который можно вызывать либо без аргументов, либо с одним аргументом, определяющим начальный набор элементов.

Перепишем наш класс `StringList`, который автоматически сохраняет все свои элементы в виде строк, так, чтобы он наследовался от `UserList`.

```python
from collections import UserList

class StringList(UserList):
    def __init__(self, iterable):
        super().__init__(str(item) for item in iterable)

    def __setitem__(self, index, item):
        self.data[index] = str(item)

    def insert(self, index, item):
        self.data.insert(index, str(item))

    def append(self, item):
        self.data.append(str(item))

    def extend(self, other):
        if isinstance(other, type(self)):
            self.data.extend(other)
        else:
            self.data.extend(str(item) for item in other)

    def __repr__(self):
        return f'{type(self).__name__}({self.data.__repr__()})'
```

В этом примере доступ к атрибуту `data` позволяет создать класс `StringList` более простым способом. При этом функция `super()` используется один раз в инициализаторе класса `__init__()` для предотвращения проблемы в дальнейших сценариях наследования. В остальных методах используется атрибут `data`, который содержит обычный список.

Приведенный ниже код:

```python
lst = StringList([1, 2, 3])

lst[2] = 4
lst.append(5)
lst.insert(0, 6)
lst.extend([6, 7, 8])

print(lst)
```

выводит:

```python
StringList(['6', '1', '2', '4', '5', '6', '7', '8'])
```

Если есть необходимость, чтобы класс `StringList` поддерживал конкатенацию с помощью оператора плюс `+`, то потребуется реализовать магические методы `__add__()`, `__radd__()` и `__iadd__()`.

### Наследование от типов list и dict не всегда плохо

Может сложиться впечатление, что наследование от типов `list` и `dict` – это всегда плохая идея и что всегда нужно использовать типы `UserList` и `UserDict`. Однако это не так. В ситуациях, когда мы изменяем функциональность, ограниченную одним методом, или добавляем собственные методы, никаких проблем не возникает.

Создадим класс `DefaultDict`, наследника класса `dict`, который возвращает значение по умолчанию в ситуации, когда нужного ключа нет в словаре:

```python
class DefaultDict(dict):
    def __init__(self, *args, default=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default = default
    
    def __missing__(self, key):
        return self.default
```

Приведенный ниже код:

```python
dd1 = DefaultDict({'one': 1})
print(dd1['one'])
print(dd1['two'])

dd2 = DefaultDict({'one': 1}, default='empty result')
print(dd2['one'])
print(dd2['two'])
```

выводит:

```no-highlight
1
None
1
empty result
```

В классе `DefaultDict` нет никаких проблем с наследованием от `dict`, потому что нам требуется переопределить всего один магический метод `__missing__()`. Возвращаемое значение метода `__missing__()` – это значение, которое будет возвращено при попытке получить значение по несуществующему ключу. По умолчанию метод `__missing__()` возбуждает исключение `KeyError`.

Метод `__getitem__()` внутренне вызывает метод `__missing__()`, если ключ не существует.

### Примечания

**Примечание 1.** Исходный код классов `list` и `dict` доступен по [ссылке](https://github.com/python/cpython/blob/main/Objects/listobject.c) и [ссылке](https://github.com/python/cpython/blob/main/Objects/dictobject.c).

**Примечание 2.** Для лучшего понимания работы классов `UserDict` и `UserList` рекомендуем ознакомиться с их исходным кодом:

Исходный код класса `UserDict`: 
Исходный код класса `UserList`:

Исходный код модуля `collections` доступен по [ссылке](https://github.com/python/cpython/blob/main/Lib/collections/__init__.py).

**Примечание 3.** Классы `UserList` и `UserDict` были добавлены в Python еще тогда, когда было невозможно напрямую наследоваться от `list` и `dict`. Несмотря на то что необходимость в этих классах была частично вытеснена, они по-прежнему доступны в стандартной библиотеке как для удобства, так и для обратной совместимости.

**Примечание 4.** Классы `UserList`и `UserDict` выступают в качестве **классов-оберток**. Когда мы наследуемся от этих классов, мы оборачиваем `data` атрибут, к которому мы перенаправляем все нужные методы.

**Примечание 5.** В модуле `collections` также есть класс `UserString`. Помимо поддержки методов и операций строк, экземпляры `UserString` предоставляют атрибут `data` – объект `str`, который используется для хранения содержимого класса `UserString` и дает доступ к обернутому строковому объекту.

Исходный код класса `UserString`:

## 7.5 Абстрактные классы, модуль abc
### Тема урока: абстрактные классы, модуль abc

1. Абстрактные классы
2. Модуль `abc`
3. Модуль `collections.abc`

**Аннотация.** Урок посвящен абстрактным классам и модулям `abc` и `collections.abc`.

### Абстрактные классы

Рассмотрим иерархию классов:

```python
class Animal:
    def sound(self): 
        pass
    
    def move(self):
        pass
    
class Cat(Animal):
    def sound(self): 
        return 'мяу'
    
    def move(self):
        return ''
```

Базовый класс `Animal` не представляет никакого конкретного животного, а просто задает общий интерфейс, присущий всем животным. Несмотря на это, мы можем создать экземпляр класса `Animal`.

Приведенный ниже код:

```python
animal = Animal()

print(animal.sound())
print(animal.move())
```

выполняется без ошибок, хотя и не имеет большого смысла.

Для ситуаций, в которых не имеет смысла создавать экземпляры базового класса, используются **абстрактные классы**.

**Абстрактный класс** – очень важная концепция объектно-ориентированного программирования. Это хорошая практика принципа "не повторяйся". Абстрактные классы очень удобно использовать для определения общего интерфейса для различных реализаций.

Абстрактный класс имеет некоторые особенности:

- абстрактный класс не содержит всех реализаций методов, необходимых для полной работы, это означает, что он содержит один или несколько **абстрактных методов**
- абстрактный метод – это только объявление метода, без его подробной реализации
- абстрактный класс предоставляет интерфейс для наследников, чтобы избежать дублирования кода, при этом нет смысла создавать экземпляр абстрактного класса
- классы наследники должны реализовать **все** абстрактные методы для создания конкретного класса, который соответствует интерфейсу, определенному абстрактным классом

Другими словами, абстрактный класс определяет общий интерфейс для набора подклассов. Он предоставляет общие атрибуты и методы для всех подклассов, чтобы уменьшить дублирование кода. Он также заставляет подклассы реализовывать абстрактные методы, чтобы избежать каких-то несоответствий.

Для создания абстрактных классов используется встроенный модуль `abc`. Абстрактный класс можно определить с помощью наследования от класса `abc.ABC`, а абстрактный метод — с помощью декоратора `@abc.abstractmethod`.

ABC – это аббревиатура от слов Abstract Base Class (Абстрактный Базовый Класс).

В приведенном ниже коде мы объявляем абстрактный класс `Animal`, содержащий два абстрактных метода `move()` и `sound()`:

```
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def move(self):
        pass

    @abstractmethod
    def sound(self):
        pass
```

Python не разрешает создавать экземпляры абстрактных классов. При попытке сделать это будет возбуждено исключение

Приведенный ниже код:

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def move(self):
        pass

    @abstractmethod
    def sound(self):
        pass
    
animal = Animal()
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Can't instantiate abstract class Animal with abstract methods move, sound
```

Обратите внимание, что класс является абстрактным только в том случае, если он наследуется от класса `abc.ABC` и имеет хотя бы один абстрактный метод. В противном случае класс не будет считаться абстрактным, и его экземпляр можно будет создать.

Наследник абстрактного класса должен переопределить **все** абстрактные методы, иначе экземпляр такого класса будет невозможно создать.

На самом деле абстрактный метод в Python не обязательно должен быть полностью абстрактным, что отличается от некоторых других объектно-ориентированных языков программирования. Можно определить некоторый общий функционал в абстрактном методе и использовать функцию `super()` для вызова его в подклассах.

Приведенный ниже код:

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self): 
        print('Не определен')

    @abstractmethod
    def move(self):
        print('Животное движется')

class Cat(Animal):
    def sound(self): 
        print('мяу')

    def move(self):
        super().move()
        print('Кот движется')


cat = Cat()

cat.move()
cat.sound()
```

выводит:

```no-highlight
Животное движется
Кот движется
мяу
```

Как показано в приведенном выше примере, абстрактный метод `move()` может содержать некоторый функционал и может вызываться подклассом с помощью `super()`. Несмотря на реализацию в базовом классе, метод `move()` является все еще абстрактным методом, и нам необходимо полностью реализовать (переопределить или дополнить) его в подклассах.

Совместно с декоратором `@abstractmethod` можно использовать такие декораторы, как `@property, @classmethod` и `@staticmethod`, при этом декоратор `@abstractmethod` следует применять как самый внутренний декоратор.

**Определение абстрактного метода класса:**

```python
from abc import ABC, abstractmethod

class C(ABC):
    @classmethod
    @abstractmethod
    def abstract_class_method(cls, ...):
        ...
```

**Определение абстрактного статического метода:**

```python
from abc import ABC, abstractmethod

class C(ABC):
    @staticmethod
    @abstractmethod
    def abstract_static_method(...):
        ...
```

**Определение абстрактного свойства только для чтения:**

```python
from abc import ABC, abstractmethod

class C(ABC):
    @property
    @abstractmethod
    def abstract_property(self):
        ...
```

Также можно определить абстрактное свойство для чтения и записи, соответствующим образом пометив один или несколько базовых методов как абстрактные:

```python
from abc import ABC, abstractmethod

class C(ABC):
    @property
    def x(self):
        ...

    @x.setter
    @abstractmethod
    def x(self, value):
        ...
```

Если только некоторые компоненты являются абстрактными, только эти компоненты необходимо обновить, чтобы создать конкретное свойство в подклассе:

```python
class D(C):
    @C.x.setter
    def x(self, value):
        ...
```

### Примечания

**Примечание 1.** Если класс не реализует какой-либо метод, то вместо заглушки `pass` он может возбуждать исключение `NotImplementedError` или содержать строку документации.

```python
from abc import ABC, abstractmethod

class C(ABC):
    @abstractmethod
    def method1(self, input):
        '''docstring'''

    @abstractmethod
    def method2(self, output, data):
        raise NotImplementedError
```

**Примечание 2.** Абстрактные классы могут содержать не только абстрактные методы, но и обычные. Такие методы не обязаны быть переопределены дочерними классами.

Приведенный ниже код:

```python
from abc import ABC, abstractmethod

class C(ABC):
    @abstractmethod
    def method1(self):
        pass

    def method2(self):
        return 2

class D(C):
    def method1(self):
        return 1


d = D()

print(d.method1())
print(d.method2())
```

выводит:

```no-highlight
1
2
```

**Примечание 3.** Несмотря на то что Python использует утиную типизацию, концепция абстрактных классов позволяет улучшить качество архитектуры приложения, уменьшить объем работы и при этом, обеспечить легкость дальнейшей поддержки кода.

**Примечание 4.** Документация по абстрактным классам доступна по [ссылке](https://peps.python.org/pep-3119/) и [ссылке](https://docs.python.org/3/library/abc.html).

### Модуль collections.abc

Модуль `collections.abc` предоставляет абстрактные базовые классы, которые можно использовать для проверки того, реализует объект тот или иной интерфейс или нет.

|Класс (Интерфейс)|Наследуется от|Абстрактные методы|Mixin методы|
|---|---|---|---|
|`Container`||`__contains__()`||
|`Hashable`||`__hash__()`||
|`Iterable`||`__iter__()`||
|`Iterator`|`Iterable`|`__next__()`|`__iter__()`|
|`Reversible`|`Iterable`|`__reversed__()`||
|`Generator`|`Iterator`|`send(), throw()`|`close(), __iter__(), __next__()`|
|`Sized`||`__len__()`||
|`Callable`||`__call__()`||
|`Collection`|`Sized, Iterable, Container`|`__contains__(), __iter__(), __len__()`||
|`Sequence`|`Reversible, Collection`|`__getitem__(), __len__()`|`__contains__(), __iter__(), __reversed__(), index(), count()`|
|`MutableSequence`|`Sequence`|`__getitem__(), __setitem__(), __delitem__(), __len__(), insert()`|все методы `Sequence, append(), reverse(), extend(), pop(), remove(), __iadd__()`|
|`Set`|`Collection`|`__contains__(), __iter__(), __len__()`|`__le__(), __lt__(), __eq__(), __ne__(), __gt__(), __ge__(), __and__(), __or__(), __sub__(), __xor__(), isdisjoint()`|
|`MutableSet`|`Set`|`__contains__(), __iter__(), __len__(), add(), discard()`|все методы `Set, clear(), pop(), remove(), __ior__(), __iand__(), __ixor__(), __isub__()`|
|`Mapping`|`Collection`|`__getitem__(), __iter__(), __len__()`|`__contains__(), keys(), items(), values(), get(), __eq__(), __ne__()`|
|`MutableMapping`|`Mapping`|`__getitem__(), __setitem__(), __delitem__(), __iter__(), __len__()`|все методы `Mapping, pop(), popitem(), clear(), update(), setdefault()`|

Mixin методы представляют собой методы, которые автоматически реализуются на основе абстрактных методов.

Таким образом, некоторый объект реализует интерфейс:

- `Iterable`, если он содержит метод `__iter__()`
- `Iterator`, если он содержит методы `__next__()` и `__iter__()`
- `Collection`, если он содержит методы `__contains__(), __iter__()` и `__len__()`
- `Sequence`, если он содержит методы `__getitem__(), __len__(), __contains__(), __iter__(), __reversed__(), index()` и `count()`
- `Mapping`, если он содержит методы `__getitem__(), __iter__(), __len__(), __contains__(), keys(), items(), values(), get(), __eq__()` и `__ne__()`
- и т.д.

С помощью типов из данного модуля и функций `isinstance()` и `issubclass()` можно проверить, например, является ли объект итерируемым, или, например, реализует ли класс протокол последовательности.

Приведенный ниже код:

```python
from collections.abc import Sequence, MutableSequence

print(isinstance([1, 2, 3], Sequence))
print(isinstance(['one', 'two'], MutableSequence))

print(issubclass(list, Sequence))
print(issubclass(list, MutableSequence))
```

выводит:

```no-highlight
True
True
True
True
```

Приведенный ниже код:

```python
from collections.abc import Sequence, MutableSequence

print(isinstance((1, 2, 3), Sequence))
print(isinstance(('one', 'two'), MutableSequence))

print(issubclass(tuple, Sequence))
print(issubclass(tuple, MutableSequence))
```

 выводит:

```no-highlight
True
False
True
False
```

Приведенный ниже код:

```python
from collections.abc import Sequence, MutableSequence

print(isinstance('beegeek', Sequence))
print(isinstance('beegeek', MutableSequence))

print(issubclass(str, Sequence))
print(issubclass(str, MutableSequence))
```

выводит:

```no-highlight
True
False
True
False
```

Приведенный ниже код:

```python
from collections.abc import Mapping, MutableMapping, MutableSequence

print(isinstance({'one': 1, 'two': 2}, MutableSequence))
print(isinstance({'one': 1, 'two': 2}, Mapping))
print(isinstance({'one': 1, 'two': 2}, MutableMapping))

print(issubclass(dict, MutableSequence))
print(issubclass(dict, Mapping))
print(issubclass(dict, MutableMapping))
```

выводит:

```no-highlight
False
True
True
False
True
True
```

#### Использование collections.abc

Абстрактные базовые классы модуля `collections.abc` полезны при создании пользовательских классов, которые работают как последовательности (`tuple, str, list`), множества (`set`), отображения (`dict`) и т.д. Иногда вместо наследования от встроенных типов `tuple, str, set, list, dict` куда проще реализовать соответствующий интерфейс.

Создадим класс `ListBasedSet`, который представляет собой неизменяемое множество, основанное на списке. Такая реализация будет медленнее обычного множества, но при этом будет потреблять меньше памяти:

```
from collections.abc import Set

class ListBasedSet(Set):
    def __init__(self, iterable):
        lst = []
        for value in iterable:
            if value not in lst:
                lst.append(value)
        self.elements = lst

    def __iter__(self):
        return iter(self.elements)

    def __contains__(self, value):
        return value in self.elements

    def __len__(self):
        return len(self.elements)
    
    def __repr__(self):
        return f'{type(self).__name__}({self.elements})'
```

Приведенный ниже код:

```python
s1 = ListBasedSet('abcdef')
s2 = ListBasedSet('defghi')

print(s1 | s2)
print(s1 & s2)
print(s1 - s2)
```

выводит:

```no-highlight
ListBasedSet(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])
ListBasedSet(['d', 'e', 'f'])
ListBasedSet(['a', 'b', 'c'])
```

Обратите внимание, что нам достаточно реализовать лишь методы `__iter__(), __contains__()` и `__len__()`. При этом методы `__le__(), __lt__(), __eq__(), __ne__(), __gt__(), __ge__(), __and__(), __or__(), __sub__(), __xor__(), isdisjoint()`, а вместе с ними и соответствующие операторы будут реализованы автоматически.

Помимо абстрактных методов, наследники классов из `collections.abc` могут содержать любой дополнительный набор полезных для них методов.

#### Примечания

**Примечание 1.** Документация по модулю `collections.abc` доступна по [ссылке](https://docs.python.org/3/library/collections.abc.html).

**Примечание 2.** Статья, описывающая основные возможности модуля `collections.abc` доступна по [ссылке](https://peps.python.org/pep-3119/).

**Примечание 3.** Абстрактные базовые классы позволяют нам проверять наличие определенного функционала у объектов. Например, если мы хотим проверить наличие метода `__len__()`, то вместо кода:

```python
size = None

if hasattr(size, '__len__'):
    size = len(size)
```

можем написать более типизированный код:

```python
from collections.abc import Sized

size = None

if isinstance(size, Sized):
    size = len(size)
```

**Примечание 4.** Если при создании пользовательских классов, которые работают подобно последовательностям (`tuple, str, list`), множествам (`set`), отображениям (`dict`) нужно менять их основные функции (нестандартный функционал), унаследованые от базовых классов, то наследование может оказаться болезненным, поскольку придется переопределять много методов. В этих ситуациях проще создать класс, унаследованный от одного из абстрактных классов модуля `collections.abc`. Если же мы создаем пользовательский класс, который совсем немного отличается от своего базового, то можно рассмотреть наследование от типов `list, str, dict, UserList, UserString, UserDict`.

**Примечание 5.** В Python используется утиная типизация. Таким образом, для того, чтобы объекты пользовательских классов поддерживали определенный функционал, им достаточно содержать лишь необходимые методы. Скажем, для того чтобы иметь возможность обращаться к объекту через квадратные скобки `[]`, достаточно иметь метод `__getitem__()`. При этом Python не требует, чтобы соответствующие классы были унаследованы от `Sequence` или `Mapping`. Однако нужно понимать, что использование модуля `collections.abc` все-таки дает определенные преимущества. Во-первых, мы получаем возможность разделять разные типы данных по их возможностям, а во-вторых мы получаем уже реализованные методы на основе абстрактных методов. Например, унаследовавшись от `Sequence`, нам достаточно реализовать методы `__getitem__()` и `__len__()`. При этом методы  `__contains__(), __iter__(), __reversed__(), index()`  и `count()` будут реализованы автоматически.

**Примечание 6.** Не забывайте, что наследник абстрактного класса должен переопределить **все** абстрактные методы, иначе экземпляр такого класса будет невозможно создать.

## 7.6 Множественное наследование
### Тема урока: множественное наследование

1. Множественное наследование
2. Проблема ромбовидного наследования
3. Method Resolution Order (MRO)

**Аннотация.** Урок посвящен множественному наследованию в Python.

### Множественное наследование

В предыдущих уроках мы познакомились с наследованием, или точнее с **одиночным наследованием**, при котором класс наследуется от одного другого класса. Помимо этого в Python реализовано **множественное наследование**, при котором класс наследуется от двух или более классов одновременно. В этом случае дочерний класс наследует все атрибуты и методы всех родительских классов.

Синтаксис множественного наследования практически ничем не отличается от одиночного. Единственная разница в том, что при определении дочернего класса в скобках мы указываем не один родительский класс, а несколько через запятую:

```python
class Parent1:                                       # первый родительский класс
    pass

class Parent2:                                       # второй родительский класс
    pass

class Child(Parent1, Parent2):                       # дочерний класс
    pass
```

Важно не путать множественное наследование с многоуровневым наследованием. При множественном наследовании класс определяется как наследник двух или более классов одновременно, при многоуровневом наследовании каждый класс цепочки определяется как наследник лишь одного класса:

![](https://ucarecdn.com/de28ee02-ff8c-49dd-8577-a7c3b8534843/)

Рассмотрим иерархию из уже знакомых нам классов `Cat` и `Dog`, к которой добавим их наследника в лице класса `CatDog`, описывающего мультипликационного персонажа — котопса:

```python
class Cat:
    def meow(self):
        return 'мяу'

class Dog:
    def bark(self):
        return 'гав'

class CatDog(Cat, Dog):
    pass
```

[![](https://ucarecdn.com/4a6deea7-cb43-4dcb-8b92-e1b323df1e93/)](https://stepik.org/media/attachments/lesson/841344/%D0%9B%D1%8E%D0%B1%D0%B8%D0%BC%D1%8B%D0%B9_%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BA_%D0%A2%D0%B8%D0%BC%D1%83%D1%80%D0%B0.mp4)

В классе `Cat` определен метод `meow()`, в классе `Dog` определен метод `bark()`, и класс `CatDog`, являясь их наследником, может пользоваться обоими этими методами.

Приведенный ниже код:

```python
class Cat:
    def meow(self):
        return 'мяу'

class Dog:
    def bark(self):
        return 'гав'

class CatDog(Cat, Dog):
    pass


catdog = CatDog()

print(catdog.meow())
print(catdog.bark())
```

выводит:

```no-highlight
мяу
гав
```

Функционально множественное наследование повторяет одиночное наследование. Мы получаем возможность в дочернем классе пользоваться атрибутами и методами всех указанных родительских классов с последующим их переопределением или расширением. Однако множественное наследование, в отличие от одиночного, является потенциальным источником ошибок, которые могут возникнуть из-за наличия одинаковых имен атрибутов и методов в родительских классах.

При множественном наследовании класс может иметь неограниченное количество родительских классов.

В одиночном, а точнее в многоуровневом наследовании, иерархия классов представляет собой линейную структуру, в которой классы располагаются в том порядке, в котором наследуются друг от друга. И здесь ситуация, когда в нескольких родительских классах определен метод с одним и тем же именем, не является проблемой: текущим классом будет унаследован метод того родительского класса, который ближе к текущему в иерархии.

Приведенный ниже код:

```python
class Animal:
    def sound(self):
        pass
    
class Cat(Animal):
    def sound(self):
        return 'мяу'

class Kitten(Cat):
    pass


kitten = Kitten()

print(kitten.sound())
```

выводит:

```no-highlight
мяу
```

В случае множественного наследования иерархия классов представляет собой ветвистую структуру, а не линейную, и зачастую бывает не так просто определить, одноименный метод какого родительского класса будет унаследован текущим классом.

### Проблема ромбовидного наследования

Проблема ромбовидного наследования — это типичная проблема при множественном наследовании. Она заключается в двусмысленности, возникающей, когда два класса `B` и `C` наследуются от класса `A`, а другой класс `D` наследуется от классов `B` и `C`.

Описанную иерархию можно изобразить следующим образом:

![](https://ucarecdn.com/c6d9a8bb-fc8c-45c7-852e-086fb9faf270/-/crop/448x416/0,18/-/preview/)

В обозначениях Python она будет иметь вид:

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```

Указанная выше диаграмма иерархии классов `A, B, C` и `D` представляет собой ромб, именно поэтому неоднозначность, возникающую при подобном наследовании, называют проблемой ромбовидного наследования. Проблемой, потому что, например, если в классе `A` есть метод `method()`, который класс `B` или `C` переопределил (или они оба переопределили), то возникает вопрос, какую версию этого метода должен унаследовать класс `D`?

Рассмотрим одну из упомянутых ситуаций. Определим одноименный метод в классах `A, B` и `C` и проверим, какой из них будет унаследован классом `D`.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса B
```

В данной ситуации класс `D` унаследовал метод класса `B`, и этот выбор не является случайным. В Python проблема ромбовидного наследования решается с помощью **MRO**.

### Method Resolution Order (MRO)

В Python существует строгий порядок, в котором просматриваются классы во время поиска конкретного метода в иерархии классов при наследовании. Этот порядок определяется для каждого класса индивидуально в зависимости от его иерархии и называется **Method Resolution Order** или сокращенно **MRO**.

Для получения MRO класса достаточно воспользоваться методом `mro()`. Его результатом является список родителей класса, включая сам класс, расположенных ровно в том порядке, в котором Python будет производить поиск методов.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


print(D.mro())
```

выводит:

```no-highlight
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

MRO класса также можно получить с помощью атрибута класса `__mro__`.

Определив MRO класса, мы всегда можем точно сказать, какой из методов будет унаследован этим классом в том или ином случае, так как знаем, в каком порядке будут проверяться его родительские классы при поиске метода. Так, в нашей ромбовидной иерархии классов `A, B, C` и `D` мы видим, что в MRO класса `D` класс `B` находится перед классами `A` и `C`, следовательно, определенный во всех трех родительских классах метод `method()` будет унаследован именно из класса `B`.

Например, если метод `method()` будет определен только в классах `A` и `C`, то унаследованный метод будет принадлежать классу `C`, потому что в MRO класса `D` класс `C` находится перед классом `A`.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    pass
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса C
```

Аналогично, если метод `method()` будет определен только в классе `A`, то унаследованный метод будет принадлежать именно этому классу.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    pass
        
class C(A):
    pass

class D(B, C):
    pass


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса A
```

Наконец, если метод `method()` будет определен во всех родительских классах, включая сам класс `D`, то использоваться будет метод, реализованный именно в классе `D`.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    def method(self):
        print('Метод класса D')


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса D
```

MRO решает основную проблему множественного наследования — неоднозначность, возникающую при ромбовидном наследовании. Зная MRO класса, мы всегда можем определить, какой метод будет унаследован этим классом, независимо от сложности его иерархии.

В MRO любого класса на первом месте всегда указывается исходный класс, а на последнем — класс `object`.

#### Простейшее построение MRO

В случае простейшего множественного наследования алгоритм построения MRO не вызывает трудностей, так как представляет собой поиск в глубину, слева направо, то есть сперва проверяется иерархия первого родительского класса, затем иерархия второго родительского класса, и так далее, с последующим исключением из полученной последовательности повторяющихся классов, кроме их последних включений.

Если мы попытаемся самостоятельно определить MRO класса `D` из нашей ромбовидной иерархии:

```python
class A:
    pass
        
class B(A):
    pass
        
class C(A):
    pass

class D(B, C):
    pass
```

то сперва укажем класс `D`, затем иерархию первого родительского класса `B`, а после иерархию второго родительского класса `C`:

```no-highlight
D, B, A, object, C, A, object
```

Затем исключим из полученной последовательности повторяющиеся классы, кроме их последних включений, и получим MRO класса `D`:

```no-highlight
D, B, C, A, object
```

Данный способ не является решением в общем виде, он может служить лишь подсказкой при простейшем множественном наследовании, когда иерархии родительских классов представлены в виде линейных структур. В общем же случае алгоритм построения MRO имеет более сложный вид.

Алгоритм построения MRO называется C3-линеаризация. Ознакомиться с принципом его работы можно в официальной документации по [ссылке](https://www.python.org/download/releases/2.3/mro/).

#### Невозможность построения MRO

Алгоритм, с помощью которого Python строит MRO класса, имеет ряд правил, в число которых входят следующие:

- **Правило наследования.** Если некоторый класс `D` является наследником классов `A, B, C`, то при построении MRO эти классы должны располагаться в том порядке, в котором они были указаны в определении класса `D`, причем между ними могут располагаться другие классы, однако их исходный порядок должен остаться неизменным
- **Правило старшинства.** При построении MRO все классы иерархии должны располагаться в порядке старшинства, то есть ни один родительский класс не должен следовать перед своим дочерним классом.

Возможны ситуации, когда иерархия классов при множественном наследовании такова, что алгоритм при построении MRO не может соблюсти эти правила, в таких случаях построение MRO считается невозможным. Рассмотрим две ситуации множественного наследования, в которых не соблюдается хотя бы одно из приведенных выше правил и MRO построить нельзя.

**Ситуация 1.** Построение MRO класса `C` при следующей иерархии классов:

```python
class A:
    pass

class B(A):
    pass

class C(A, B):
    pass
```

является невозможным по той причине, что каково бы ни было MRO, не соблюдается либо правило наследования, либо правило старшинства:

- правило наследования нарушается при следующем построении MRO:
    
    ```no-highlight
    C, B, A, object
    ```
    
    Так как классы `A` и `B` должны располагаться в том порядке, в котором были указаны в определении класса `C`
- правило старшинства нарушается при следующем построении MRO:
    
    ```no-highlight
    C, A, B, object
    ```
    
    Так как ни один родительский класс не должен следовать перед своим дочерним классом, в данном случае родительским классом является класс `A`, дочерним — класс `B`
    

**Ситуация 2.** Построение MRO класса `E`  при следующей иерархии классов:

```python
class A:
    pass

class B:
    pass

class C(A, B):
    pass

class D(B, A):
    pass

class E(C, D):
    pass
```

является невозможным по той причине, что по правилу наследования родители класса `C` должны быть расположены в порядке `A, B`, в то время как по тому же правилу родители класса `D` должны быть расположены в порядке `B, A`. В MRO класса `E` должны быть соблюдены оба порядка, но этого сделать нельзя, так как они противоречат друг другу.

## Примечания

**Примечание 1.** При недавнем рассмотрении функции `super()` было упомянуто, что она предоставляет доступ ко всем классам в иерархии наследования, а не к конкретному родительскому классу. При поиске необходимого метода в этой иерархии функция `super()` использует MRO.

Приведенный ниже код:

```python
class A:
    pass
        
class B(A):
    pass
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    def method(self):
        super().method()


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса C
```

**Примечание 2.** Дополнительно о множественном наследовании можно почитать в официальной документации по [ссылке](https://docs.python.org/3/tutorial/classes.html#multiple-inheritance).

**Примечание 3.** Обратите внимание, что даже самое простое множественное наследование является ромбовидным, так как все классы в Python являются наследниками класса `object`:

```python
class A(object):
    pass

class B(object):
    pass

class C(A, B):
    pass
```

**Примечание 4.** При множественном наследовании атрибуты класса ведут себя так же, как и методы, то есть наследуются дочерним классом со всеми вытекающими особенностями.

Приведенный ниже код:

```python
class Animal:
    en_name = 'animal'
    ru_name = 'животное'

class Cat(Animal):
    en_name = 'cat'
    ru_name = 'кот'

class Dog(Animal):
    en_name = 'dog'
    ru_name = 'собака'
    
class CatDog(Cat, Dog):
    pass


print(CatDog.en_name)
print(CatDog.ru_name)
```

выводит:

```no-highlight
cat
кот
```

**Примечание 5.** Попытка создать класс, MRO которого невозможно определить, приводит к возбуждению исключения.

Приведенный ниже код:

```python
class A:
    pass

class B(A):
    pass

class C(A, B):
    pass
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Cannot create a consistent method resolution
order (MRO) for bases A, B
```

## 7.7 Полиморфизм
### Тема урока: полиморфизм

1. Понятие полиморфизма
2. Полиморфизм операторов
3. Полиморфизм функций
4. Полиморфизм в методах классов

**Аннотация.** Урок посвящен полиморфизму в Python.

### Понятие полиморфизма

**Полиморфизм** — это множество форм. Однако в понятиях ООП имеется в виду, скорее, обратное. Объекты разных классов, с разной внутренней реализацией, могут иметь одинаковые интерфейсы. Например, для чисел есть операция сложения, обозначаемая знаком `+`. Однако мы можем определить класс, объекты которого также будут поддерживать операцию, обозначаемую этим знаком, но это вовсе не значит, что объекты должны быть числами и будет получаться какая-то сумма. Операция `+` для объектов нашего класса может значить что-то иное. Но интерфейс, в данном случае это знак `+`, у чисел и нашего класса будет одинаков. Полиморфность же проявляется во внутренней реализации и результате операции.

### Полиморфизм операторов

Мы уже сталкивались с полиморфизмом операции `+` в языке Python. Для чисел она обозначает сложение, а для строк — конкатенацию. Внутренняя реализация оператора `+` существенно отличается для целых чисел, чисел с плавающей точкой и строк. То есть на самом деле это три разные операции — интерпретатор Python выбирает одну из них при выполнении в зависимости от операндов.

Приведенный ниже код:

```python
print(10 + 20)
print(10.5 + 20.8)
print('bee' + 'geek')
```

выводит:

```no-highlight
30
31.3
beegeek
```

Здесь мы можем увидеть единственный оператор `+`, выполняющий разные операции для разных типов данных. Это один из самых простых примеров полиморфизма в Python, благодаря которому мы можем выполнять разные действие одинаковыми способами, другими словами, определять один интерфейс и иметь множество реализаций.

### Полиморфизм функций

В Python есть некоторые функции, которые могут работать с объектами разных типов. Одной из таких функций является функция `len()`.

Приведенный ниже код:

```python
print(len('beegeek'))
print(len(['beegeek', 'stepik', 'python']))
print(len({'name': 'Timur', 'city': 'Dubai'}))
```

выводит:

```no-highlight
7
3
2
```

Здесь мы можем увидеть, что различные типы данных, такие как строка, список, кортеж, множество и словарь могут быть обработаны функцией `len()`. Для каждого типа данных она возвращает специфичную для него информацию: для строк — количество символов, для списка — количество элементов, для словаря — количество пар ключ-значение.

### Полиморфизм в методах классов

В Python различные классы могут иметь методы с одинаковыми именами, что позволяет нам при их определении использовать концепцию полиморфизма, с помощью которого мы сможем обобщить вызов этих методов и игнорировать тип объекта, с которым работаем. 

Рассмотрим похожие по структуре классы `Cat` и `Dog`, описывающие кошку и собаку соответственно:

```
class Cat:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'мяу'

class Dog:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'гав'
```

Экземпляры обоих классов имеют атрибут `name` и метод `sound()`, и концепция полиморфизма в данном случае заключается в том, что нам неважно, с экземпляром класса `Cat` или `Dog` мы работаем, главное, что мы знаем о наличии у него атрибута и метода, к которым можем обратиться.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'мяу'

class Dog:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'гав'


cat = Cat('Кемаль')
dog = Dog('Роджер')

for animal in (cat, dog):
    print(f'{animal.name} говорит {animal.sound()}')
```

выводит:

```no-highlight
Кемаль говорит мяу
Роджер говорит гав
```

Обратите внимание, что мы не создавали общего класса-родителя и не соединяли классы вместе каким-либо другим способом. Тем не менее, мы можем объединить экземпляры этих классов в кортеж и проитерироваться по нему, используя общую переменную `animal`. Если переменная `animal` ссылается на экземпляр класса `Cat`, выполняются методы, определенные в этом классе, если на экземпляр класса `Dog` — методы класса `Dog`.

Также тело цикла может быть заменено на вызов полиморфной функции, которая будет верно работать с экземплярами обоих классов, благодаря наличию у них атрибута `name` и метода `sound()`.

Приведенный ниже код:

```python
def say(animal):
    return f'{animal.name} говорит {animal.sound()}'

class Cat:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'мяу'

class Dog:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'гав'


cat = Cat('Кемаль')
dog = Dog('Роджер')

for animal in (cat, dog):
    print(say(animal))
```

выводит:

```no-highlight
Кемаль говорит мяу
Роджер говорит гав
```

Данный подход позволяет заранее написать функцию, которая будет работать со всеми экземплярами любых классов — даже еще не существующих. Важно лишь, чтобы эти классы поддерживали необходимый функции интерфейс.

Чтобы полиморфизм работал, за ним надо следить как на уровне синтаксиса (одинаковые имена методов и количество параметров), так и на уровне смысла (методы с одинаковыми именами делают похожие операции, параметры методов имеют тот же смысл). Например, если в одном из классов, представленных выше, один из методов `sound()` будет не возвращать строку, а печатать, то синтаксически все будет верно, однако результат окажется неверным.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def sound(self):
        print('мяу')

class Dog:
    def __init__(self, name):
        self.name = name

    def sound(self):
        return 'гав'


cat = Cat('Кемаль')
dog = Dog('Роджер')

for animal in (cat, dog):
    print(f'{animal.name} говорит {animal.sound()}')
```

выводит:

```no-highlight
мяу
Кемаль говорит None
Роджер говорит гав
```

### Примечания

**Примечание 1.** Полиморфизм в переводе с греческого означает нечто, что обладает множеством форм. Однако в ООП смысл немного иной — есть одна форма (интерфейс), но разные содержания (реализации).

**Примечание 2.** Без полиморфизма может потребоваться проверка типа перед выполнением действия над объектом, чтобы определить правильный метод для вызова. Полиморфизм позволяет избавиться от лишних условий и избыточного кода в целом.

**Примечание 3.** Python является языком с динамической типизацией, поэтому на самом деле с полиморфизмом мы неявно знакомы с самого начала его изучения. Например, обычный оператор `+` для сложения чисел является полиморфным, и может работать с объектами других типов, однако уже выполнять иную операцию от сложения чисел.

Приведенный ниже код:

```python
def f(x, y):
    return x + y

print(f(1, 2))
print(f(1.5, 2.5))
print(f([1, 2], [3, 4]))
```

выводит:

```no-highlight
3
4.0
[1, 2, 3, 4]
```

В языках со статической типизацией подобное невозможно, так как в них каждая переменная имеет определенный тип. Поэтому для определения функции, которая бы, помимо сложения, скажем, целых чисел, складывала и вещественные числа, для каждого случая нам бы пришлось определить отдельную реализацию.

Функция для сложения целых и вещественных чисел, а также их комбинаций на примере С++:

```cpp
#include <iostream>

using namespace std;

int f(int x, int y )
{
    return x + y;
}
double f(int x, double y)
{
    return x + y;
}
double f(double x, int y)
{
    return x + y;
}
double f(double x, double y)
{
    return x + y;
}
```

**Примечание 4.** Перегрузка методов — создание методов с одним и тем же именем, но с разными типами аргументов не поддерживается в Python.

**Примечание 5.** ​​​​​​​Не забывайте, что в Python используется утиная типизация, которая заключается в том, что конкретный тип объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает.

## 7.8 Композиция
### Тема урока: композиция

1. Композиция
2. Композиция и наследование

**Аннотация.** Урок посвящен композиции при проектировании классов.

### Композиция

В объектно-ориентированных языках программирования существует несколько способов организации взаимодействия между классами, одним из которых является наследование. Суть наследования заключается в создании дочернего класса, имеющего все атрибуты и методы родительского класса. Наследование описывается словом **является**: кошка является животным, автомобиль является транспортом.

В этом уроке мы поговорим еще об одном способе — **композиции**. Композиция представляет собой ситуацию, когда экземпляр одного класса **включает в себя** экземпляр другого класса. Класс, экземпляр которого содержит экземпляр другого класса, называют **составным**. Класс, экземпляр которого содержится в экземпляре другого класса, называют **компонентным**. Композиция описывается словом **имеет**: кошка имеет лапы, автомобиль имеет двигатель.

Композиция позволяет составному классу использовать функционал компонентного класса, не наследуясь от него. Примером может служить класс `UserDict` из модуля `collections`, экземпляр которого внутренне содержит экземпляр класса `dict`, используя функционал которого реализует свой.

В отличие от наследования, композиция не выстраивает строгие иерархические отношения между классами. Это означает, что изменения в компонентном классе редко влияют на составной класс, а изменения в составном классе никогда не влияют на компонентный класс. При рассмотрении программ, одна из которых основана на наследовании, а другая — на композиции, композиционное решение обычно является наиболее гибким.

Рассмотрим несколько примеров композиции и начнем с самого простого — класса `Rectangle`, описывающего прямоугольник.

Приведенный ниже код:

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length                                  # длина прямоугольника
        self.width = width                                    # ширина прямоугольника


rectangle = Rectangle(1, 2)

print(type(rectangle))
print(type(rectangle.length))
print(type(rectangle.width))
```

выводит:

```no-highlight
<class '__main__.Rectangle'>
<class 'int'>
<class 'int'>
```

Экземпляры класса `Rectangle` содержат информацию о сторонах прямоугольника, которые в нашем случае представляются экземплярами класса `int`. Таким образом, классы `Rectangle`  и `int` образуют собой композицию, где класс `Rectangle` является составным, а `int` — компонентным.

Мы можем определить в классе `Rectangle` набор методов для вычисления периметра и площади прямоугольника, используя имеющиеся данные о его сторонах.

Приведенный ниже код:

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def perimeter(self):
        return (self.length + self.width) * 2                 # периметр прямоугольника
    
    def area(self):
        return self.length * self.width                       # площадь прямоугольника


rectangle = Rectangle(1, 2)

print(rectangle.perimeter())
print(rectangle.area())
```

 выводит:

```no-highlight
6
2
```

Далее перейдем к случаю, когда компонентный класс является пользовательским, а не встроенным. Для этого рассмотрим класс `Square`, описывающий квадрат, который внутренне содержит экземпляр класса `Rectangle` с равными значениями длины и ширины.

Приведенный ниже код:

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def perimeter(self):
        return (self.length + self.width) * 2
    
    def area(self):
        return self.length * self.width

class Square:
    def __init__(self, side):
        self.value = Rectangle(side, side)                    # прямоугольник с равными сторонами


square = Square(2)

print(type(square))
```

выводит:

```no-highlight
<class '__main__.Square'>
```

Класс `Square` не является наследником класса `Rectangle`, поэтому экземпляр класса `Square` не имеет методов `perimeter()` и `area()` класса `Rectangle`, однако он внутренне содержит экземпляр класса `Rectangle`, через который может пользоваться этими методами. Таким образом, класс `Square` может определить собственные методы `perimeter()` и `area()`, но не реализовывать их функционал.

Приведенный ниже код:

```python
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def perimeter(self):
        return (self.length + self.width) * 2
    
    def area(self):
        return self.length * self.width

class Square:
    def __init__(self, side):
        self.value = Rectangle(side, side)
        
    def perimeter(self):
        return self.value.perimeter()
    
    def area(self):
        return self.value.area()

square = Square(2)

print(square.perimeter())
print(square.area())
```

выводит:

```no-highlight
8
4
```

Композиция — это слабосвязанные отношения, которые часто не требуют, чтобы составной класс знал о реализации компонентного класса.

Изобразить взаимосвязь между классами `Rectangle` и `Square`, а также классом `int`, являющимся компонентным для первого, можно следующим образом:

![](https://ucarecdn.com/beb21cc3-b67e-4f54-ab28-a3977d89daa3/-/crop/779x336/66,52/-/preview/)

В начале урока мы упомянули, что композиция описывается словом **имеет**: кошка имеет лапы, автомобиль имеет двигатель. Однако пример выше недостаточно наглядно демонстрирует это отношение, так как трудно в неформальном виде представить квадрат, владеющий прямоугольником. Поэтому в качестве второго примера, сперва без композиции, рассмотрим класс `Employee`, описывающий наемного работника:

```python
class Employee:
     def __init__(self, name, pay, bonus=0):
         self.name = name                                     # имя работника
         self.pay = pay                                       # ежемесячная зарплата
         self.bonus = bonus                                   # ежегодная премия, по умолчанию равна 0
```

Определим в этом классе метод `total_salary()`, возвращающий сумму, которую работник получает за год.

Приведенный ниже код:

```python
class Employee:
     def __init__(self, name, pay, bonus=0):
         self.name = name
         self.pay = pay
         self.bonus = bonus
    
     def total_salary(self):
         return 12 * self.pay + self.bonus                    # годовая зарплата


employee = Employee('Гвидо', 100000, 10000)

print(employee.total_salary())
```

выводит:

```no-highlight
1210000
```

Несмотря на то что класс `Employee` работает как и требуется, он выполняет неприсущие ему операции, а именно вычисляет годовую заработную плату, хотя его задачей по большей части является лишь хранение этого значения. Поэтому мы можем определить класс `Salary`, описывающий зарплату, который содержит набор методов, выполняющих необходимые вычисления, а в классе `Employee` лишь пользоваться этими методами.

Приведенный ниже код:

```python
class Salary:
    def __init__(self, pay, bonus):
        self.pay = pay                                        # ежемесячная зарплата
        self.bonus = bonus                                    # ежегодная премия

    def annual_salary(self):
        return 12 * self.pay + self.bonus                     # годовая зарплата

class Employee:
     def __init__(self, name, pay, bonus):
         self.name = name
         self.salary = Salary(pay, bonus)                     # объект, содержащий все данные о зарплате

     def total_salary(self):
         return self.salary.annual_salary()


employee = Employee('Гвидо', 100000, 10000)

print(employee.total_salary())
```

выводит:

```no-highlight
1210000
```

Здесь взаимосвязь между классами, которая описывается словом **имеет**, более наглядна, так как работник, представленный экземпляром класса `Employee`, буквально имеет имя и имеет заработную плату, представленные экземплярами классов `str` и `Salary` соответственно.

Композиция — это построение целого из частей с минимальной взаимосвязью.

Может возникнуть вопрос о целесообразности применения композиции в данном случае, ведь мы определили дополнительный класс и, по сути, увеличили количество кода вдвое. Однако стоит отметить, что сам код стал проще, так как вычисления в классе `Employee` были заменены на вызов говорящего метода. Также, если в дальнейшем нам нужно будет производить какие-либо операции с зарплатой, например, вычислять полугодовое значение без премии, мы снова определим соответствующий метод в классе `Salary` и лишь воспользуемся им в классе `Employee`.

### Композиция и наследование

Частым вопросом является выбор между композицией и наследованием, ведь они оба позволяют повторно использовать код и могут решать аналогичные проблемы. Зачастую в качестве правила, определяющего отношение между классами, предлагается выбор слова, связывающего эти классы: **является** или **имеет**. Если подходит первое слово, то предпочтение стоит отдать наследованию, если второе — композиции.

Наследование используется, когда класс хочет получить весь функционал родительского класса, а затем расширить его, определив новые методы, или изменить, переопределив уже имеющиеся. В случае с композицией мы можем только использовать этот класс и не имеем возможности его изменить. Таким образом, когда нужно использовать класс как таковой без каких-либо модификаций, рекомендуется композиция, а когда нужно изменить поведение метода в другом классе, рекомендуется наследование.

Общий совет заключается в использовании отношения, которое создает меньше зависимостей между двумя классами. Этим отношением является композиция. Не путайте композицию с наследованием. Композиция означает, что объект знает другой объект и явно делегирует ему некоторые задачи.

### Примечания

**Примечание 1.** Нередко в программировании ситуацию, когда экземпляр одного класса включает в себя экземпляр другого класса, разделяют на два типа: композицию и агрегацию. В первом случае считается, что экземпляр компонентного класса создается внутри экземпляра составного класса и не существует отдельно от него. Во втором случае, наоборот, экземпляр компонентного класса создается отдельно от экземпляра составного класса и передается в качестве аргумента при создании второго.

Пример композиции:

```python
class Salary:
    def __init__(self, pay, bonus):
        self.pay = pay
        self.bonus = bonus

class Employee:
     def __init__(self, name, pay, bonus):
         self.name = name
         self.salary = Salary(pay, bonus)


employee = Employee('Гвидо', 100000, 10000)
```

Пример агрегации:

```python
class Salary:
    def __init__(self, pay, bonus):
        self.pay = pay
        self.bonus = bonus

class Employee:
     def __init__(self, name, salary):
         self.name = name
         self.salary = salary


salary = Salary(100000, 10000)
employee = Employee('Гвидо', salary)
```

**Примечание 2.** Ветка на StackOverflow с большим количеством рассуждений на тему того, чему стоит отдавать предпочтение, композиции или наследованию, доступна по [ссылке](https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance).

![](https://ucarecdn.com/aa5fd709-3593-4395-865a-ddcf71320866/-/crop/896x472/0,34/-/preview/)

# 8. Дополнительные возможности
## 8.1 Слоты, атрибут __slots__
### Тема урока: слоты, атрибут __slots__

1. Слоты
2. Атрибут `__slots__`
3. Слоты при наследовании
4. Сравнение производительности

**Аннотация.** Урок посвящен слотам и их особенностям.

### Слоты

Рассмотрим класс `Point`, описывающий точку на плоскости:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

Каждый экземпляр данного класса имеет словарь атрибутов `__dict__`, в котором содержатся его атрибуты `x` и `y` — координаты по осям �x и �y соответственно.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


point1 = Point(1, 2)
point2 = Point(3, 4)

print(point1.__dict__)
print(point2.__dict__)
```

выводит:

```no-highlight
{'x': 1, 'y': 2}
{'x': 3, 'y': 4}
```

По умолчанию Python использует словарь для управления атрибутами экземпляра класса. При необходимости словарь позволяет добавлять экземпляру дополнительные атрибуты. Однако это в то же время влечет расход памяти, например, если экземпляров класса оказывается достаточно много.

Для оптимизации потребляемой памяти в Python были добавлены слоты. Если экземпляры некоторого класса содержат только фиксированный (определенный заранее) набор атрибутов, мы можем использовать слоты, чтобы вместо словарей использовалась более компактная структура данных.

### Атрибут __slots__

Для реализации слотов в Python используется атрибут класса `__slots__`. С помощью данного атрибута мы определяем набор атрибутов, которыми может обладать экземпляр класса.

Например, если экземпляры нашего класса `Point`, описывающего точку на плоскости, всегда содержат только два атрибута — координаты точки по осям �x и �y, то мы можем указать данные атрибуты в слотах следующим образом:

```python
class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y
```

В качестве значения `__slots__` мы указываем кортеж, содержащий строковые имена атрибутов, которыми может обладать экземпляр класса `Point`. Следует отметить, что имена атрибутов, помимо принадлежности к типу `str`, должны быть корректными с точки зрения правил именования атрибутов в Python.

Значением атрибута `__slots__` может быть любой итерируемый объект, однако на практике используют кортеж.

После определения слотов в классе Python не будет использовать словарь `__dict__` для управления атрибутами экземпляров этого класса.

Приведенный ниже код:

```python
class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


point = Point(1, 2)

print(point.__dict__)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Point' object has no attribute '__dict__'. Did you mean: '__dir__'?
```

Также пропадет возможность добавлять экземплярам класса новые атрибуты.

Приведенный ниже код:

```python
class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


point = Point(1, 2)

point.z = 3

print(point.z)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Point' object has no attribute 'z'
```

Так как `__slots__` является обыкновенным атрибутом класса, обращаться к нему можно как через сам класс, так и через его экземпляры.

Приведенный ниже код:

```python
class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


point = Point(1, 2)

print(Point.__slots__)
print(point.__slots__)
```

выводит:

```no-highlight
('x', 'y')
('x', 'y')
```

### Слоты при наследовании

Рассмотрим поведение слотов при наследовании. Определим родительский класс `Point2D`, описывающий точку на плоскости, и его дочерний класс `Point3D`, описывающий точку в пространстве.

```python
class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Point3D(Point2D):
    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z
```

Класс `Point3D` не имеет слотов, поэтому его экземпляры имеют словарь атрибутов `__dict__`. Таким образом, дочерний класс `Point3D` использует как слоты из родительского класса, так и словарь атрибутов `__dict__`.

Приведенный ниже код:

```python
class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Point3D(Point2D):
    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z


point = Point3D(1, 2, 3)

print(point.x, point.y, point.z)
print(point.__slots__)
print(point.__dict__)
```

 выводит:

```no-highlight
1 2 3
('x', 'y')
{'z': 3}
```

Такое поведение разрешает нам определять дополнительные атрибуты для экземпляров дочернего класса. Если мы хотим, чтобы дочерний класс также использовал слоты, мы можем определить их в нем самом.

Приведенный ниже код:

```python
class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Point3D(Point2D):
    __slots__ = ('z',)

    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z

point = Point3D(1, 2, 3)

print(point.x, point.y, point.z)
print(point.__slots__)
```

 выводит:

```no-highlight
1 2 3
('z',)
```

Определяя слоты в дочернем классе, дублировать слоты родительского класса не нужно.

Теперь экземпляры класса `Point3D` будут использовать слоты для всех своих атрибутов `x, y` и `z`, при этом не будут иметь словарь атрибутов `__dict__`.

Приведенный ниже код:

```python
class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

class Point3D(Point2D):
    __slots__ = ('z',)

    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z


point = Point3D(1, 2, 3)

print(point.__dict__)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Point3D' object has no attribute '__dict__'. Did you mean: '__dir__'?
```

### Сравнение производительности

Одной из причин использования слотов может быть желание увеличить производительность класса путем ускорения выполнения некоторых операций и снижения потребляемой памяти.

#### Доступ к атрибутам

Для сравнения скорости доступа к атрибутам воспользуемся функцией `repeat()` из модуля `timeit`.

Приведенный ниже код:

```python
from timeit import repeat

class PointWithoutSlots:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class PointWithSlots:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

def get_set_test(cls):
    obj = cls(0, 0)
    def get_set():
        obj.x += 1
        obj.y += 2
    return get_set


print(max(repeat(get_set_test(PointWithoutSlots))))    # результат класса без слотов
print(max(repeat(get_set_test(PointWithSlots))))       # результат класса со слотами
```

в среднем выводит:

```no-highlight
0.11013359995558858
0.09572770004160702
```

Класс с использованием слотов в среднем на `15-20 %` быстрее в операциях доступа к атрибутам.

Документация по модулю `timeit` доступна по [ссылке](https://docs.python.org/3/library/timeit.html).

#### Потребляемая память

Для сравнения потребляемой памяти воспользуемся функцией `asizeof()` из модуля `pympler.asizeof`.

Приведенный ниже код:

```python
from pympler import asizeof

class PointWithoutSlots:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class PointWithSlots:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


point1 = PointWithoutSlots(0, 0)
point2 = PointWithSlots(0, 0)

print(asizeof.asizeof(point1))                         # результат класса без слотов
print(asizeof.asizeof(point2))                         # результат класса со слотами
```

выводит:

```no-highlight
288
72
```

Экземпляры классов с использованием слотов занимают меньше памяти, чем экземпляры классов без использования слотов. Значительную экономию памяти можно получить в ситуациях, когда создается большое количество экземпляров классов.

### Примечания

**Примечание 1.** Прочитать про использование атрибута `__slots__` можно по [ссылке](https://wiki.python.org/moin/UsingSlots%C2%A0).

**Примечание 2.** Если при наследовании родительский класс не использует слоты, а дочерний класс использует, экземпляры дочернего класса все равно будут иметь словарь атрибутов `__dict__`.

Приведенный ниже код:

```
class Shape:
    pass

class Point(Shape):
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


point = Point(1, 2)

print(point.__slots__)
print(point.__dict__)

point.color = 'yellow'
print(point.__dict__)
```

выводит:

```no-highlight
('x', 'y')
{}
{'color': 'yellow'}
```

## 8.2 Перечисления, класс Enum
### Тема урока: перечисления, класс Enum

1. Перечисления
2. Создание перечислений
3. Возможности перечислений

**Аннотация.** Урок посвящен перечислениям в Python.

## Перечисления

В большинстве современных языков программирования поддерживается работа с перечислениями, и Python не является исключением. Мы можем обойтись без них, однако, как и многие другие инструменты, перечисления упрощают процесс написания кода и улучшают его читаемость.

Перечисление — это набор символических имен, привязанных к уникальным постоянным значениям.

Перечисления могут быть полезны, когда нам необходимо определить неизменяемый набор похожих или связанных констант, которые могут иметь смысловое значение. В качестве примеров перечислений можно привести дни недели, времена года, стороны света, цвета на светофоре, коды состояния HTTP.

## Создание перечислений

В Python для создания перечислений используется класс `Enum` из модуля `enum`. Чтобы создать собственное перечисление, мы можем либо создать подкласс `Enum`, либо использовать его функциональную часть. Мы рассмотрим оба способа и начнем с первого.

### Подкласс Enum

Классическим примером использования перечислений является создание набора констант, представляющих дни недели. Каждый день недели имеет название и числовое значение от `1` до `7` включительно.

Рассмотрим класс `Weekday`, представляющий данное перечисление:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7
```

В данном примере `Weekday` — это перечисление. `Weekday.MONDAY, Weekday.TUESDAY` и другие — это элементы перечисления. Элементы имеют имена и значения, например, именем элемента `Weekday.MONDAY` является `MONDAY`, а значением — `1`.

Поскольку перечисления используются для представления констант, имена элементов перечисления рекомендуется записывать в верхнем регистре.

Элементы перечисления являются функциональными константами, и представляют собой экземпляры класса перечисления.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(type(Weekday.MONDAY))
print(type(Weekday.SUNDAY))
```

выводит:

```no-highlight
<enum 'Weekday'>
<enum 'Weekday'>
```

Они имеют атрибуты `name` и `value`, в которых содержатся их имена и значения соответственно, также для них определены методы `__str__()` и `__repr__()` для информативного строкового представления.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(str(Weekday.MONDAY))
print(repr(Weekday.MONDAY))
print(Weekday.MONDAY.name)
print(Weekday.MONDAY.value)
```

выводит:

```no-highlight
Weekday.MONDAY
<Weekday.MONDAY: 1>
MONDAY
1
```

Поскольку перечисления используются для представления констант, изменение значений их элементов невозможно, и приводит к возбуждению исключения.

Зачастую элементы перечислений принимают последовательные целочисленные значения, однако они могут быть любыми и принадлежать любому типу. Например, мы можем использовать строковые значения для представления размерной сетки верхней одежды.

Приведенный ниже код:

```python
from enum import Enum

class Size(Enum):
    S = 'small'
    M = 'medium'
    L = 'large'
    XL = 'extra large'


print(Size.S)
print(Size.S.name)
print(Size.S.value)
```

выводит:

```python
Size.S
S
small
```

### Функция Enum

Для создания перечислений мы можем обойтись без использования синтаксиса создания классов, а лишь воспользоваться функциональной частью класса `Enum`, которая подразумевает вызов `Enum` с соответствующим набором аргументов. В качестве первого аргумента мы должны указать имя класса перечисления, а в качестве второго — имена элементов перечисления. Второй аргумент может быть представлен любым итерируемым объектом, содержащим имена, или строкой, в которой имена разделены одним пробелом.

Приведенный ниже код:

```python
from enum import Enum

Weekday = Enum('Weekday', ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'])

print(str(Weekday.MONDAY))
print(repr(Weekday.MONDAY))
print(type(Weekday.MONDAY))
print(Weekday.MONDAY.name)
print(Weekday.MONDAY.value)
```

выводит:

```no-highlight
Weekday.MONDAY
<Weekday.MONDAY: 1>
<enum 'Weekday'>
MONDAY
1
```

По умолчанию элементы перечисления принимают последовательные целочисленные значения, начиная с `1`. Это поведение можно изменить, передав при создании необязательный аргумент `start`, который определяет начальное значение.

Приведенный ниже код: 

```python
from enum import Enum

Weekday = Enum('Weekday', ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'], start=0)

print(repr(Weekday.MONDAY))
print(repr(Weekday.TUESDAY))
print(repr(Weekday.WEDNESDAY))
```

выводит:

```python
<Weekday.MONDAY: 0>
<Weekday.TUESDAY: 1>
<Weekday.WEDNESDAY: 2>
```

Также в качестве второго аргумента — имен элементов перечисления — мы можем передать итерируемый объект, в котором представлены пары имя-значение. Таким объектом может быть список кортежей или аналогичный словарь.

Приведенный ниже код:

```python
from enum import Enum

Size = Enum('Size', [('S', 'small'), ('M', 'medium'), ('L', 'large'), ('XL', 'extra large')])

print(str(Size.S))
print(repr(Size.S))
print(type(Size.S))
print(Size.S.name)
print(Size.S.value)
```

выводит:

```python
Size.S
<Size.S: 'small'>
<enum 'Size'>
S
small
```

### Возможности перечислений

#### Доступ к элементам

Основной операцией при работе с перечислениями является доступ к их элементам. Выше мы уже увидели, что обращаться к элементам можно по их именам с помощью точечной нотации, однако помимо этого существуют еще два способа.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(Weekday.MONDAY)                         # точечная нотация с указанием имени элемента
print(Weekday['MONDAY'])                      # доступ по ключу в виде имени элемента
print(Weekday(1))                             # вызов перечисления с аргументом в виде значения элемента
```

выводит:

```no-highlight
Weekday.MONDAY
Weekday.MONDAY
Weekday.MONDAY
```

Обратите внимание, что вызов перечисления используется именно для доступа к элементам по их значениям, а не для создания экземпляров класса. Создание экземпляров класса перечисления путем вызова самого класса невозможно.

#### Итерирование

Перечисления являются итерируемыми объектами, поэтому мы можем, например, перебирать их в цикле или преобразовывать в коллекции.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


for day in Weekday:
    print(day)
```

выводит:

```no-highlight
Weekday.MONDAY
Weekday.TUESDAY
Weekday.WEDNESDAY
Weekday.THURSDAY
Weekday.FRIDAY
Weekday.SATURDAY
Weekday.SUNDAY
```

Мы также можем обращаться к именам и значениям элементов перечисления при итерировании.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


for day in Weekday:
    print(day.name, '->', day.value)
```

выводит:

```no-highlight
MONDAY -> 1
TUESDAY -> 2
WEDNESDAY -> 3
THURSDAY -> 4
FRIDAY -> 5
SATURDAY -> 6
SUNDAY -> 7
```

Элементы перечисления при итерировании располагаются в том порядке, в котором они были определены в классе.

#### Сравнение на равенство и идентичность

Перечисления поддерживают два вида сравнения:

- сравнение на равенство с помощью операторов `==` и `!=`
- сравнение на идентичность с помощью операторов `is` и `is not`

Каждый элемент перечисления является синглтоном, то есть существует в единственном экземпляре, поэтому при сравнении элементов удобно пользоваться более быстрыми операторами `is` и `is not`.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


day = Weekday.MONDAY

print(day is Weekday.MONDAY)
print(day is Weekday.TUESDAY)
print(day is not Weekday.MONDAY)
print(day is not Weekday.WEDNESDAY)
```

выводит:

```no-highlight
True
False
False
True
```

Мы также можем пользоваться операторами `==` и `!=`. Их поведение полностью повторяет поведение операторов `is` и `is not`, так как первые делегируют свои вызовы вторым.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


day = Weekday.MONDAY

print(day == Weekday.MONDAY)
print(day == Weekday.TUESDAY)
print(day != Weekday.MONDAY)
print(day != Weekday.WEDNESDAY)
```

выводит:

```no-highlight
True
False
False
True
```

Так как сравнение с помощью операторов `==` и `!=`, по сути, является сравнением на идентичность, результатом сравнения элементов с их фактическими значениями всегда будет `False`.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(Weekday.MONDAY == 1)
print(Weekday.TUESDAY == 2)
print(Weekday.WEDNESDAY == 3)
```

выводит:

```no-highlight
False
False
False
```

Так как перечисления являются итерируемыми объектами, а их элементы можно сравнивать, мы также можем пользоваться операторами проверки на принадлежность `in` и `not in`. 

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(Weekday.MONDAY in Weekday)
print(Weekday.TUESDAY not in Weekday)
```

выводит:

```no-highlight
True
False
```

#### Условные конструкции

Благодаря тому, что для перечислений доступны операции сравнения на равенство и идентичность, мы можем использовать их в условных конструкциях, делая их более наглядными и очевидными.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7

def what_to_do(day):
    if day is Weekday.SUNDAY:
        print('Сегодня выходной. Отдыхаем =)')
    else:
        print('Сегодня рабочий день. Работаем =(')


what_to_do(Weekday.MONDAY)
what_to_do(Weekday.SUNDAY)
```

выводит:

```no-highlight
Сегодня рабочий день. Работаем =(
Сегодня выходной. Отдыхаем =)
```

Данный подход удобен тем, что в сравнении мы используем объекты с говорящими именами, а не просто какие-либо значения.

#### Сортировка

По умолчанию перечисления не поддерживают операции сравнения с помощью операторов `>, < >=` и `<=`, поэтому для их сортировки необходимо использовать ключевую функцию.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    SUNDAY = 7
    SATURDAY = 6
    FRIDAY = 5
    THURSDAY = 4
    WEDNESDAY = 3
    TUESDAY = 2
    MONDAY = 1


print(sorted(Weekday, key=lambda day: day.value))
```

выводит:

```no-highlight
[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 3>, <Weekday.THURSDAY: 4>, <Weekday.FRIDAY: 5>, <Weekday.SATURDAY: 6>, <Weekday.SUNDAY: 7>]
```

#### Пользовательские методы

Лишь создав класс перечисления и определив в нем набор элементов, мы уже получаем неплохой стартовый функционал, однако по желанию он может быть изменен и расширен.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7

    def about(self):                      # метод экземпляра, возвращающий данные элемента
        return self.name, self.value
 
    def __str__(self):                    # переопределенный магический метод __str__()
        return f'Today is {self.name}'    

    @classmethod              
    def favorite_day(cls):                # метод класса, возращающий элемент Weekday.SUNDAY
        return cls.SUNDAY


day = Weekday.favorite_day()

print(day)
print(day.about())
```

выводит:

```no-highlight
Today is SUNDAY
('SUNDAY', 7)
```

Аналогичным образом мы можем определить методы сравнения элементов перечисления, тем самым добавив возможность их сортировки.

Не забывайте, что элементы перечисления являются экземплярами класса перечисления.

### Примечания

**Примечание 1.** Официальная документация по модулю `enum` доступна по [ссылке](https://docs.python.org/3/library/enum.html#module-enum).

**Примечание 2.** Все перечисления (наследники класса `Enum`) имеют следующие магические методы:

- `__contains__()`
- `__getitem__()`
- `__iter__()`
- `__len__()`
- `__reversed__()`

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(Weekday.SUNDAY in Weekday)
print(Weekday['SUNDAY'])
print(list(Weekday))
print(len(Weekday))
print(list(reversed(Weekday)))
```

выводит:

```no-highlight
True
Weekday.SUNDAY
[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 3>, <Weekday.THURSDAY: 4>, <Weekday.FRIDAY: 5>, <Weekday.SATURDAY: 6>, <Weekday.SUNDAY: 7>]
7
[<Weekday.SUNDAY: 7>, <Weekday.SATURDAY: 6>, <Weekday.FRIDAY: 5>, <Weekday.THURSDAY: 4>, <Weekday.WEDNESDAY: 3>, <Weekday.TUESDAY: 2>, <Weekday.MONDAY: 1>]
```

**Примечание 3.** Чаще всего значениями элементов перечислений являются целые числа, поэтому в модуле `enum` помимо класса `Enum` имеется класс `IntEnum`. Наследуясь от данного класса, можно наделить элементы перечисления всем функционалом целых чисел, а именно возможностью выполнять с ними арифметические операции, а также производить всевозможные сравнения.

Приведенный ниже код:

```python
from enum import IntEnum

class Weekday(IntEnum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(Weekday.MONDAY < Weekday.SUNDAY)
print(Weekday.THURSDAY > Weekday.MONDAY)
print(Weekday.MONDAY + Weekday.SUNDAY)
print(Weekday.SUNDAY - Weekday.MONDAY)
print(Weekday.TUESDAY * Weekday.THURSDAY)
```

выводит:

```no-highlight
True
True
8
6
8
```

При определении перечисления, наследуемого от `IntEnum`, значения элементов должны быть такими, чтобы их можно было преобразовать в целые числа, в ином случае будет возбуждено исключение.

Приведенный ниже код:

```python
from enum import IntEnum

class Weekday(IntEnum):
    MONDAY = 'a'
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7
```

приводит к возбуждению исключения:

```no-highlight
ValueError: invalid literal for int() with base 10: 'a'
```

В Python 3.11 также был добавлен класс `StrEnum`. Подробнее о нем можно почитать по [ссылке](https://docs.python.org/3/library/enum.html#enum.StrEnum).

**Примечание 4.** Элементы перечисления, имеющие одинаковые значения, являются одним и тем же объектом, причем тем, который был создан раньше. На этот объект ссылаются все элементы перечисления, имеющие то же значение, при этом имя может быть любым.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7
    Monday = 1


print(Weekday.MONDAY)
print(Weekday.Monday)
print(Weekday.MONDAY is Weekday.Monday)
```

выводит:

```no-highlight
Weekday.MONDAY
Weekday.MONDAY
True
```

Элементы с одинаковыми значениями, созданные позже, не учитываются при итерировании по перечислению.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7
    Monday = 1


for day in Weekday:
    print(day.name, '->', day.value)
```

выводит:

```no-highlight
MONDAY -> 1
TUESDAY -> 2
WEDNESDAY -> 3
THURSDAY -> 4
FRIDAY -> 5
SATURDAY -> 6
SUNDAY -> 7
```

Если мы хотим, чтобы все элементы перечисления обязательно имели разные значения, то мы можем воспользоваться декоратором `@unique` из модуля `enum`. Данный декоратор приведет к возбуждению исключения, если в перечислении значения каких-либо элементов совпадают.

Приведенный ниже код:

```python
from enum import Enum, unique

@unique
class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7
    Monday = 1
```

приводит к возбуждению исключения:

```no-highlight
ValueError: duplicate values found in <enum 'Weekday'>: Monday -> MONDAY
```

**Примечание 5.** Элементы перечисления являются хешируемыми, то есть мы можем использовать их в качестве ключей в словарях, а также в качестве элементов в множествах.

Приведенный ниже код:

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7


print(set(Weekday))
```

выводит:

```no-highlight
{<Weekday.THURSDAY: 4>, <Weekday.SATURDAY: 6>, <Weekday.TUESDAY: 2>, <Weekday.MONDAY: 1>, <Weekday.WEDNESDAY: 3>, <Weekday.FRIDAY: 5>, <Weekday.SUNDAY: 7>}
```

**Примечание 6.** Если значениями элементов перечисления являются последовательные целые числа, начиная с `1`, мы можем не прописывать их явно, а воспользоваться функцией `auto()` из модуля `enum`.

Приведенный ниже код:

```python
from enum import Enum, auto

class Weekday(Enum):
    MONDAY = auto()
    TUESDAY = auto()
    WEDNESDAY = auto()
    THURSDAY = auto()
    FRIDAY = auto()
    SATURDAY = auto()
    SUNDAY = auto()


for day in Weekday:
    print(day.name, '->', day.value)
```

выводит:

```no-highlight
MONDAY -> 1
TUESDAY -> 2
WEDNESDAY -> 3
THURSDAY -> 4
FRIDAY -> 5
SATURDAY -> 6
SUNDAY -> 7
```

## 8.3 Битовые флаги, класс Flag
### Тема урока: битовые флаги, класс Flag

1. Битовые флаги
2. Операторы `|, &, ^` и `~`
3. Проверка на принадлежность
4. Нулевой элемент
5. Битовые флаги в Python 3.11

**Аннотация.** Урок посвящен битовым флагам в Python.

### Битовые флаги

Помимо класса `Enum` в модуле `enum` содержится класс `Flag`, с помощью которого можно создавать битовые флаги. Битовые флаги похожи на перечисления, однако в отличие от перечислений, элементы флагов поддерживают битовые операции с помощью операторов `|` (побитовое ИЛИ), `&` (побитовое И), `^` (побитовое исключающее ИЛИ) и `~` (побитовое НЕ).

В качестве флага рассмотрим класс `Color`, элементами которого являются цвета:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4
```

Первое, на что стоит обратить внимание во флаге `Color`, это на значения его элементов: все они являются **степенями двойки**. Элемент `RED` имеет значение `2^0`, `GREEN` — `2^1`, `BLUE` — `2^2`. Значениями элементов должны являться именно степени двойки для того, чтобы упомянутые выше битовые операции выполнялись корректно. Более очевидным необходимость таких значений становится в том случае, если записать их в двоичной системе счисления:

```python
from enum import Flag

class Color(Flag):
    RED = 1                                      # 001
    GREEN = 2                                    # 010
    BLUE = 4                                     # 100
```

Несложно заметить, что в двоичной записи значение каждого элемента состоит из нулей и одной единицы, причем позиция единицы для каждого значения уникальна. Таким образом, позиция единицы в двоичной записи значения и определяет элемент флага.

### Оператор |

С помощью оператора `|` можно объединить элементы флага. Например, в двоичной записи значения элемента `RED`  единица находится на последней позиции, элемента `GREEN` — на предпоследней позиции. Выполнив операцию побитового ИЛИ для значений элементов `RED` и `GREEN`, мы получим значение `011`, что соответствует объединению элементов `RED` и `GREEN`, так как единица в данном случае находится и на последней позиции, и на предпоследней.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined1 = Color.RED | Color.GREEN
combined2 = Color.RED | Color.GREEN | Color.BLUE

print(combined1)
print(combined2)
```

выводит:

```no-highlight
Color.GREEN|RED
Color.BLUE|GREEN|RED
```

Представление значений элементов флага в двоичной системе счисления и знание битовых операций позволяет удобно работать с элементами флага. Подробнее ознакомиться с битовыми операциями можно по [ссылке](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F).

Обратите внимание, что объект, полученный в результате какой-либо битовой операции между элементами флага, сам является элементом флага.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined1 = Color.RED | Color.GREEN
combined2 = Color.RED | Color.GREEN | Color.BLUE

print(type(combined1))
print(type(combined2))
```

выводит:

```no-highlight
<flag 'Color'>
<flag 'Color'>
```

Если он не является фактическим элементом флага (определенным внутри класса), то у него нет имени, однако есть значение.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined1 = Color.RED | Color.GREEN              # 011 в двоичной записи и 3 в десятичной
combined2 = Color.RED | Color.BLUE               # 101 в двоичной записи и 5 в десятичной

print(combined1.name)
print(combined1.value)
print(combined2.name)
print(combined2.value)
```

выводит:

```no-highlight
None
3
None
5
```

### Оператор ^

Имея объединение элементов, с помощью оператора `^` можно исключить элемент или несколько элементов из этого объединения.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined = Color.RED | Color.GREEN | Color.BLUE

print(combined ^ Color.RED)                      # исключаем Color.RED
print(combined ^ Color.GREEN)                    # исключаем Color.GREEN
print(combined ^ Color.BLUE)                     # исключаем Color.BLUE
print(combined ^ (Color.BLUE | Color.RED))       # исключаем Color.BLUE и Color.RED
```

выводит:

```no-highlight
Color.BLUE|GREEN
Color.BLUE|RED
Color.GREEN|RED
Color.GREEN
```

### Оператор &

Имея несколько объединений элементов, с помощью оператора `&` их можно пересечь и получить их общие элементы.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined1 = Color.RED | Color.GREEN | Color.BLUE
combined2 = Color.GREEN | Color.BLUE

print(combined1 & combined2)
print(combined1 & Color.RED)
```

выводит:

```no-highlight
Color.BLUE|GREEN
Color.RED
```

### Оператор ~

С помощью оператора `~` можно получить все элементы флага, кроме заданных.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


print(~Color.RED)                                # все элементы Color, кроме Color.RED
print(~Color.GREEN)                              # все элементы Color, кроме Color.GREEN
print(~Color.BLUE)                               # все элементы Color, кроме Color.BLUE
print(~(Color.RED | Color.GREEN))                # все элементы Color, кроме Color.RED и Color.GREEN
```

выводит:

```no-highlight
Color.BLUE|GREEN
Color.BLUE|RED
Color.GREEN|RED
Color.BLUE
```

### Проверка на принадлежность

Имея объединение элементов, проверить наличие в нем конкретного элемента или нескольких элементов можно с помощью оператора `in`.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined1 = Color.RED | Color.GREEN
combined2 = Color.RED | Color.GREEN | Color.BLUE

print(Color.RED in combined1)
print(Color.BLUE in combined1)
print(combined1 in combined2)
```

выводит:

```no-highlight
True
False
True
```

### Нулевой элемент

В результате битовых операций с элементами флага может получиться элемент с нулевым значением. Ошибки в данном случае не произойдет, так как флаг для подобных ситуаций автоматически определяет элемент с именем `None` и значением `0`.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined = ~(Color.RED | Color.GREEN | Color.BLUE)

print(combined)
print(combined.name)
print(combined.value)
```

выводит:

```no-highlight
Color.0
None
0
```

Иногда удобно определить подобный элемент в классе явно.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    NONE = 0
    RED = 1
    GREEN = 2
    BLUE = 4


zero_value = ~(Color.RED | Color.GREEN | Color.BLUE)

print(zero_value)
print(zero_value.name)
print(zero_value.value)
```

выводит:

```no-highlight
Color.NONE
NONE
0
```

### Битовые флаги в Python 3.11

С релизом Python 3.11 класс `Flag` был обновлен. Так, в новой версии языка элемент флага с нулевым значением получил новое строковое представление.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined = ~(Color.RED | Color.GREEN | Color.BLUE)

print(str(combined))
print(repr(combined))
```

в Python 3.10 выводит:

```no-highlight
Color.0
<Color.0: 0>
```

в то время как в Python 3.11 выводит:

```no-highlight
Color(0)
<Color: 0>
```

Элементы флага стали итерируемыми объектами, имеющими длину, которую можно получить с помощью встроенной функции `len()`.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined = Color.RED | Color.GREEN | Color.BLUE

print(len(Color.RED))
print(*Color.RED)
print(len(combined))
print(*combined)
```

в Python 3.10 приводит к возбуждению исключения:

```no-highlight
TypeError: object of type 'Color' has no len()
```

в то время как в Python 3.11 выводит:

```no-highlight
1
Color.RED
3
Color.RED Color.GREEN Color.BLUE
```

Также элементы флага, полученные в результате каких-либо битовых операций и не являющиеся его фактическими элементами, стали обладать именами.

Приведенный ниже код:

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


combined1 = Color.RED | Color.GREEN
combined2 = Color.RED | Color.BLUE

print(combined1.name)
print(combined2.name)
```

в Python 3.10 выводит:

```no-highlight
None
None
```

в то время как в Python 3.11 выводит:

```python
RED|GREEN
RED|BLUE
```

### Примечания

**Примечание 1.** Битовые флаги имеют весь функционал обычных перечислений: доступ к элементам, итерирование, сравнение на равенство и идентичность и т.д.

Приведенный ниже код:

```python
from  enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4


print(Color.RED)
print(Color(2))
print(Color['BLUE'])

for color in Color:
    print(color.name, color.value)
```

выводит:

```no-highlight
Color.RED
Color.GREEN
Color.BLUE
RED 1
GREEN 2
BLUE 4
```

**Примечание 2.** Для автоматической установки в качестве значений элементам флага степеней двойки можно использовать функцию `auto()`.

Приведенный ниже код:

```python
from enum import Flag, auto

class Color(Flag):
    RED = auto()
    GREEN = auto()
    BLUE = auto()


for color in Color:
    print(color.name, color.value)
```

выводит:

```no-highlight
RED 1
GREEN 2
BLUE 4
```

**Примечание 3.** С помощью класса `IntFlag` из модуля `enum` можно реализовать флаг, элементы которого получают весь функционал класса `int`. Подробнее о классе `IntFlag` можно почитать по [ссылке](https://docs.python.org/3/library/enum.html#enum.IntFlag).

**Примечание 4.** Хорошая статья на тему флагов и битовых операций доступна по [ссылке](https://dev.koshovyi.com/2020/10/22/bitovye-maski-i-flagi-v-net-c/).

## 8.4 Декораторы. Часть 1
### Тема урока: Декораторы

1. Декораторы
2. Декорирование методов
3. Классы декораторы

**Аннотация.** Урок посвящен различным видам декораторов в Python.

### Декораторы

Декораторы являются неотъемлемой частью языка Python и представляют собой инструмент, основной целью которого является расширение функционала функций. В прошлом курсе мы познакомились с большим количеством различных декораторов, как простых, так и сложных.

К более простым декораторам можно отнести те, которые не принимают никаких аргументов. В качестве такого примера рассмотрим декоратор `@do_twice`, выполняющий вызов декорируемой функции дважды.

Приведенный ниже код:

```python
import functools

def do_twice(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        for _ in range(2):
            value = func(*args, **kwargs)
        return value
    return wrapper

@do_twice
def greet(name):
    print(f'Привет, {name}!')


greet('Кемаль')
```

выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
```

Обратите внимание, что к вложенной функции `wrapper()` мы дополнительно применяем декоратор `@wraps` из модуля `functools`. Напомним, что данный декоратор используется для сохранения всей информации о декорируемой функции: ее имени, строки документации и т.д. Также стоит отметить, что форма декорирования через символ `@` является лишь краткой записью ручного декорирования `greet = do_twice(greet)`.

Преимущество ручного декорирования (без использования `@`) в том, что оно позволяет использовать обе версии функции: начальную и декорированную.

Более сложными являются декораторы с аргументами. В качестве такого примера рассмотрим декоратор `@do_n_times`, выполняющий вызов декорируемой функции `n` раз.

Приведенный ниже код:

```python
import functools

def do_n_times(n):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(n):
                value = func(*args, **kwargs)
            return value
        return wrapper
    return decorator

@do_n_times(4)
def greet(name):
    print(f'Привет, {name}!')


greet('Кемаль')
```

выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
```

Стоит отметить, что функция `do_n_times()`, по сути, не является декоратором, она возвращает декоратор. Однако для простоты мы называем ее декоратором с аргументами.

Уроки по декоратором из предыдущего курса доступны по [ссылке](https://stepik.org/lesson/640039/step/1?unit=636559) и [ссылке](https://stepik.org/lesson/640040/step/1?unit=636560).

### Декорирование методов

Есть два способа использования декораторов в классах, первым из которых является декорирование методов. С ним мы уже сталкивались, например, когда изучали статические методы и методы класса, которые реализуются с помощью декораторов `@staticmethod` и `@classmethod` соответственно.

К методам в классе мы также можем применять и собственные декораторы. Рассмотрим класс `Cat`, описывающий кошку, и задекорируем один из его методов приведенным выше декоратором `@do_n_times`.

Приведенный ниже код:

```python
import functools

def do_n_times(n):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(n):
                value = func(*args, **kwargs)
            return value
        return wrapper
    return decorator

class Cat:
    @do_n_times(4)
    def say(self):
        print('Мяу')


cat = Cat()

cat.say()
```

выводит:

```no-highlight
Мяу
Мяу
Мяу
Мяу
```

Вторым способом использования декораторов в классах является **декорирование всего класса**, но о нем мы поговорим позже.

### Классы декораторы

В общем случае декоратор представляет собой функцию, которая принимает в качестве аргумента функцию и возвращает новую функцию, которая заменяет переданную. Однако декоратор может возвращать не только функцию, но и вызываемый объект, который аналогичным образом способен заменить декорируемую функцию. Данный подход позволяет нам реализовывать декораторы не только с помощью функций, но и с помощью классов, экземпляры которых являются вызываемыми объектами, то есть содержат магический метод `__call__()`.

Рассмотрим класс декоратор `@do_twice`, выполняющий вызов декорируемой функции дважды.

Приведенный ниже код:

```python
class do_twice:
    def __init__(self, func):
        self.func = func                            # декорируемая функция
        
    def __call__(self, *args, **kwargs):
        for _ in range(2):
            value = self.func(*args, **kwargs)      # вызов декорируемой функции
        return value

def greet(name):
    print(f'Привет, {name}!')


greet = do_twice(greet)

greet('Кемаль')
```

выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
```

Класс `do_twice` имеет два метода `__init__()` и `__call__()`. Первый метод принимает в качестве аргумента декорируемую функцию и закрепляет ее за экземпляром класса `do_twice` в виде атрибута `func`. Второй метод делает экземпляр класса `do_twice` вызываемым объектом.

Таким образом, вызов `do_twice(greet)` возвращает экземпляр класса `do_twice`, который:

- внутренне хранит функцию `greet()` в виде атрибута `func`
- является вызываемым объектом и при вызове себя вызывает сохраненную функцию `greet()`

В итоге использование класса в качестве декоратора отличается лишь тем, что вместо вызова функции и получения функции, мы вызываем класс и получаем его экземпляр, который является вызываемым объектом.

Использование классов декораторов может быть выгодно тем, что они избавляют от тройной последовательной вложенности функций и делают код более простым для понимания.

Стоит отметить, что заменив функцию `greet()` на экземпляр класса `do_twice`, мы потеряли всю информацию о ней. Для сохранения информации о декорируемой функции нам необходимо воспользоваться функцией `update_wrapper()` из модуля `functools`.

Приведенный ниже код:

```python
import functools

class do_twice:
    def __init__(self, func):
        functools.update_wrapper(self, func)        # сохранение информации о декорируемой функции
        self.func = func
        
    def __call__(self, *args, **kwargs):
        for _ in range(2):
            value = self.func(*args, **kwargs)
        return value

@do_twice
def greet(name):
    """docstring"""
    print(f'Привет, {name}!')


print(greet.__name__)
print(greet.__doc__)
```

выводит:

```no-highlight
greet
docstring
```

Обратите внимание, что для сохранения информации о декорируемой функции нужно использовать функцию `update_wrapper()` модуля `functools`, вместо декоратора `@wraps`.

Класс декоратор также может выступать в качестве декоратора с аргументами. Рассмотрим класс декоратор `@do_n_times`, выполняющий вызов декорируемой функции `n` раз.

Приведенный ниже код:

```python
import functools

class do_n_times:
    def __init__(self, n):
        self.n = n
        
    def __call__(self, func):                       # передача декорируемой функции
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(self.n):
                value = func(*args, **kwargs)       # вызов декорируемой функции
            return value
        return wrapper

def greet(name):
    print(f'Привет, {name}!')


decorator = do_n_times(4)                           # создание экземпляра класса do_n_times
greet = decorator(greet)                            # вызов экземпляра класса do_n_times

greet('Кемаль')
```

выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
```

Здесь в метод `__init__()` уже передается не декорируемая функция, а число `n` — количество вызовов декорируемой функции. Сам экземпляр класса `do_n_times` также не является объектом, заменяющим декорируемую функцию, он является фактическим декоратором, так как при вызове себя принимает в качестве аргумента декорируемую функцию `func` и возвращает функцию `wrapper()`, которая и заменяет переданную.

Таким образом, вызов `do_n_times(4)` возвращает экземпляр класса `do_n_times`, который внутренне хранит лишь число `4` в виде атрибута `n`. Однако этот экземпляр класса `do_n_times` является вызываемым объектом, который принимает в качестве аргумента декорируемую функцию `greet()` и возвращает функцию `wrapper()`, которая, в свою очередь, внутренне хранит число `4` и функцию `greet()`, а также эту функцию `greet()` заменяет.

Используя синтаксис декораторов, приведенный выше код можно записать в более короткой форме:

```python
import functools

class do_n_times:
    def __init__(self, n):
        self.n = n
        
    def __call__(self, func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(self.n):
                value = func(*args, **kwargs)
            return value
        return wrapper

@do_n_times(4)
def greet(name):
    print(f'Привет, {name}!')


greet('Кемаль')
```

который так же выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
```

### Примечания

**Примечание 1.** При применении классов декораторов к методам в классе могут возникнуть проблемы, связанные с аргументом `self`. Подробнее о самой проблеме и способах ее решения можно почитать по [ссылке](https://stackoverflow.com/questions/5469956/python-decorator-self-is-mixed-up).

**Примечание 2.** Глубокие уровни наложения декораторов в итоге могут повлиять на производительность, поскольку они продолжают добавлять вложенные вызовы функций. Обычно на практике это не создает проблем, но об этом следует помнить, если вы работаете с кодом, требующим высокой производительности.

**Примечание 3.** Документация о декораторах на русском языке доступна по [ссылке](https://docs-python.ru/tutorial/dekoratory-python/).

**Примечание 4.** Наглядное представление декоратора:

![](https://ucarecdn.com/cb3c1660-9bbc-4caf-a406-d14c8f40cc43/)

## 8.5 Декораторы. Часть 2
### Тема урока: Декораторы

1. Декорирование классов
2. Примеры декорирования классов

**Аннотация.** Урок посвящен декораторам классов в Python.

### Декорирование классов

Как уже было сказано в прошлом уроке, декораторы можно применять не только к функциям и методам, но и к классам. Декорирование класса позволяет модифицировать поведение и содержание класса без изменения его исходного кода.

Синтаксически декорирование класса ничем не отличается от декорирования функции. Например, если у нас есть класс `MyClass` и декоратор `@decorator`, то применить второй к первому мы можем одним из следующих способов:

```python
# 1
    @decorator
    class MyClass:
        pass
# 2    ```
```python
    MyClass = decorator(MyClass)
    ```
### Примеры декорирования классов

Подход декорирования функции несколько отличается от декорирования класса. Если в первом случае мы заменяем функцию другой функцией или вызываемым объектом, то во втором случае мы модифицируем исходный класс и возвращаем его же. Конечно, мы можем аналогичным образом определить новый класс, который внутренне будет использовать декорируемый класс, и вернуть его, однако данный способ нецелесообразен ввиду своей сложности.

Рассмотрим несколько примеров декорирования классов в порядке увеличения их сложности.

**Пример 1.** Реализуем декоратор класса `@add_attr`, который добавляет декорируемому классу атрибут `attr` со значением `None`.

Приведенный ниже код:

```python
def add_attr(cls):
    cls.attr = None                                 # добавляем декорируемому классу атрибут attr
    return cls                                      # возвращаем декорируемый класс

@add_attr
class MyClass:
    pass


print(MyClass.attr)
```

выводит:

```no-highlight
None
```

Здесь декоратор `@add_attr` представляет собой функцию, которая принимает в качестве аргумента декорируемый класс, добавляет ему атрибут `attr` и возвращает его же. Стоит заметить, что в таком случае нам не нужно сохранять информацию о декорируемом классе, так как мы не определяем новый класс и все операции выполняем с исходным классом.

**Пример 2.** Реализуем декоратор класса `@add_attr_to_instances`, который добавляет экземплярам декорируемого класса атрибут `attr` со значением `None`.

Для реализации данного декоратора нам нужно вмешаться в процесс инициализации экземпляров декорируемого класса, то есть модифицировать метод `__init__()`. Сделать это мы можем путем определения нового инициализатора и подмены им исходного. Также важно предварительно сохранить исходный инициализатор, чтобы воспользоваться им в новом инициализаторе.

Приведенный ниже код:

```python
import functools

def add_attr_to_instances(cls):
    old_init = cls.__init__                         # сохраняем исходный инициализатор
    
    @functools.wraps(old_init)
    def new_init(self, *args, **kwargs):
        old_init(self, *args, **kwargs)             # вызываем исходный инициализатор
        self.attr = None                            # добавляем экземпляру класса атрибут attr
    
    cls.__init__ = new_init                         # заменяем исходный инициализатор новым
    return cls

@add_attr_to_instances
class MyClass:
    pass


obj = MyClass()

print(obj.attr)
```

выводит:

```no-highlight
None
```

Здесь, как и в прошлом примере, декоратор `@add_attr_to_instances` принимает в качестве аргумента класс, модифицирует его и возвращает. Сперва происходит сохранение исходного магического метода `__init__()` декорируемого класса в переменной `old_init`. Сделать это необходимо по той причине, что далее этот метод у класса будет заменен, и если мы не сохраним его, то потеряем к нему доступ.

После идет определение функции `new_init()`, которая представляет собой новый инициализатор, то есть функцию, заменяющую магический метод `__init__()` декорируемого класса. Сигнатура данной функции на первом месте содержит параметр `self`. Сделано это исключительно ради удобства, чтобы внутри функции обращаться к экземпляру декорируемого класса через имя `self`. Сигнатура функции может иметь вид `(*args, **kwargs)`, однако в данном случае экземпляр декорируемого класса будет доступен через `args[0]`.

Так как функция `new_init()` является новым инициализатором, в качестве первой операции она выполняет вызов исходного инициализатора, чтобы сохранить его функционал. Далее она выполняет свою задачу — добавляет экземпляру декорируемого класса атрибут `attr` со значением `None`.

Завершающим этапом является замена исходного инициализатора новым, после которой декорируемый класс по имени `__init__` будет содержать функцию `new_init()`, определенную выше, а не функцию `__init__()`, определенную в теле этого класса.

**Пример 3.** Реализуем декоратор класса `@add_attr_to_instances`, который принимает произвольное количество именованных аргументов и добавляет их экземплярам декорируемого класса в качестве атрибутов.

Приведенный ниже код:

```python
import functools

def add_attr_to_instances(**attrs):
    def decorator(cls):
        old_init = cls.__init__
    
        @functools.wraps(old_init)
        def new_init(self, *args, **kwargs):
            old_init(self, *args, **kwargs)
            self.__dict__.update(attrs)             # добавляем атрибуты экземпляру декорируемого класса
    
        cls.__init__ = new_init
        return cls
    
    return decorator

@add_attr_to_instances(first_attr=1, second_attr=2)
class MyClass:
    pass


obj = MyClass()

print(obj.first_attr)
print(obj.second_attr)
```

выводит:

```no-highlight
1
2
```

Решение в данном примере практически полностью повторяет решение из предыдущего примера. Отличие лишь в том, что здесь мы получаем дополнительный уровень вложенности, так как декоратор `@add_attr_to_instances` принимает в качестве аргументов имена и значения устанавливаемых атрибутов, а не класс. Фактическим декоратором является вложенная функция `decorator()`, возвращаемая декоратором `@add_attr_to_instances`. Именно она принимает в качестве аргумента класс, модифицирует его и возвращает.

**Пример 4.** Реализуем декоратор класса `@count_instances`, который считает количество созданных экземпляров декорируемого класса. Счетчик доступен по атрибуту `count`.

Приведенный ниже код:

```python
import functools

def count_instances(cls):
    old_init = cls.__init__
    cls.count = 0                                   # счетчик созданных экземпляров декорируемого класса
    
    @functools.wraps(old_init)
    def new_init(self, *args, **kwargs):
        old_init(self, *args, **kwargs)
        cls.count += 1                              # увеличение счетчика на единицу   
    
    cls.__init__ = new_init
    return cls

@count_instances
class MyClass:
    pass


print(MyClass.count)

for _ in range(10):
    obj = MyClass()

print(MyClass.count)
```

выводит:

```no-highlight
0
10
```

Так как функция `new_init()` является новым инициализатором, мы применяем к ней декоратор `@functools.wraps`, чтобы она содержала всю информацию исходного инициализатора: имя, строку документации и т.д.

### Примечания

**Примечание 1.** Декоратор класса имеет достаточно глубокие возможности по влиянию на класс: он может удалять, добавлять, менять, переименовывать атрибуты и методы класса. Поэтому следует понимать, что при декорировании исходный класс не всегда может быть использован так же, как прежде.
  
## 8.6 Модуль dataclasses 
### Тема урока: модуль dataclasses

1. Классы данных
2. Модуль `dataclasses`
3. Декоратор `@dataclass`

**Аннотация.** Урок посвящен модулю `dataclasses`.

### Классы данных

Иногда мы реализуем классы, экземпляры которых ведут себя как контейнеры для хранения информации, и при реализации каждого такого класса нам приходится тратить значительное количество времени на написание шаблонного кода, определяя массивный инициализатор с большим количеством аргументов. Решением этой проблемы являются **классы данных**, которые были добавлены в Python 3.7. Они призваны автоматизировать процесс определения классов, которые используются для хранения информации.

#### Создание

Рассмотрим класс `Person`, описывающий человека:

```python
class Person:
    def __init__(self, name, surname, age):
        self.name = name                                  # имя
        self.surname = surname                            # фамилия
        self.age = age                                    # возраст
```

Экземпляр данного класса содержит имя, фамилию и возраст человека, которые доступны по соответствующим атрибутам.

Приведенный ниже код:

```python
class Person:
    def __init__(self, name, surname, age):
        self.name = name
        self.surname = surname
        self.age = age


person = Person('Гвидо', 'ван Россум', 67)

print(person.name)
print(person.surname)
print(person.age)
```

выводит:

```no-highlight
Гвидо
ван Россум
67
```

Определить приведенный выше класс `Person` в виде класса данных мы можем следующим образом:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int
```

То есть, чтобы определить класс данных, мы должны воспользоваться декоратором `@dataclass` из модуля `dataclasses` и в теле класса перечислить имена всех атрибутов, которыми будут обладать его экземпляры. Также через двоеточие необходимо указать тип значения каждого атрибута.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int


person = Person('Гвидо', 'ван Россум', 67)

print(person.name)
print(person.surname)
print(person.age)
```

выводит:

```no-highlight
Гвидо
ван Россум
67
```

Аннотации типов в классах данных обязательно должны присутствовать, но не обязательно должны соблюдаться. Если мы не хотим указывать конкретный тип, мы можем указать тип `Any` из модуля `typing`.

Основным преимуществом классов данных является то, что они автоматически реализуют минимально необходимый базовый функционал, определяя методы `__init__(), __repr__()` и `__eq__()`, которые позволяют создавать экземпляры классов, выводить их в форматированном виде и сравнивать между собой.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int


person = Person('Гвидо', 'ван Россум', 67)

print(person)
print(person == Person('Илон', 'Маск', 51))
print(person == Person('Гвидо', 'ван Россум', 67))
```

выводит:

```no-highlight
Person(name='Гвидо', surname='ван Россум', age=67)
False
True
```

Альтернативным способом определения классов данных является использование функции `make_dataclass()` из модуля `dataclasses`. Данная функция принимает в качестве аргументов имя класса и итерируемый объект с именами атрибутов и возвращает соответствующий класс данных.

Приведенный ниже код:

```python
from dataclasses import make_dataclass

Person = make_dataclass('Person', ['name', 'surname', 'age'])

person = Person('Гвидо', 'ван Россум', 67)

print(person)
```

выводит:

```no-highlight
Person(name='Гвидо', surname='ван Россум', age=67)
```

Создание классов данных с помощью функции `make_dataclass()` очень похоже на создание именованных кортежей.

Прочитать про именованные кортежи можно в рамках нашего курса для профессионалов по [ссылке](https://stepik.org/lesson/590034/step/1?unit=584966).

#### Неизменяемость

По умолчанию экземпляры классов данных являются изменяемыми, поэтому мы можем без проблем менять значения их атрибутов, а также добавлять им новые атрибуты.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int


person = Person('Гвидо', 'ван Россум', 67)

person.name = 'Илон'
person.city = 'Бельмонт'

print(person.name)
print(person.city)
```

выводит:

```no-highlight
Илон
Бельмонт
```

Для того чтобы экземпляры класса данных были неизменяемыми, при его определении необходимо передать декоратору `@dataclass` в качестве параметра `frozen` значение `True`.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Person:
    name: str
    surname: str
    age: int


person = Person('Гвидо', 'ван Россум', 67)

person.name = 'Илон'
```

приводит к возбуждению исключения:

```no-highlight
dataclasses.FrozenInstanceError: cannot assign to field 'name'
```

#### Значения по умолчанию

При определении класса данных мы можем указывать атрибутам значения по умолчанию. Синтаксически это выглядит как присваивание переменной некоторого значения.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int = None                                       # возраст по умолчанию равен None


person1 = Person('Гвидо', 'ван Россум')
person2 = Person('Илон', 'Маск', 51)

print(person1)
print(person2)
```

выводит:

```no-highlight
Person(name='Гвидо', surname='ван Россум', age=None)
Person(name='Илон', surname='Маск', age=51)
```

Однако стоит помнить о том, что атрибуты без значений по умолчанию не могут стоять после атрибутов со значениями по умолчанию.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str = None
    surname: str = None
    age: int
```

приводит к возбуждению исключения:

```no-highlight
TypeError: non-default argument 'age' follows default argument
```

#### Функция field()

В классах данных изменяемые объекты нельзя указывать в качестве значений по умолчанию.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int
    friends: list = []                                    # список друзей
```

приводит к возбуждению исключения:

```no-highlight
ValueError: mutable default <class 'list'> for field friends is not allowed: use default_factory
```

Обусловлено это тем, что значения по умолчанию создаются единожды при определении класса. И если бы мы могли указывать изменяемые объекты в качестве значений по умолчанию, то все экземпляры класса данных использовали бы один и тот же объект, и изменение его в одном экземпляре приводило бы к его изменению во всех экземплярах.

Однако возможность использовать изменяемые объекты в качестве значений по умолчанию все же есть. Для этого необходимо воспользоваться функцией `field()` из модуля `dataclasses`, передав ей в качестве параметра `default_factory` функцию, возвращаемое значение которой и является желаемым значением по умолчанию.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int
    friends: list = field(default_factory=list)           # функция list(), возвращающая пустой список


person = Person('Гвидо', 'ван Россум', 67)

print(person.friends)
```

выводит:

```python
[]
```

Так как при вычислении значения по умолчанию атрибута `friends` вызывается функция `list()`, все экземпляры класса `Person` имеют в качестве этого атрибута созданный конкретно для них отдельный пустой список.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int
    friends: list = field(default_factory=list)


person1 = Person('Гвидо', 'ван Россум', 67)
person2 = Person('Илон', 'Маск', 51)

person1.friends.append(person2)

print(person1.friends)
print(person2.friends)
```

выводит:

```no-highlight
[Person(name='Илон', surname='Маск', age=51, friends=[])]
[]
```

Функция `field()` также может использоваться для указания простых значений по умолчанию. Для этого необходимо передать ей в качестве параметра `default` желаемое значение по умолчанию.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int = field(default=None)


person1 = Person('Гвидо', 'ван Россум')
person2 = Person('Илон', 'Маск', 51)

print(person1)
print(person2)
```

выводит:

```no-highlight
Person(name='Гвидо', surname='ван Россум', age=None)
Person(name='Илон', surname='Маск', age=51)
```

Помимо установки значений по умолчанию функция `field()` предлагает еще несколько возможностей.

**1.** Параметр `repr` определяет, будет ли атрибут отображаться в строковом представлении экземпляра класса. По умолчанию данный параметр имеет значение `True`.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int = field(repr=False)


person = Person('Гвидо', 'ван Россум', 67)

print(person)
print(person.age)
```

выводит:

```no-highlight
Person(name='Гвидо', surname='ван Россум')
67
```

**2.** Параметр `compare` определяет, будет ли атрибут учитываться при сравнении экземпляров класса. По умолчанию данный параметр имеет значение `True`.

 Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int = field(compare=False)


person1 = Person('Гвидо', 'ван Россум', 67)
person2 = Person('Гвидо', 'ван Россум', 68)

print(person1 == person2)
```

выводит:

```no-highlight
True
```

**3.** Параметр `init` определяет, будет ли атрибут участвовать при инициализации экземпляра класса. По умолчанию данный параметр имеет значение `True`.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int = field(init=False)


person = Person('Гвидо', 'ван Россум', 67)
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Person.__init__() takes 3 positional arguments but 4 were given
```

То есть если атрибут не участвует при инициализации экземпляра класса, то его значение не должно передаваться при создании этого экземпляра, так как инициализатор его не ждет. Также из этого следует, что экземпляр класса этим атрибутом обладать не будет.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int = field(init=False)


person = Person('Гвидо', 'ван Россум')

print(hasattr(person, 'age'))
```

выводит:

```no-highlight
False
```

Указание в качестве параметра `init` значения `False` в таком виде достаточно бесполезно, ведь атрибут определяется в теле класса, но никак не используется. Однако это может быть удобно при использовании метода `__post_init__()`, о котором будет сказано позже.

**4.** Параметр `hash` определяет, будет ли атрибут учитываться при вычислении хеш-значения экземпляра класса. По умолчанию данный параметр имеет значение `True`.

#### Метод __post_init__()

В классах данных есть возможность определить второй инициализатор в виде метода `__post_init__()`, который, если определен, автоматически вызывается после метода `__init__()`. Он может быть удобен в случаях, когда мы хотим добавить экземпляру класса атрибут, значение которого зависит от значений других атрибутов.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int
    fullname: str = None
    
    def __post_init__(self):
        self.fullname = self.name + ' ' + self.surname    # полное имя на основе имени и фамилии


person = Person('Гвидо', 'ван Россум', 67)

print(person.fullname)
```

выводит:

```no-highlight
Гвидо ван Россум
```

Если мы хотим, чтобы значение атрибута, вычисляемого на основе других, нельзя было указывать при создании экземпляра класса, мы можем воспользоваться функцией `field()`.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int
    fullname: str = field(init=False)
    
    def __post_init__(self):
        self.fullname = self.name + ' ' + self.surname


person = Person('Гвидо', 'ван Россум', 67)

print(person.fullname)
```

выводит:

```no-highlight
Гвидо ван Россум
```

В то время как приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    surname: str
    age: int
    fullname: str = field(init=False)
    
    def __post_init__(self):
        self.fullname = self.name + ' ' + self.surname


person = Person('Гвидо', 'ван Россум', 67, 'Гвидо ван Россум')
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Person.__init__() takes 4 positional arguments but 5 were given
```

#### Сравнение

По умолчанию экземпляры класса данных можно сравнивать между собой лишь на равенство.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int


person1 = Person('Гвидо', 'ван Россум', 67)
person2 = Person('Илон', 'Маск', 51)

print(person1 > person2)
```

приводит к возбуждению исключения:

```no-highlight
TypeError: '>' not supported between instances of 'Person' and 'Person'
```

Для того чтобы экземпляры класса данных можно было сравнивать на больше/меньше, при его определении необходимо передать декоратору `@dataclass` в качестве параметра `order` значение `True`.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass(order=True)
class Person:
    name: str
    surname: str
    age: int


person1 = Person('Гвидо', 'ван Россум', 67)
person2 = Person('Илон', 'Маск', 51)

print(person1 > person2)
```

выводит:

```no-highlight
False
```

Сравнение в таком случае подразумевает последовательное сравнение значений всех атрибутов, то есть сперва сравниваются значения атрибутов `name`, если они равны — сравниваются значения атрибутов `surname`, и так далее до первого несовпадения. В примере выше `person2` больше `person1`, так как `person2.name` больше `person1.name`. Таким образом, располагая атрибуты в теле класса в определенном порядке, мы можем контролировать их приоритет при сравнении.

Также мы можем использовать функцию `field()`, чтобы исключить атрибуты, которые не хотим учитывать при сравнении.

Приведенный ниже код:

```python
from dataclasses import dataclass, field

@dataclass(order=True)
class Person:
    name: str = field(compare=False)                      # атрибут не учитывается при сравнении
    surname: str = field(compare=False)                   # атрибут не учитывается при сравнении
    age: int


person1 = Person('Гвидо', 'ван Россум', 67)
person2 = Person('Илон', 'Маск', 51)

print(person1 > person2)
```

выводит:

```no-highlight
True
```

В примере выше при сравнении экземпляров класса `Person` учитываются только значения атрибутов `age`, поэтому `person1` больше `person2`, так как `person1.age` больше `person2.age`.

#### Дополнительные методы

Классы данных с точки зрения Python являются обычными классами, поэтому помимо атрибутов и реализованных по умолчанию магических методов `__init__(), __repr__()` и `__eq__()` они могут иметь произвольный набор дополнительных методов.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int
    
    def fullname(self):                                   # метод экземпляра, возвращающий полное имя
        return self.name + ' ' + self.surname


person = Person('Гвидо', 'ван Россум', 67)

print(person.fullname())
```

выводит:

```no-highlight
Гвидо ван Россум
```

Уже реализованные методы `__init__(), __repr__()` и `__eq__()` также могут быть переопределены, однако их рекомендуется оставлять неизменными.

 Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    surname: str
    age: int

    def __repr__(self):                                   # переопределенный метод __repr__()
        return self.name + ' ' + self.surname


person = Person('Гвидо', 'ван Россум', 67)

print(person)
```

выводит:

```no-highlight
Гвидо ван Россум
```

### Примечания

**Примечание 1.** Декоратор `@dataclass` имеет параметры `init, repr` и `eq`, отвечающие за автоматическую реализацию одноименных магических методов. По умолчанию данные параметры имеют значение `True`.

Приведенный ниже код:

```python
from dataclasses import dataclass

@dataclass(repr=False)                                    # не реализуем магический метод __repr__()
class Person:
    name: str
    surname: str
    age: int


person = Person('Гвидо', 'ван Россум', 67)

print(person)
```

выводит (адрес может отличаться):

```no-highlight
<__main__.Person object at 0x0000015692B574C0>
```

**Примечание 2.** В модуле `dataclasses` доступны функции `astuple()` и `asdict()`, которые используются для преобразования экземпляров классов данных в кортежи и словари соответственно.

Приведенный ниже код:

```python
from dataclasses import dataclass, astuple, asdict

@dataclass
class Person:
    name: str
    surname: str
    age: int


person = Person('Гвидо', 'ван Россум', 67)

print(astuple(person))
print(asdict(person))
```

выводит:

```no-highlight
('Гвидо', 'ван Россум', 67)
{'name': 'Гвидо', 'surname': 'ван Россум', 'age': 67}
```

**Примечание 3.** Подробнее о классах данных можно почитать на английском языке по [ссылке](https://realpython.com/python-data-classes/) и на русском языке по [ссылке](https://habr.com/ru/post/415829/) и [ссылке](https://habr.com/ru/company/otus/blog/650257/).

**Примечание 4.** Если модуль `dataclasses` вам показался интересным, вы также можете ознакомиться с его более функциональным аналогом — модулем `attrs`. Документация данного модуля доступна по [ссылке](https://attrs.org/en/stable/).